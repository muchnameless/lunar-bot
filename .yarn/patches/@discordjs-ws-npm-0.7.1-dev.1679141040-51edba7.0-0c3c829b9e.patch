diff --git a/dist/defaultWorker.js b/dist/defaultWorker.js
index 96c3dd0a2263813b8d6d85352a8bd43326afa655..acbd77d5c7bc2ea981403f85cd8f736225783607 100644
--- a/dist/defaultWorker.js
+++ b/dist/defaultWorker.js
@@ -373,6 +373,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   replayedEvents = 0;
   isAck = true;
   sendRateLimitState = getInitialSendRateLimitState();
+  initialHeartbeatTimeoutController = null;
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
@@ -455,6 +456,10 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     if (this.heartbeatInterval) {
       (0, import_node_timers.clearInterval)(this.heartbeatInterval);
     }
+    if (this.initialHeartbeatTimeoutController) {
+      this.initialHeartbeatTimeoutController.abort();
+      this.initialHeartbeatTimeoutController = null;
+    }
     this.lastHeartbeatAt = -1;
     if (options.recover !== WebSocketShardDestroyRecovery.Resume && this.session) {
       this.session = null;
@@ -492,7 +497,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       `Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`
     ]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
@@ -766,7 +771,20 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         this.debug([
           `Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`
         ]);
-        await (0, import_promises2.setTimeout)(firstWait);
+        try {
+          const controller = new AbortController();
+          this.initialHeartbeatTimeoutController = controller;
+          await (0, import_promises2.setTimeout)(firstWait, void 0, {
+            signal: controller.signal
+          });
+        } catch {
+          this.debug([
+            "Cancelled initial heartbeat due to #destroy being called"
+          ]);
+          return;
+        } finally {
+          this.initialHeartbeatTimeoutController = null;
+        }
         await this.heartbeat();
         this.debug([
           `First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`
diff --git a/dist/defaultWorker.mjs b/dist/defaultWorker.mjs
index 3f2b9fd1c9070ddee6e8b2b99cf8d342655526f0..bd4b4f536f0918e2a224f0a7db25ae9a0592c616 100644
--- a/dist/defaultWorker.mjs
+++ b/dist/defaultWorker.mjs
@@ -351,6 +351,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   replayedEvents = 0;
   isAck = true;
   sendRateLimitState = getInitialSendRateLimitState();
+  initialHeartbeatTimeoutController = null;
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
@@ -433,6 +434,10 @@ var WebSocketShard = class extends AsyncEventEmitter {
     if (this.heartbeatInterval) {
       clearInterval(this.heartbeatInterval);
     }
+    if (this.initialHeartbeatTimeoutController) {
+      this.initialHeartbeatTimeoutController.abort();
+      this.initialHeartbeatTimeoutController = null;
+    }
     this.lastHeartbeatAt = -1;
     if (options.recover !== WebSocketShardDestroyRecovery.Resume && this.session) {
       this.session = null;
@@ -470,7 +475,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
       `Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`
     ]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
@@ -744,7 +749,20 @@ var WebSocketShard = class extends AsyncEventEmitter {
         this.debug([
           `Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`
         ]);
-        await sleep2(firstWait);
+        try {
+          const controller = new AbortController();
+          this.initialHeartbeatTimeoutController = controller;
+          await sleep2(firstWait, void 0, {
+            signal: controller.signal
+          });
+        } catch {
+          this.debug([
+            "Cancelled initial heartbeat due to #destroy being called"
+          ]);
+          return;
+        } finally {
+          this.initialHeartbeatTimeoutController = null;
+        }
         await this.heartbeat();
         this.debug([
           `First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 6fd4b6c916c55d7ca645e91413e6e080955afa20..7329474005b987f0a4f78a8a5948fa9412a911f1 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -72,6 +72,7 @@ declare class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap>
     private replayedEvents;
     private isAck;
     private sendRateLimitState;
+    private initialHeartbeatTimeoutController;
     private heartbeatInterval;
     private lastHeartbeatAt;
     private session;
diff --git a/dist/index.js b/dist/index.js
index bf2febfa70b04c1bb34318605061fd8f9cc41c04..c5bde38265c391127d7df9038c54adcac19b4e6f 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -533,6 +533,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   replayedEvents = 0;
   isAck = true;
   sendRateLimitState = getInitialSendRateLimitState();
+  initialHeartbeatTimeoutController = null;
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
@@ -615,6 +616,10 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     if (this.heartbeatInterval) {
       (0, import_node_timers.clearInterval)(this.heartbeatInterval);
     }
+    if (this.initialHeartbeatTimeoutController) {
+      this.initialHeartbeatTimeoutController.abort();
+      this.initialHeartbeatTimeoutController = null;
+    }
     this.lastHeartbeatAt = -1;
     if (options.recover !== WebSocketShardDestroyRecovery.Resume && this.session) {
       this.session = null;
@@ -652,7 +657,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       `Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`
     ]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
@@ -926,7 +931,20 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         this.debug([
           `Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`
         ]);
-        await (0, import_promises2.setTimeout)(firstWait);
+        try {
+          const controller = new AbortController();
+          this.initialHeartbeatTimeoutController = controller;
+          await (0, import_promises2.setTimeout)(firstWait, void 0, {
+            signal: controller.signal
+          });
+        } catch {
+          this.debug([
+            "Cancelled initial heartbeat due to #destroy being called"
+          ]);
+          return;
+        } finally {
+          this.initialHeartbeatTimeoutController = null;
+        }
         await this.heartbeat();
         this.debug([
           `First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`
diff --git a/dist/index.mjs b/dist/index.mjs
index 564d813d4468221c2bf7a41cc3ae054149ee2ffb..8f594913f5115e2ebe649e6df7cc9f3966638a37 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -492,6 +492,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   replayedEvents = 0;
   isAck = true;
   sendRateLimitState = getInitialSendRateLimitState();
+  initialHeartbeatTimeoutController = null;
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
@@ -574,6 +575,10 @@ var WebSocketShard = class extends AsyncEventEmitter {
     if (this.heartbeatInterval) {
       clearInterval(this.heartbeatInterval);
     }
+    if (this.initialHeartbeatTimeoutController) {
+      this.initialHeartbeatTimeoutController.abort();
+      this.initialHeartbeatTimeoutController = null;
+    }
     this.lastHeartbeatAt = -1;
     if (options.recover !== WebSocketShardDestroyRecovery.Resume && this.session) {
       this.session = null;
@@ -611,7 +616,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
       `Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`
     ]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
@@ -885,7 +890,20 @@ var WebSocketShard = class extends AsyncEventEmitter {
         this.debug([
           `Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`
         ]);
-        await sleep2(firstWait);
+        try {
+          const controller = new AbortController();
+          this.initialHeartbeatTimeoutController = controller;
+          await sleep2(firstWait, void 0, {
+            signal: controller.signal
+          });
+        } catch {
+          this.debug([
+            "Cancelled initial heartbeat due to #destroy being called"
+          ]);
+          return;
+        } finally {
+          this.initialHeartbeatTimeoutController = null;
+        }
         await this.heartbeat();
         this.debug([
           `First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`
