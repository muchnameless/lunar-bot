diff --git a/src/client/websocket/WebSocketManager.js b/src/client/websocket/WebSocketManager.js
index f96cdf12e5affd4fd0582ebb8cffbe5f55169172..959039d9b3ed6cd5ca69912c190f44088aa874f4 100644
--- a/src/client/websocket/WebSocketManager.js
+++ b/src/client/websocket/WebSocketManager.js
@@ -1,10 +1,16 @@
 'use strict';

 const EventEmitter = require('node:events');
+const process = require('node:process');
 const { setImmediate } = require('node:timers');
-const { setTimeout: sleep } = require('node:timers/promises');
 const { Collection } = require('@discordjs/collection');
-const { GatewayCloseCodes, GatewayDispatchEvents, Routes } = require('discord-api-types/v10');
+const {
+  WebSocketManager: WSWebSocketManager,
+  WebSocketShardEvents: WSWebSocketShardEvents,
+  CompressionMethod,
+  CloseCodes,
+} = require('@discordjs/ws');
+const { GatewayCloseCodes, GatewayDispatchEvents } = require('discord-api-types/v10');
 const WebSocketShard = require('./WebSocketShard');
 const PacketHandlers = require('./handlers');
 const { DiscordjsError, ErrorCodes } = require('../../errors');
@@ -12,6 +18,13 @@ const Events = require('../../util/Events');
 const Status = require('../../util/Status');
 const WebSocketShardEvents = require('../../util/WebSocketShardEvents');

+let zlib = false;
+
+try {
+  require('zlib-sync');
+  zlib = true;
+} catch {} // eslint-disable-line no-empty
+
 const BeforeReadyWhitelist = [
   GatewayDispatchEvents.Ready,
   GatewayDispatchEvents.Resumed,
@@ -22,15 +35,17 @@ const BeforeReadyWhitelist = [
   GatewayDispatchEvents.GuildMemberRemove,
 ];

-const unrecoverableErrorCodeMap = {
-  [GatewayCloseCodes.AuthenticationFailed]: ErrorCodes.TokenInvalid,
-  [GatewayCloseCodes.InvalidShard]: ErrorCodes.ShardingInvalid,
-  [GatewayCloseCodes.ShardingRequired]: ErrorCodes.ShardingRequired,
-  [GatewayCloseCodes.InvalidIntents]: ErrorCodes.InvalidIntents,
-  [GatewayCloseCodes.DisallowedIntents]: ErrorCodes.DisallowedIntents,
-};
+const WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];

-const UNRESUMABLE_CLOSE_CODES = [1000, GatewayCloseCodes.AlreadyAuthenticated, GatewayCloseCodes.InvalidSeq];
+const UNRESUMABLE_CLOSE_CODES = [
+  CloseCodes.Normal,
+  GatewayCloseCodes.AlreadyAuthenticated,
+  GatewayCloseCodes.InvalidSeq,
+];
+
+const reasonIsDeprecated = 'the reason property is deprecated, use the code property to determine the reason';
+let deprecationEmittedForInvalidSessionEvent = false;
+let deprecationEmittedForDestroyedEvent = false;

 /**
  * The WebSocket manager for this client.
@@ -56,27 +71,12 @@ class WebSocketManager extends EventEmitter {
      */
     this.gateway = null;

-    /**
-     * The amount of shards this manager handles
-     * @private
-     * @type {number}
-     */
-    this.totalShards = this.client.options.shards.length;
-
     /**
      * A collection of all shards this manager handles
      * @type {Collection<number, WebSocketShard>}
      */
     this.shards = new Collection();

-    /**
-     * An array of shards to be connected or that need to reconnect
-     * @type {Set<WebSocketShard>}
-     * @private
-     * @name WebSocketManager#shardQueue
-     */
-    Object.defineProperty(this, 'shardQueue', { value: new Set(), writable: true });
-
     /**
      * An array of queued events before this WebSocketManager became ready
      * @type {Object[]}
@@ -99,11 +99,16 @@ class WebSocketManager extends EventEmitter {
     this.destroyed = false;

     /**
-     * If this manager is currently reconnecting one or multiple shards
-     * @type {boolean}
+     * @external WSWebSocketManager
+     * @see {@link https://discord.js.org/#/docs/ws/main/class/WebSocketManager}
+     */
+
+    /**
+     * The internal WebSocketManager from `@discordjs/ws`.
+     * @type {WSWebSocketManager}
      * @private
      */
-    this.reconnecting = false;
+    this._ws = null;
   }

   /**
@@ -119,11 +124,14 @@ class WebSocketManager extends EventEmitter {
   /**
    * Emits a debug message.
    * @param {string} message The debug message
-   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any
+   * @param {?number} [shardId] The id of the shard that emitted this message, if any
    * @private
    */
-  debug(message, shard) {
-    this.client.emit(Events.Debug, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);
+  debug(message, shardId) {
+    this.client.emit(
+      Events.Debug,
+      `[WS => ${typeof shardId === 'number' ? `Shard ${shardId}` : 'Manager'}] ${message}`,
+    );
   }

   /**
@@ -132,11 +140,37 @@ class WebSocketManager extends EventEmitter {
    */
   async connect() {
     const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);
+    const { shards, shardCount, intents, ws } = this.client.options;
+    if (this._ws && this._ws.options.token !== this.client.token) {
+      await this._ws.destroy({ code: CloseCodes.Normal, reason: 'Login with differing token requested' });
+      this._ws = null;
+    }
+    if (!this._ws) {
+      const wsOptions = {
+        intents: intents.bitfield,
+        rest: this.client.rest,
+        token: this.client.token,
+        largeThreshold: ws.large_threshold,
+        version: ws.version,
+        shardIds: shards === 'auto' ? null : shards,
+        shardCount: shards === 'auto' ? null : shardCount,
+        initialPresence: ws.presence,
+        retrieveSessionInfo: shardId => this.shards.get(shardId).sessionInfo,
+        updateSessionInfo: (shardId, sessionInfo) => {
+          this.shards.get(shardId).sessionInfo = sessionInfo;
+        },
+        compression: zlib ? CompressionMethod.ZlibStream : null,
+      };
+      if (ws.buildStrategy) wsOptions.buildStrategy = ws.buildStrategy;
+      this._ws = new WSWebSocketManager(wsOptions);
+      this.attachEvents();
+    }
+
     const {
       url: gatewayURL,
       shards: recommendedShards,
       session_start_limit: sessionStartLimit,
-    } = await this.client.rest.get(Routes.gatewayBot()).catch(error => {
+    } = await this._ws.fetchGatewayInformation().catch(error => {
       throw error.status === 401 ? invalidToken : error;
     });

@@ -152,156 +186,130 @@ class WebSocketManager extends EventEmitter {

     this.gateway = `${gatewayURL}/`;

-    let { shards } = this.client.options;
-
-    if (shards === 'auto') {
-      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);
-      this.totalShards = this.client.options.shardCount = recommendedShards;
-      shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);
-    }
-
-    this.totalShards = shards.length;
-    this.debug(`Spawning shards: ${shards.join(', ')}`);
-    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));
-
-    return this.createShards();
-  }
-
-  /**
-   * Handles the creation of a shard.
-   * @returns {Promise<boolean>}
-   * @private
-   */
-  async createShards() {
-    // If we don't have any shards to handle, return
-    if (!this.shardQueue.size) return false;
-
-    const [shard] = this.shardQueue;
-
-    this.shardQueue.delete(shard);
-
-    if (!shard.eventsAttached) {
-      shard.on(WebSocketShardEvents.AllReady, unavailableGuilds => {
-        /**
-         * Emitted when a shard turns ready.
-         * @event Client#shardReady
-         * @param {number} id The shard id that turned ready
-         * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any
-         */
-        this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);
-
-        if (!this.shardQueue.size) this.reconnecting = false;
-        this.checkShardsReady();
-      });
+    this.client.options.shardCount = await this._ws.getShardCount();
+    this.client.options.shards = await this._ws.getShardIds();
+    this.totalShards = this.client.options.shards.length;
+    for (const id of this.client.options.shards) {
+      if (!this.shards.has(id)) {
+        const shard = new WebSocketShard(this, id);
+        this.shards.set(id, shard);

-      shard.on(WebSocketShardEvents.Close, event => {
-        if (event.code === 1_000 ? this.destroyed : event.code in unrecoverableErrorCodeMap) {
+        shard.on(WebSocketShardEvents.AllReady, unavailableGuilds => {
           /**
-           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.
-           * @event Client#shardDisconnect
-           * @param {CloseEvent} event The WebSocket close event
-           * @param {number} id The shard id that disconnected
+           * Emitted when a shard turns ready.
+           * @event Client#shardReady
+           * @param {number} id The shard id that turned ready
+           * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any
            */
-          this.client.emit(Events.ShardDisconnect, event, shard.id);
-          this.debug(GatewayCloseCodes[event.code], shard);
-          return;
-        }
+          this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);

-        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {
-          // These event codes cannot be resumed
-          shard.sessionId = null;
-        }
-
-        /**
-         * Emitted when a shard is attempting to reconnect or re-identify.
-         * @event Client#shardReconnecting
-         * @param {number} id The shard id that is attempting to reconnect
-         */
-        this.client.emit(Events.ShardReconnecting, shard.id);
-
-        this.shardQueue.add(shard);
-
-        if (shard.sessionId) this.debug(`Session id is present, attempting an immediate reconnect...`, shard);
-        this.reconnect();
-      });
-
-      shard.on(WebSocketShardEvents.InvalidSession, () => {
-        this.client.emit(Events.ShardReconnecting, shard.id);
-      });
-
-      shard.on(WebSocketShardEvents.Destroyed, () => {
-        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);
-
-        this.client.emit(Events.ShardReconnecting, shard.id);
+          this.checkShardsReady();
+        });
+        shard.status = Status.Connecting;
+      }
+    }

-        this.shardQueue.add(shard);
-        this.reconnect();
-      });
+    await this._ws.connect();

-      shard.eventsAttached = true;
-    }
+    this.shards.forEach(shard => {
+      if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {
+        process.emitWarning(
+          'The WebSocketShard#invalidSession event is deprecated and will never emit.',
+          'DeprecationWarning',
+        );

-    this.shards.set(shard.id, shard);
-
-    try {
-      await shard.connect();
-    } catch (error) {
-      if (error?.code && error.code in unrecoverableErrorCodeMap) {
-        throw new DiscordjsError(unrecoverableErrorCodeMap[error.code]);
-        // Undefined if session is invalid, error event for regular closes
-      } else if (!error || error.code) {
-        this.debug('Failed to connect to the gateway, requeueing...', shard);
-        this.shardQueue.add(shard);
-      } else {
-        throw error;
+        deprecationEmittedForInvalidSessionEvent = true;
       }
-    }
-    // If we have more shards, add a 5s delay
-    if (this.shardQueue.size) {
-      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);
-      await sleep(5_000);
-      return this.createShards();
-    }
+      if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {
+        process.emitWarning(
+          'The WebSocketShard#destroyed event is deprecated and will never emit.',
+          'DeprecationWarning',
+        );

-    return true;
+        deprecationEmittedForDestroyedEvent = true;
+      }
+    });
   }

   /**
-   * Handles reconnects for this manager.
+   * Attaches event handlers to the internal WebSocketShardManager from `@discordjs/ws`.
    * @private
-   * @returns {Promise<boolean>}
    */
-  async reconnect() {
-    if (this.reconnecting || this.status !== Status.Ready) return false;
-    this.reconnecting = true;
-    try {
-      await this.createShards();
-    } catch (error) {
-      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);
-      if (error.httpStatus !== 401) {
-        this.debug(`Possible network error occurred. Retrying in 5s...`);
-        await sleep(5_000);
-        this.reconnecting = false;
-        return this.reconnect();
+  attachEvents() {
+    this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug(message, shardId));
+    this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {
+      this.client.emit(Events.Raw, data, shardId);
+      const shard = this.shards.get(shardId);
+      this.handlePacket(data, shard);
+      if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {
+        shard.gotGuild(data.d.id);
       }
-      // If we get an error at this point, it means we cannot reconnect anymore
-      if (this.client.listenerCount(Events.Invalidated)) {
+    });
+
+    this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {
+      this.shards.get(shardId).onReadyPacket(data);
+    });
+
+    this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {
+      const shard = this.shards.get(shardId);
+      shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });
+      if (UNRESUMABLE_CLOSE_CODES.includes(code) && this.destroyed) {
+        shard.status = Status.Disconnected;
         /**
-         * Emitted when the client's session becomes invalidated.
-         * You are expected to handle closing the process gracefully and preventing a boot loop
-         * if you are listening to this event.
-         * @event Client#invalidated
+         * Emitted when a shard's WebSocket disconnects and will no longer reconnect.
+         * @event Client#shardDisconnect
+         * @param {CloseEvent} event The WebSocket close event
+         * @param {number} id The shard id that disconnected
          */
-        this.client.emit(Events.Invalidated);
-        // Destroy just the shards. This means you have to handle the cleanup yourself
-        this.destroy();
+        this.client.emit(Events.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);
+        this.debug(GatewayCloseCodes[code], shardId);
+        return;
+      }
+
+      this.shards.get(shardId).status = Status.Connecting;
+      /**
+       * Emitted when a shard is attempting to reconnect or re-identify.
+       * @event Client#shardReconnecting
+       * @param {number} id The shard id that is attempting to reconnect
+       */
+      this.client.emit(Events.ShardReconnecting, shardId);
+    });
+    this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {
+      const shard = this.shards.get(shardId);
+      if (shard.sessionInfo) {
+        shard.closeSequence = shard.sessionInfo.sequence;
+        shard.status = Status.Resuming;
       } else {
-        this.client.destroy();
+        shard.status = Status.Identifying;
       }
-    } finally {
-      this.reconnecting = false;
-    }
-    return true;
+    });
+
+    this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {
+      const shard = this.shards.get(shardId);
+      shard.status = Status.Ready;
+      /**
+       * Emitted when the shard resumes successfully
+       * @event WebSocketShard#resumed
+       */
+      shard.emit(WebSocketShardEvents.Resumed);
+    });
+
+    this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {
+      this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`, shardId);
+      const shard = this.shards.get(shardId);
+      shard.lastPingTimestamp = heartbeatAt;
+      shard.ping = latency;
+    });
+
+    this._ws.on(WSWebSocketShardEvents.Error, err => {
+      /**
+       * Emitted whenever a shard's WebSocket encounters a connection error.
+       * @event Client#shardError
+       * @param {Error} error The encountered error
+       * @param {number} shardId The shard that encountered this error
+       */
+      this.client.emit(Events.ShardError, err, err.shardId);
+    });
   }

   /**
@@ -310,7 +318,7 @@ class WebSocketManager extends EventEmitter {
    * @private
    */
   broadcast(packet) {
-    for (const shard of this.shards.values()) shard.send(packet);
+    for (const shardId of this.shards.keys()) this._ws.send(shardId, packet);
   }

   /**
@@ -322,8 +330,7 @@ class WebSocketManager extends EventEmitter {
     // TODO: Make a util for getting a stack
     this.debug(`Manager was destroyed. Called by:\n${new Error().stack}`);
     this.destroyed = true;
-    this.shardQueue.clear();
-    for (const shard of this.shards.values()) shard.destroy({ closeCode: 1_000, reset: true, emit: false, log: false });
+    this._ws.destroy({ code: CloseCodes.Normal });
   }

   /**
@@ -345,7 +352,7 @@ class WebSocketManager extends EventEmitter {
       const item = this.packetQueue.shift();
       setImmediate(() => {
         this.handlePacket(item.packet, item.shard);
-      }).unref();
+      });
     }

     if (packet && PacketHandlers[packet.t]) {
diff --git a/src/client/websocket/WebSocketShard.js b/src/client/websocket/WebSocketShard.js
index c41b656360a7cb4efbb3a67c562fd3ae3f30d35a..df5e7765ba11cb71ab1b3366eb2153fe3e087ec9 100644
--- a/src/client/websocket/WebSocketShard.js
+++ b/src/client/websocket/WebSocketShard.js
@@ -1,22 +1,12 @@
 'use strict';

 const EventEmitter = require('node:events');
-const { setTimeout, setInterval, clearTimeout, clearInterval } = require('node:timers');
-const { GatewayDispatchEvents, GatewayIntentBits, GatewayOpcodes } = require('discord-api-types/v10');
-const WebSocket = require('../../WebSocket');
-const Events = require('../../util/Events');
+const process = require('node:process');
+const { setTimeout, clearTimeout } = require('node:timers');
+const { GatewayIntentBits } = require('discord-api-types/v10');
 const Status = require('../../util/Status');
 const WebSocketShardEvents = require('../../util/WebSocketShardEvents');

-const STATUS_KEYS = Object.keys(Status);
-const CONNECTION_STATE = Object.keys(WebSocket.WebSocket);
-
-let zlib;
-
-try {
-  zlib = require('zlib-sync');
-} catch {} // eslint-disable-line no-empty
-
 /**
  * Represents a Shard's WebSocket connection
  * @extends {EventEmitter}
@@ -43,13 +33,6 @@ class WebSocketShard extends EventEmitter {
      */
     this.status = Status.Idle;

-    /**
-     * The current sequence of the shard
-     * @type {number}
-     * @private
-     */
-    this.sequence = -1;
-
     /**
      * The sequence of the shard after close
      * @type {number}
@@ -57,20 +40,6 @@ class WebSocketShard extends EventEmitter {
      */
     this.closeSequence = 0;

-    /**
-     * The current session id of the shard
-     * @type {?string}
-     * @private
-     */
-    this.sessionId = null;
-
-    /**
-     * The resume url for this shard
-     * @type {?string}
-     * @private
-     */
-    this.resumeURL = null;
-
     /**
      * The previous heartbeat ping of the shard
      * @type {number}
@@ -83,81 +52,6 @@ class WebSocketShard extends EventEmitter {
      */
     this.lastPingTimestamp = -1;

-    /**
-     * If we received a heartbeat ack back. Used to identify zombie connections
-     * @type {boolean}
-     * @private
-     */
-    this.lastHeartbeatAcked = true;
-
-    /**
-     * Used to prevent calling {@link WebSocketShard#event:close} twice while closing or terminating the WebSocket.
-     * @type {boolean}
-     * @private
-     */
-    this.closeEmitted = false;
-
-    /**
-     * Contains the rate limit queue and metadata
-     * @name WebSocketShard#ratelimit
-     * @type {Object}
-     * @private
-     */
-    Object.defineProperty(this, 'ratelimit', {
-      value: {
-        queue: [],
-        total: 120,
-        remaining: 120,
-        time: 60e3,
-        timer: null,
-      },
-    });
-
-    /**
-     * The WebSocket connection for the current shard
-     * @name WebSocketShard#connection
-     * @type {?WebSocket}
-     * @private
-     */
-    Object.defineProperty(this, 'connection', { value: null, writable: true });
-
-    /**
-     * @external Inflate
-     * @see {@link https://www.npmjs.com/package/zlib-sync}
-     */
-
-    /**
-     * The compression to use
-     * @name WebSocketShard#inflate
-     * @type {?Inflate}
-     * @private
-     */
-    Object.defineProperty(this, 'inflate', { value: null, writable: true });
-
-    /**
-     * The HELLO timeout
-     * @name WebSocketShard#helloTimeout
-     * @type {?NodeJS.Timeout}
-     * @private
-     */
-    Object.defineProperty(this, 'helloTimeout', { value: null, writable: true });
-
-    /**
-     * The WebSocket timeout.
-     * @name WebSocketShard#wsCloseTimeout
-     * @type {?NodeJS.Timeout}
-     * @private
-     */
-    Object.defineProperty(this, 'wsCloseTimeout', { value: null, writable: true });
-
-    /**
-     * If the manager attached its event handlers on the shard
-     * @name WebSocketShard#eventsAttached
-     * @type {boolean}
-     * @private
-     */
-    Object.defineProperty(this, 'eventsAttached', { value: false, writable: true });
-
     /**
      * A set of guild ids this shard expects to receive
      * @name WebSocketShard#expectedGuilds
@@ -175,12 +69,17 @@ class WebSocketShard extends EventEmitter {
     Object.defineProperty(this, 'readyTimeout', { value: null, writable: true });

     /**
-     * Time when the WebSocket connection was opened
-     * @name WebSocketShard#connectedAt
-     * @type {number}
+     * @external SessionInfo
+     * @see {@link https://discord.js.org/#/docs/ws/main/typedef/SessionInfo}
+     */
+
+    /**
+     * The session info used by `@discordjs/ws` package.
+     * @name WebSocketShard#sessionInfo
+     * @type {?SessionInfo}
      * @private
      */
-    Object.defineProperty(this, 'connectedAt', { value: 0, writable: true });
+    Object.defineProperty(this, 'sessionInfo', { value: null, writable: true });
   }

   /**
@@ -189,161 +88,7 @@ class WebSocketShard extends EventEmitter {
    * @private
    */
   debug(message) {
-    this.manager.debug(message, this);
-  }
-
-  /**
-   * Connects the shard to the gateway.
-   * @private
-   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,
-   * or reject if we couldn't connect
-   */
-  connect() {
-    const { client } = this.manager;
-
-    if (this.connection?.readyState === WebSocket.OPEN && this.status === Status.Ready) {
-      return Promise.resolve();
-    }
-
-    const gateway = this.resumeURL ?? this.manager.gateway;
-
-    return new Promise((resolve, reject) => {
-      const cleanup = () => {
-        this.removeListener(WebSocketShardEvents.Close, onClose);
-        this.removeListener(WebSocketShardEvents.Ready, onReady);
-        this.removeListener(WebSocketShardEvents.Resumed, onResumed);
-        this.removeListener(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);
-        this.removeListener(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);
-      };
-
-      const onReady = () => {
-        cleanup();
-        resolve();
-      };
-
-      const onResumed = () => {
-        cleanup();
-        resolve();
-      };
-
-      const onClose = event => {
-        cleanup();
-        reject(event);
-      };
-
-      const onInvalidOrDestroyed = () => {
-        cleanup();
-        // eslint-disable-next-line prefer-promise-reject-errors
-        reject();
-      };
-
-      this.once(WebSocketShardEvents.Ready, onReady);
-      this.once(WebSocketShardEvents.Resumed, onResumed);
-      this.once(WebSocketShardEvents.Close, onClose);
-      this.once(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);
-      this.once(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);
-
-      if (this.connection?.readyState === WebSocket.OPEN) {
-        this.debug('An open connection was found, attempting an immediate identify.');
-        this.identify();
-        return;
-      }
-
-      if (this.connection) {
-        this.debug(`A connection object was found. Cleaning up before continuing.
-    State: ${CONNECTION_STATE[this.connection.readyState]}`);
-        this.destroy({ emit: false });
-      }
-
-      const wsQuery = { v: client.options.ws.version };
-
-      if (zlib) {
-        this.inflate = new zlib.Inflate({
-          chunkSize: 65535,
-          flush: zlib.Z_SYNC_FLUSH,
-          to: WebSocket.encoding === 'json' ? 'string' : '',
-        });
-        wsQuery.compress = 'zlib-stream';
-      }
-
-      this.debug(
-        `[CONNECT]
-    Gateway    : ${gateway}
-    Version    : ${client.options.ws.version}
-    Encoding   : ${WebSocket.encoding}
-    Compression: ${zlib ? 'zlib-stream' : 'none'}`,
-      );
-
-      this.status = this.status === Status.Disconnected ? Status.Reconnecting : Status.Connecting;
-      this.setHelloTimeout();
-
-      this.connectedAt = Date.now();
-
-      // Adding a handshake timeout to just make sure no zombie connection appears.
-      const ws = (this.connection = WebSocket.create(gateway, wsQuery, { handshakeTimeout: 30_000 }));
-      ws.onopen = this.onOpen.bind(this);
-      ws.onmessage = this.onMessage.bind(this);
-      ws.onerror = this.onError.bind(this);
-      ws.onclose = this.onClose.bind(this);
-    });
-  }
-
-  /**
-   * Called whenever a connection is opened to the gateway.
-   * @private
-   */
-  onOpen() {
-    this.debug(`[CONNECTED] Took ${Date.now() - this.connectedAt}ms`);
-    this.status = Status.Nearly;
-  }
-
-  /**
-   * Called whenever a message is received.
-   * @param {MessageEvent} event Event received
-   * @private
-   */
-  onMessage({ data }) {
-    let raw;
-    if (data instanceof ArrayBuffer) data = new Uint8Array(data);
-    if (zlib) {
-      const l = data.length;
-      const flush =
-        l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;
-
-      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);
-      if (!flush) return;
-      raw = this.inflate.result;
-    } else {
-      raw = data;
-    }
-    let packet;
-    try {
-      packet = WebSocket.unpack(raw);
-    } catch (err) {
-      this.manager.client.emit(Events.ShardError, err, this.id);
-      return;
-    }
-    this.manager.client.emit(Events.Raw, packet, this.id);
-    if (packet.op === GatewayOpcodes.Dispatch) this.manager.emit(packet.t, packet.d, this.id);
-    this.onPacket(packet);
-  }
-
-  /**
-   * Called whenever an error occurs with the WebSocket.
-   * @param {ErrorEvent} event The error that occurred
-   * @private
-   */
-  onError(event) {
-    const error = event?.error ?? event;
-    if (!error) return;
-
-    /**
-     * Emitted whenever a shard's WebSocket encounters a connection error.
-     * @event Client#shardError
-     * @param {Error} error The encountered error
-     * @param {number} shardId The shard that encountered this error
-     */
-    this.manager.client.emit(Events.ShardError, error, this.id);
+    this.manager.debug(message, this.id);
   }

   /**
@@ -351,43 +96,11 @@ class WebSocketShard extends EventEmitter {
    * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}
    */

-  /**
-   * @external ErrorEvent
-   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}
-   */
-
-  /**
-   * @external MessageEvent
-   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}
-   */
-
-  /**
-   * Called whenever a connection to the gateway is closed.
-   * @param {CloseEvent} event Close event that was received
-   * @private
-   */
-  onClose(event) {
-    this.closeEmitted = true;
-    if (this.sequence !== -1) this.closeSequence = this.sequence;
-    this.sequence = -1;
-    this.setHeartbeatTimer(-1);
-    this.setHelloTimeout(-1);
-    // Clearing the WebSocket close timeout as close was emitted.
-    this.setWsCloseTimeout(-1);
-    // If we still have a connection object, clean up its listeners
-    if (this.connection) {
-      this._cleanupConnection();
-      // Having this after _cleanupConnection to just clean up the connection and not listen to ws.onclose
-      this.destroy({ reset: !this.sessionId, emit: false, log: false });
-    }
-    this.status = Status.Disconnected;
-    this.emitClose(event);
-  }
-
   /**
    * This method is responsible to emit close event for this shard.
    * This method helps the shard reconnect.
    * @param {CloseEvent} [event] Close event that was received
+   * @deprecated
    */
   emitClose(
     event = {
@@ -410,93 +123,35 @@ class WebSocketShard extends EventEmitter {
   }

   /**
-   * Called whenever a packet is received.
+   * Called when the shard receives the READY payload.
    * @param {Object} packet The received packet
    * @private
    */
-  onPacket(packet) {
+  onReadyPacket(packet) {
     if (!packet) {
       this.debug(`Received broken packet: '${packet}'.`);
       return;
     }

-    switch (packet.t) {
-      case GatewayDispatchEvents.Ready:
-        /**
-         * Emitted when the shard receives the READY payload and is now waiting for guilds
-         * @event WebSocketShard#ready
-         */
-        this.emit(WebSocketShardEvents.Ready);
-
-        this.sessionId = packet.d.session_id;
-        this.resumeURL = packet.d.resume_gateway_url;
-        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));
-        this.status = Status.WaitingForGuilds;
-        this.debug(`[READY] Session ${this.sessionId} | Resume url ${this.resumeURL}.`);
-        this.lastHeartbeatAcked = true;
-        this.sendHeartbeat('ReadyHeartbeat');
-        break;
-      case GatewayDispatchEvents.Resumed: {
-        /**
-         * Emitted when the shard resumes successfully
-         * @event WebSocketShard#resumed
-         */
-        this.emit(WebSocketShardEvents.Resumed);
-
-        this.status = Status.Ready;
-        const replayed = packet.s - this.closeSequence;
-        this.debug(`[RESUMED] Session ${this.sessionId} | Replayed ${replayed} events.`);
-        this.lastHeartbeatAcked = true;
-        this.sendHeartbeat('ResumeHeartbeat');
-        break;
-      }
-    }
+    /**
+     * Emitted when the shard receives the READY payload and is now waiting for guilds
+     * @event WebSocketShard#ready
+     */
+    this.emit(WebSocketShardEvents.Ready);

-    if (packet.s > this.sequence) this.sequence = packet.s;
+    this.expectedGuilds = new Set(packet.guilds.map(d => d.id));
+    this.status = Status.WaitingForGuilds;
+  }

-    switch (packet.op) {
-      case GatewayOpcodes.Hello:
-        this.setHelloTimeout(-1);
-        this.setHeartbeatTimer(packet.d.heartbeat_interval);
-        this.identify();
-        break;
-      case GatewayOpcodes.Reconnect:
-        this.debug('[RECONNECT] Discord asked us to reconnect');
-        this.destroy({ closeCode: 4_000 });
-        break;
-      case GatewayOpcodes.InvalidSession:
-        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);
-        // If we can resume the session, do so immediately
-        if (packet.d) {
-          this.identifyResume();
-          return;
-        }
-        // Reset the sequence
-        this.sequence = -1;
-        // Reset the session id as it's invalid
-        this.sessionId = null;
-        // Set the status to reconnecting
-        this.status = Status.Reconnecting;
-        // Finally, emit the INVALID_SESSION event
-        /**
-         * Emitted when the session has been invalidated.
-         * @event WebSocketShard#invalidSession
-         */
-        this.emit(WebSocketShardEvents.InvalidSession);
-        break;
-      case GatewayOpcodes.HeartbeatAck:
-        this.ackHeartbeat();
-        break;
-      case GatewayOpcodes.Heartbeat:
-        this.sendHeartbeat('HeartbeatRequest', true);
-        break;
-      default:
-        this.manager.handlePacket(packet, this);
-        if (this.status === Status.WaitingForGuilds && packet.t === GatewayDispatchEvents.GuildCreate) {
-          this.expectedGuilds.delete(packet.d.id);
-          this.checkReady();
-        }
-    }
+  /**
+   * Called when a GuildCreate or GuildDelete for this shard was sent after READY payload was received,
+   * but before we emitted the READY event.
+   * @param {Snowflake} guildId the id of the Guild sent in the payload
+   * @private
+   */
+  gotGuild(guildId) {
+    this.expectedGuilds.delete(guildId);
+    this.checkReady();
   }

   /**
@@ -543,197 +198,12 @@ class WebSocketShard extends EventEmitter {
         );

         this.readyTimeout = null;
-
         this.status = Status.Ready;

         this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
       },
       hasGuildsIntent ? waitGuildTimeout : 0,
-    ).unref();
-  }
-
-  /**
-   * Sets the HELLO packet timeout.
-   * @param {number} [time] If set to -1, it will clear the hello timeout
-   * @private
-   */
-  setHelloTimeout(time) {
-    if (time === -1) {
-      if (this.helloTimeout) {
-        this.debug('Clearing the HELLO timeout.');
-        clearTimeout(this.helloTimeout);
-        this.helloTimeout = null;
-      }
-      return;
-    }
-    this.debug('Setting a HELLO timeout for 20s.');
-    this.helloTimeout = setTimeout(() => {
-      this.debug('Did not receive HELLO in time. Destroying and connecting again.');
-      this.destroy({ reset: true, closeCode: 4009 });
-    }, 20_000).unref();
-  }
-
-  /**
-   * Sets the WebSocket Close timeout.
-   * This method is responsible for detecting any zombie connections if the WebSocket fails to close properly.
-   * @param {number} [time] If set to -1, it will clear the timeout
-   * @private
-   */
-  setWsCloseTimeout(time) {
-    if (this.wsCloseTimeout) {
-      this.debug('[WebSocket] Clearing the close timeout.');
-      clearTimeout(this.wsCloseTimeout);
-    }
-    if (time === -1) {
-      this.wsCloseTimeout = null;
-      return;
-    }
-    this.wsCloseTimeout = setTimeout(() => {
-      this.setWsCloseTimeout(-1);
-      this.debug(`[WebSocket] Close Emitted: ${this.closeEmitted}`);
-      // Check if close event was emitted.
-      if (this.closeEmitted) {
-        this.debug(
-          `[WebSocket] was closed. | WS State: ${CONNECTION_STATE[this.connection?.readyState ?? WebSocket.CLOSED]}`,
-        );
-        // Setting the variable false to check for zombie connections.
-        this.closeEmitted = false;
-        return;
-      }
-
-      this.debug(
-        `[WebSocket] did not close properly, assuming a zombie connection.\nEmitting close and reconnecting again.`,
-      );
-
-      // Cleanup connection listeners
-      if (this.connection) this._cleanupConnection();
-
-      this.emitClose({
-        code: 4009,
-        reason: 'Session time out.',
-        wasClean: false,
-      });
-    }, time);
-  }
-
-  /**
-   * Sets the heartbeat timer for this shard.
-   * @param {number} time If -1, clears the interval, any other number sets an interval
-   * @private
-   */
-  setHeartbeatTimer(time) {
-    if (time === -1) {
-      if (this.heartbeatInterval) {
-        this.debug('Clearing the heartbeat interval.');
-        clearInterval(this.heartbeatInterval);
-        this.heartbeatInterval = null;
-      }
-      return;
-    }
-    this.debug(`Setting a heartbeat interval for ${time}ms.`);
-    // Sanity checks
-    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
-    this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time).unref();
-  }
-
-  /**
-   * Sends a heartbeat to the WebSocket.
-   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect
-   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent
-   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.
-   * @private
-   */
-  sendHeartbeat(
-    tag = 'HeartbeatTimer',
-    ignoreHeartbeatAck = [Status.WaitingForGuilds, Status.Identifying, Status.Resuming].includes(this.status),
-  ) {
-    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {
-      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);
-    } else if (!this.lastHeartbeatAcked) {
-      this.debug(
-        `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.
-    Status          : ${STATUS_KEYS[this.status]}
-    Sequence        : ${this.sequence}
-    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`,
-      );
-
-      this.destroy({ reset: true, closeCode: 4009 });
-      return;
-    }
-
-    this.debug(`[${tag}] Sending a heartbeat.`);
-    this.lastHeartbeatAcked = false;
-    this.lastPingTimestamp = Date.now();
-    this.send({ op: GatewayOpcodes.Heartbeat, d: this.sequence }, true);
-  }
-
-  /**
-   * Acknowledges a heartbeat.
-   * @private
-   */
-  ackHeartbeat() {
-    this.lastHeartbeatAcked = true;
-    const latency = Date.now() - this.lastPingTimestamp;
-    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);
-    this.ping = latency;
-  }
-
-  /**
-   * Identifies the client on the connection.
-   * @private
-   * @returns {void}
-   */
-  identify() {
-    return this.sessionId ? this.identifyResume() : this.identifyNew();
-  }
-
-  /**
-   * Identifies as a new connection on the gateway.
-   * @private
-   */
-  identifyNew() {
-    const { client } = this.manager;
-    if (!client.token) {
-      this.debug('[IDENTIFY] No token available to identify a new session.');
-      return;
-    }
-
-    this.status = Status.Identifying;
-
-    // Clone the identify payload and assign the token and shard info
-    const d = {
-      ...client.options.ws,
-      intents: client.options.intents.bitfield,
-      token: client.token,
-      shard: [this.id, Number(client.options.shardCount)],
-    };
-
-    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount} with intents: ${d.intents}`);
-    this.send({ op: GatewayOpcodes.Identify, d }, true);
-  }
-
-  /**
-   * Resumes a session on the gateway.
-   * @private
-   */
-  identifyResume() {
-    if (!this.sessionId) {
-      this.debug('[RESUME] No session id was present; identifying as a new session.');
-      this.identifyNew();
-      return;
-    }
-
-    this.status = Status.Resuming;
-
-    this.debug(`[RESUME] Session ${this.sessionId}, sequence ${this.closeSequence}`);
-
-    const d = {
-      token: this.manager.client.token,
-      session_id: this.sessionId,
-      seq: this.closeSequence,
-    };
-
-    this.send({ op: GatewayOpcodes.Resume, d }, true);
+    );
   }

   /**
@@ -743,161 +213,16 @@ class WebSocketShard extends EventEmitter {
    * Do not use this method if you don't know what you're doing.</warn>
    * @param {Object} data The full packet to send
    * @param {boolean} [important=false] If this packet should be added first in queue
+   * <warn>This parameter is **deprecated**. Important payloads are determined by their opcode instead.</warn>
    */
   send(data, important = false) {
-    this.ratelimit.queue[important ? 'unshift' : 'push'](data);
-    this.processQueue();
-  }
-
-  /**
-   * Sends data, bypassing the queue.
-   * @param {Object} data Packet to send
-   * @returns {void}
-   * @private
-   */
-  _send(data) {
-    if (this.connection?.readyState !== WebSocket.OPEN) {
-      this.debug(
-        `Tried to send packet '${JSON.stringify(data).replaceAll(
-          this.manager.client.token,
-          this.manager.client._censoredToken,
-        )}' but no WebSocket is available!`,
+    if (important) {
+      process.emitWarning(
+        'Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.',
+        'DeprecationWarning',
       );
-      this.destroy({ closeCode: 4_000 });
-      return;
     }
-
-    this.connection.send(WebSocket.pack(data), err => {
-      if (err) this.manager.client.emit(Events.ShardError, err, this.id);
-    });
-  }
-
-  /**
-   * Processes the current WebSocket queue.
-   * @returns {void}
-   * @private
-   */
-  processQueue() {
-    if (this.ratelimit.remaining === 0) return;
-    if (this.ratelimit.queue.length === 0) return;
-    if (this.ratelimit.remaining === this.ratelimit.total) {
-      this.ratelimit.timer = setTimeout(() => {
-        this.ratelimit.remaining = this.ratelimit.total;
-        this.processQueue();
-      }, this.ratelimit.time).unref();
-    }
-    while (this.ratelimit.remaining > 0) {
-      const item = this.ratelimit.queue.shift();
-      if (!item) return;
-      this._send(item);
-      this.ratelimit.remaining--;
-    }
-  }
-
-  /**
-   * Destroys this shard and closes its WebSocket connection.
-   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard
-   * @private
-   */
-  destroy({ closeCode = 1_000, reset = false, emit = true, log = true } = {}) {
-    if (log) {
-      this.debug(`[DESTROY]
-    Close Code    : ${closeCode}
-    Reset         : ${reset}
-    Emit DESTROYED: ${emit}`);
-    }
-
-    // Step 0: Remove all timers
-    this.setHeartbeatTimer(-1);
-    this.setHelloTimeout(-1);
-
-    this.debug(
-      `[WebSocket] Destroy: Attempting to close the WebSocket. | WS State: ${
-        CONNECTION_STATE[this.connection?.readyState ?? WebSocket.CLOSED]
-      }`,
-    );
-    // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED
-    if (this.connection) {
-      // If the connection is currently opened, we will (hopefully) receive close
-      if (this.connection.readyState === WebSocket.OPEN) {
-        this.connection.close(closeCode);
-        this.debug(`[WebSocket] Close: Tried closing. | WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
-      } else {
-        // Connection is not OPEN
-        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
-        // Remove listeners from the connection
-        this._cleanupConnection();
-        // Attempt to close the connection just in case
-        try {
-          this.connection.close(closeCode);
-        } catch (err) {
-          this.debug(
-            `[WebSocket] Close: Something went wrong while closing the WebSocket: ${
-              err.message || err
-            }. Forcefully terminating the connection | WS State: ${CONNECTION_STATE[this.connection.readyState]}`,
-          );
-          this.connection.terminate();
-        }
-
-        // Emit the destroyed event if needed
-        if (emit) this._emitDestroyed();
-      }
-    } else if (emit) {
-      // We requested a destroy, but we had no connection. Emit destroyed
-      this._emitDestroyed();
-    }
-
-    this.debug(
-      `[WebSocket] Adding a WebSocket close timeout to ensure a correct WS reconnect.
-        Timeout: ${this.manager.client.options.closeTimeout}ms`,
-    );
-    this.setWsCloseTimeout(this.manager.client.options.closeTimeout);
-
-    // Step 2: Null the connection object
-    this.connection = null;
-
-    // Step 3: Set the shard status to disconnected
-    this.status = Status.Disconnected;
-
-    // Step 4: Cache the old sequence (use to attempt a resume)
-    if (this.sequence !== -1) this.closeSequence = this.sequence;
-
-    // Step 5: Reset the sequence, resume url and session id if requested
-    if (reset) {
-      this.sequence = -1;
-      this.sessionId = null;
-      this.resumeURL = null;
-    }
-
-    // Step 6: reset the rate limit data
-    this.ratelimit.remaining = this.ratelimit.total;
-    this.ratelimit.queue.length = 0;
-    if (this.ratelimit.timer) {
-      clearTimeout(this.ratelimit.timer);
-      this.ratelimit.timer = null;
-    }
-  }
-
-  /**
-   * Cleans up the WebSocket connection listeners.
-   * @private
-   */
-  _cleanupConnection() {
-    this.connection.onopen = this.connection.onclose = this.connection.onmessage = null;
-    this.connection.onerror = () => null;
-  }
-
-  /**
-   * Emits the DESTROYED event on the shard
-   * @private
-   */
-  _emitDestroyed() {
-    /**
-     * Emitted when a shard is destroyed, but no WebSocket connection was present.
-     * @private
-     * @event WebSocketShard#destroyed
-     */
-    this.emit(WebSocketShardEvents.Destroyed);
+    this.manager._ws.send(this.id, data);
   }
 }

diff --git a/src/client/websocket/handlers/RESUMED.js b/src/client/websocket/handlers/RESUMED.js
index 39824bc9242d9bdff8aabf7607b117e7b71602c0..27ed7ddc5df31c657c371466c4649f62ae1963e3 100644
--- a/src/client/websocket/handlers/RESUMED.js
+++ b/src/client/websocket/handlers/RESUMED.js
@@ -3,7 +3,7 @@
 const Events = require('../../../util/Events');

 module.exports = (client, packet, shard) => {
-  const replayed = shard.sequence - shard.closeSequence;
+  const replayed = shard.sessionInfo.sequence - shard.closeSequence;
   /**
    * Emitted when a shard resumes successfully.
    * @event Client#shardResume
diff --git a/src/errors/ErrorCodes.js b/src/errors/ErrorCodes.js
index 3f074a1dad066a25bb13772506fa58d7daf51f53..6f256c556f2ab2f747cd6e224aa99c35ad2c0910 100644
--- a/src/errors/ErrorCodes.js
+++ b/src/errors/ErrorCodes.js
@@ -275,7 +275,6 @@ const keys = [

   'InteractionAlreadyReplied',
   'InteractionNotReplied',
-  'InteractionEphemeralReplied',

   'CommandInteractionOptionNotFound',
   'CommandInteractionOptionType',
diff --git a/src/errors/Messages.js b/src/errors/Messages.js
index 1b79ec030023ce6411d607e7ccfd431fe6c1de55..adf2a1be495f20853a5a3e01e39b583b29f7acb2 100644
--- a/src/errors/Messages.js
+++ b/src/errors/Messages.js
@@ -136,7 +136,6 @@ const Messages = {

   [DjsErrorCodes.InteractionAlreadyReplied]: 'The reply to this interaction has already been sent or deferred.',
   [DjsErrorCodes.InteractionNotReplied]: 'The reply to this interaction has not been sent or deferred.',
-  [DjsErrorCodes.InteractionEphemeralReplied]: 'Ephemeral responses cannot be deleted.',

   [DjsErrorCodes.CommandInteractionOptionNotFound]: name => `Required option "${name}" not found.`,
   [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) =>
diff --git a/src/index.js b/src/index.js
index d5a585f67468a1fdc4b4f360356dbcb36e319ccd..c7c530ced537a2c646e7034ba37fba2f578368fb 100644
--- a/src/index.js
+++ b/src/index.js
@@ -204,11 +204,10 @@ exports.WidgetMember = require('./structures/WidgetMember');
 exports.WelcomeChannel = require('./structures/WelcomeChannel');
 exports.WelcomeScreen = require('./structures/WelcomeScreen');

-exports.WebSocket = require('./WebSocket');
-
 // External
 __exportStar(require('discord-api-types/v10'), exports);
 __exportStar(require('@discordjs/builders'), exports);
 __exportStar(require('@discordjs/formatters'), exports);
 __exportStar(require('@discordjs/rest'), exports);
 __exportStar(require('@discordjs/util'), exports);
+__exportStar(require('@discordjs/ws'), exports);
diff --git a/src/managers/GuildManager.js b/src/managers/GuildManager.js
index 1d2d4ba967724319fca7e47e063ee9474e83e923..7e56936a4af06a5748f06cb34a9f4bea0a75e591 100644
--- a/src/managers/GuildManager.js
+++ b/src/managers/GuildManager.js
@@ -235,7 +235,7 @@ class GuildManager extends CachedManager {
           this.client.removeListener(Events.GuildCreate, handleGuild);
           this.client.decrementMaxListeners();
           resolve(this.client.guilds._add(data));
-        }, 10_000).unref();
+        }, 10_000);
       })
     );
   }
diff --git a/src/managers/GuildMemberManager.js b/src/managers/GuildMemberManager.js
index a4cf09b5d07e31f0dc60ebe8a01eed85928ff2d4..32c591cdf457f9beb5ed910f29f5ef64975fa4c9 100644
--- a/src/managers/GuildMemberManager.js
+++ b/src/managers/GuildMemberManager.js
@@ -265,7 +265,7 @@ class GuildMemberManager extends CachedManager {
         this.client.removeListener(Events.GuildMembersChunk, handler);
         this.client.decrementMaxListeners();
         reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));
-      }, time).unref();
+      }, time);
       this.client.incrementMaxListeners();
       this.client.on(Events.GuildMembersChunk, handler);
     });
diff --git a/src/structures/AttachmentBuilder.js b/src/structures/AttachmentBuilder.js
index e2e7cf5179cd1250aedf0d7cf51b044daecab703..350b88a0dec297aad9637cf1c3ebe8e1350d92fc 100644
--- a/src/structures/AttachmentBuilder.js
+++ b/src/structures/AttachmentBuilder.js
@@ -1,16 +1,16 @@
 'use strict';

-const { basename, flatten } = require('../util/Util');
+const { isJSONEncodable } = require('@discordjs/builders');
+const { basename } = require('../util/Util');

 /**
  * Represents an attachment builder
  */
 class AttachmentBuilder {
   /**
-   * @param {BufferResolvable|Stream} attachment The file
-   * @param {AttachmentData} [data] Extra data
+   * @param {AttachmentPayload} [payload] Attachment and extra data
    */
-  constructor(attachment, data = {}) {
+  constructor({ attachment, name, description } = {}) {
     /**
      * The file associated with this attachment.
      * @type {BufferResolvable|Stream}
@@ -20,12 +20,12 @@ class AttachmentBuilder {
      * The name of this attachment
      * @type {?string}
      */
-    this.name = data.name;
+    this.name = name;
     /**
      * The description of the attachment
      * @type {?string}
      */
-    this.description = data.description;
+    this.description = description;
   }

   /**
@@ -82,11 +82,11 @@ class AttachmentBuilder {
    * @readonly
    */
   get spoiler() {
-    return basename(this.name).startsWith('SPOILER_');
+    return this.name ? basename(this.name).startsWith('SPOILER_') : false;
   }

   toJSON() {
-    return flatten(this);
+    return { ...this };
   }

   /**
@@ -95,10 +95,10 @@ class AttachmentBuilder {
    * @returns {AttachmentBuilder}
    */
   static from(other) {
-    return new AttachmentBuilder(other.attachment, {
-      name: other.name,
-      description: other.description,
-    });
+    if (isJSONEncodable(other)) {
+      return new this(other.toJSON());
+    }
+    return new this(other);
   }
 }

diff --git a/src/structures/Embed.js b/src/structures/Embed.js
index dd68120d955b53019d973f03057740d52f814fe0..5436e854c18807335adef1613b8da974b6de3acc 100644
--- a/src/structures/Embed.js
+++ b/src/structures/Embed.js
@@ -18,11 +18,11 @@ class Embed {

   /**
    * An array of fields of this embed.
-   * @type {Array<APIEmbedField>}
+   * @type {?Array<APIEmbedField>}
    * @readonly
    */
   get fields() {
-    return this.data.fields ?? [];
+    return this.data.fields ?? null;
   }

   /**
diff --git a/src/structures/GuildEmoji.js b/src/structures/GuildEmoji.js
index f3bf22dcb496dc563aef7e5a987024ee7eb3767e..efddf66a7d5107c29224496f132c3abe8f6e787a 100644
--- a/src/structures/GuildEmoji.js
+++ b/src/structures/GuildEmoji.js
@@ -55,8 +55,9 @@ class GuildEmoji extends BaseGuildEmoji {
    * @readonly
    */
   get deletable() {
-    if (!this.guild.members.me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
-    return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits.ManageEmojisAndStickers);
+    const { me } = this.guild.members;
+    if (!me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
+    return !this.managed && me.permissions.has(PermissionFlagsBits.ManageEmojisAndStickers);
   }

   /**
diff --git a/src/structures/GuildMember.js b/src/structures/GuildMember.js
index 7c2aec177895a3837619ed06e6ea06d75fed30dd..140ec4573cb417d6b2eaf7e87e6f43875a12ee34 100644
--- a/src/structures/GuildMember.js
+++ b/src/structures/GuildMember.js
@@ -264,8 +264,9 @@ class GuildMember extends Base {
     if (this.user.id === this.guild.ownerId) return false;
     if (this.user.id === this.client.user.id) return false;
     if (this.client.user.id === this.guild.ownerId) return true;
-    if (!this.guild.members.me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
-    return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
+    const { me } = this.guild.members;
+    if (!me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
+    return me.roles.highest.comparePositionTo(this.roles.highest) > 0;
   }

   /**
@@ -274,7 +275,6 @@ class GuildMember extends Base {
    * @readonly
    */
   get kickable() {
-    if (!this.guild.members.me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
     return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.KickMembers);
   }

@@ -284,7 +284,6 @@ class GuildMember extends Base {
    * @readonly
    */
   get bannable() {
-    if (!this.guild.members.me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
     return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.BanMembers);
   }

@@ -297,7 +296,7 @@ class GuildMember extends Base {
     return (
       !this.permissions.has(PermissionFlagsBits.Administrator) &&
       this.manageable &&
-      (this.guild.members.me?.permissions.has(PermissionFlagsBits.ModerateMembers) ?? false)
+      this.guild.members.me.permissions.has(PermissionFlagsBits.ModerateMembers)
     );
   }

diff --git a/src/structures/GuildTemplate.js b/src/structures/GuildTemplate.js
index c1e219b5e2a0685deb3d46ba5b421cab2393b863..6f71745b51397fbad827916f14c25e4620f79077 100644
--- a/src/structures/GuildTemplate.js
+++ b/src/structures/GuildTemplate.js
@@ -149,7 +149,7 @@ class GuildTemplate extends Base {
       client.incrementMaxListeners();
       client.on(Events.GuildCreate, handleGuild);

-      const timeout = setTimeout(() => resolveGuild(client.guilds._add(data)), 10_000).unref();
+      const timeout = setTimeout(() => resolveGuild(client.guilds._add(data)), 10_000);
     });
   }

diff --git a/src/structures/Invite.js b/src/structures/Invite.js
index 19014ff6954351e79f7a2905c00e6023ff9a2f15..dcba2015c5cb3626c10b075b35cf44489054c089 100644
--- a/src/structures/Invite.js
+++ b/src/structures/Invite.js
@@ -234,10 +234,11 @@ class Invite extends Base {
   get deletable() {
     const guild = this.guild;
     if (!guild || !this.client.guilds.cache.has(guild.id)) return false;
-    if (!guild.members.me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
+    const { me } = guild.members;
+    if (!me) throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
     return Boolean(
       this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageChannels, false) ||
-        guild.members.me.permissions.has(PermissionFlagsBits.ManageGuild),
+        me.permissions.has(PermissionFlagsBits.ManageGuild),
     );
   }

diff --git a/src/structures/Message.js b/src/structures/Message.js
index f3f13a6fd6d6abc4ae2f93828e6f7c8ef64b0127..1ec821c4e6992242c0523756c1b00500442f68f2 100644
--- a/src/structures/Message.js
+++ b/src/structures/Message.js
@@ -320,10 +320,13 @@ class Message extends Base {
       this.client.channels._add(data.thread, this.guild);
     }

-    if (this.member && data.member) {
-      this.member._patch(data.member);
-    } else if (data.member && this.guild && this.author) {
-      this.guild.members._add(Object.assign(data.member, { user: this.author }));
+    if (data.member) {
+      const { member } = this;
+      if (member) {
+        member._patch(data.member);
+      } else if (this.author) {
+        this.guild?.members._add(Object.assign(data.member, { user: this.author }));
+      }
     }

     if ('flags' in data) {
@@ -601,19 +604,23 @@ class Message extends Base {
    * @readonly
    */
   get editable() {
-    const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable));
+    const { channel } = this;

     // Regardless of permissions thread messages cannot be edited if
     // the thread is archived or the thread is locked and the bot does not have permission to manage threads.
-    if (this.channel?.isThread()) {
-      if (this.channel.archived) return false;
-      if (this.channel.locked) {
-        const permissions = this.permissionsFor(this.client.user);
+    if (channel?.isThread()) {
+      if (channel.archived) return false;
+      if (channel.locked) {
+        const permissions = channel.permissionsFor(this.client.user);
         if (!permissions?.has(PermissionFlagsBits.ManageThreads, true)) return false;
       }
     }

-    return precheck;
+    return Boolean(
+      this.author.id === this.client.user.id &&
+        !this.flags.has(MessageFlags.Ephemeral) &&
+        (!this.guildId || channel?.viewable),
+    );
   }

   /**
@@ -624,15 +631,19 @@ class Message extends Base {
   get deletable() {
     if (!DeletableMessageTypes.includes(this.type)) return false;

-    if (!this.guild) {
+    if (this.flags.has(MessageFlags.Ephemeral)) {
+      return false;
+    }
+    if (!this.guildId) {
       return this.author.id === this.client.user.id;
     }
     // DMChannel does not have viewable property, so check viewable after proved that message is on a guild.
-    if (!this.channel?.viewable) {
+    const { channel } = this;
+    if (!channel?.viewable) {
       return false;
     }

-    const permissions = this.channel?.permissionsFor(this.client.user);
+    const permissions = channel?.permissionsFor(this.client.user);
     if (!permissions) return false;
     // This flag allows deleting even if timed out
     if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;
@@ -671,7 +682,8 @@ class Message extends Base {
     const { channel } = this;
     return Boolean(
       !this.system &&
-        (!this.guild ||
+        !this.flags.has(MessageFlags.Ephemeral) &&
+        (!this.guildId ||
           (channel?.viewable &&
             channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false))),
     );
@@ -702,7 +714,7 @@ class Message extends Base {
     const { channel } = this;
     return Boolean(
       channel?.type === ChannelType.GuildAnnouncement &&
-        !this.flags.has(MessageFlags.Crossposted) &&
+        !this.flags.any(MessageFlags.Crossposted | MessageFlags.Ephemeral) &&
         this.type === MessageType.Default &&
         channel.viewable &&
         channel.permissionsFor(this.client.user)?.has(bitfield, false),
@@ -720,8 +732,9 @@ class Message extends Base {
    *   .catch(console.error);
    */
   edit(options) {
-    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
-    return this.channel.messages.edit(this, options);
+    const { channel } = this;
+    if (!channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
+    return channel.messages.edit(this, options);
   }

   /**
@@ -736,8 +749,9 @@ class Message extends Base {
    * }
    */
   crosspost() {
-    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
-    return this.channel.messages.crosspost(this.id);
+    const { channel } = this;
+    if (!channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
+    return channel.messages.crosspost(this.id);
   }

   /**
@@ -751,8 +765,9 @@ class Message extends Base {
    *   .catch(console.error)
    */
   async pin(reason) {
-    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);
-    await this.channel.messages.pin(this.id, reason);
+    const { channel } = this;
+    if (!channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);
+    await channel.messages.pin(this.id, reason);
     return this;
   }

@@ -767,8 +782,9 @@ class Message extends Base {
    *   .catch(console.error)
    */
   async unpin(reason) {
-    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);
-    await this.channel.messages.unpin(this.id, reason);
+    const { channel } = this;
+    if (!channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);
+    await channel.messages.unpin(this.id, reason);
     return this;
   }

@@ -788,13 +804,14 @@ class Message extends Base {
    *   .catch(console.error);
    */
   async react(emoji) {
-    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);
-    await this.channel.messages.react(this.id, emoji);
+    const { channel } = this;
+    if (!channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);
+    await channel.messages.react(this.id, emoji);

     return this.client.actions.MessageReactionAdd.handle(
       {
         [this.client.actions.injectedUser]: this.client.user,
-        [this.client.actions.injectedChannel]: this.channel,
+        [this.client.actions.injectedChannel]: channel,
         [this.client.actions.injectedMessage]: this,
         emoji: resolvePartialEmoji(emoji),
       },
@@ -812,8 +829,9 @@ class Message extends Base {
    *   .catch(console.error);
    */
   async delete() {
-    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);
-    await this.channel.messages.delete(this.id);
+    const { channel } = this;
+    if (!channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);
+    await channel.messages.delete(this.id);
     return this;
   }

@@ -836,7 +854,8 @@ class Message extends Base {
    *   .catch(console.error);
    */
   reply(options) {
-    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
+    const { channel } = this;
+    if (!channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
     let data;

     if (options instanceof MessagePayload) {
@@ -849,7 +868,7 @@ class Message extends Base {
         },
       });
     }
-    return this.channel.send(data);
+    return channel.send(data);
   }

   /**
@@ -869,12 +888,13 @@ class Message extends Base {
    * @returns {Promise<ThreadChannel>}
    */
   startThread(options = {}) {
-    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
-    if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
+    const { channel } = this;
+    if (!channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
+    if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(channel.type)) {
       return Promise.reject(new DiscordjsError(ErrorCodes.MessageThreadParent));
     }
     if (this.hasThread) return Promise.reject(new DiscordjsError(ErrorCodes.MessageExistingThread));
-    return this.channel.threads.create({ ...options, startMessage: this });
+    return channel.threads.create({ ...options, startMessage: this });
   }

   /**
@@ -883,8 +903,9 @@ class Message extends Base {
    * @returns {Promise<Message>}
    */
   fetch(force = true) {
-    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
-    return this.channel.messages.fetch({ message: this.id, force });
+    const { channel } = this;
+    if (!channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
+    return channel.messages.fetch({ message: this.id, force });
   }

   /**
diff --git a/src/structures/MessagePayload.js b/src/structures/MessagePayload.js
index 372c1cf4b375499dd6a1a7175c219111f8a05272..a6a08d9027fdcf34119051824f9613ee08c39c8b 100644
--- a/src/structures/MessagePayload.js
+++ b/src/structures/MessagePayload.js
@@ -4,7 +4,6 @@ const { Buffer } = require('node:buffer');
 const { isJSONEncodable } = require('@discordjs/builders');
 const { lazy } = require('@discordjs/util');
 const { MessageFlags } = require('discord-api-types/v10');
-const ActionRowBuilder = require('./ActionRowBuilder');
 const { DiscordjsRangeError, ErrorCodes } = require('../errors');
 const DataResolver = require('../util/DataResolver');
 const MessageFlagsBitField = require('../util/MessageFlagsBitField');
@@ -134,7 +133,9 @@ class MessagePayload {
       }
     }

-    const components = this.options.components?.map(c => (isJSONEncodable(c) ? c : new ActionRowBuilder(c)).toJSON());
+    const components = this.options.components?.map(c =>
+      isJSONEncodable(c) ? c.toJSON() : this.target.client.options.jsonTransformer(c),
+    );

     let username;
     let avatarURL;
@@ -219,9 +220,9 @@ class MessagePayload {
    * @returns {Promise<MessagePayload>}
    */
   async resolveFiles() {
-    if (this.files) return this;
+    if (this.files || !this.options.files) return this;

-    this.files = await Promise.all(this.options.files?.map(file => this.constructor.resolveFile(file)) ?? []);
+    this.files = await Promise.all(this.options.files.map(file => this.constructor.resolveFile(file)));
     return this;
   }

diff --git a/src/structures/ModalSubmitFields.js b/src/structures/ModalSubmitFields.js
index 8e67b21d2e6f225f11aa02d90849eac6d0f6f392..220b4314659b8397d8546991c884f5b9ac2aaeca 100644
--- a/src/structures/ModalSubmitFields.js
+++ b/src/structures/ModalSubmitFields.js
@@ -50,6 +50,15 @@ class ModalSubmitFields {
   getTextInputValue(customId) {
     return this.getField(customId, ComponentType.TextInput).value;
   }
+
+  /**
+   * Gets the values of a select menu component given a custom id
+   * @param {string} customId The custom id for the select menu component
+   * @returns {string[]}
+   */
+  getSelectMenuValues(customId) {
+    return this.getField(customId, ComponentType.SelectMenu).values;
+  }
 }

 module.exports = ModalSubmitFields;
diff --git a/src/structures/interfaces/Collector.js b/src/structures/interfaces/Collector.js
index 65f411744035becfe8c760bad46898d9d2abc91b..1f2edae08f380b31eaeee5fb0c89d0d4c718c14c 100644
--- a/src/structures/interfaces/Collector.js
+++ b/src/structures/interfaces/Collector.js
@@ -93,8 +93,8 @@ class Collector extends EventEmitter {
     this.handleCollect = this.handleCollect.bind(this);
     this.handleDispose = this.handleDispose.bind(this);

-    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();
-    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();
+    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time);
+    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle);

     /**
      * The timestamp at which this collector last collected an item
@@ -135,7 +135,7 @@ class Collector extends EventEmitter {
         this.lastCollectedTimestamp = Date.now();
         if (this._idletimeout) {
           clearTimeout(this._idletimeout);
-          this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();
+          this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle);
         }
       } else {
         /**
@@ -247,11 +247,11 @@ class Collector extends EventEmitter {
   resetTimer({ time, idle } = {}) {
     if (this._timeout) {
       clearTimeout(this._timeout);
-      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();
+      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time);
     }
     if (this._idletimeout) {
       clearTimeout(this._idletimeout);
-      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();
+      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle);
     }
   }

diff --git a/src/util/Options.js b/src/util/Options.js
index 0602c3d3abd619f294c31dfdc08cf399a7d8e155..7410ea196a16bc12d76d8c9637958729e4404199 100644
--- a/src/util/Options.js
+++ b/src/util/Options.js
@@ -65,6 +65,8 @@ const { version } = require('../../package.json');
  * sent in the initial guild member list, must be between 50 and 250
  * @property {number} [version=10] The Discord gateway version to use <warn>Changing this can break the library;
  * only set this if you know what you are doing</warn>
+ * @property {Function} [buildStrategy] Builds the strategy to use for sharding;
+ * example: `(manager) => new WorkerShardingStrategy(manager, { shardsPerWorker: 2 })`
  */

 /**
@@ -95,7 +97,6 @@ class Options extends null {
       sweepers: this.DefaultSweeperSettings,
       ws: {
         large_threshold: 50,
-        compress: false,
         properties: {
           os: process.platform,
           browser: 'discord.js',
@@ -200,3 +201,13 @@ module.exports = Options;
  * @external RESTOptions
  * @see {@link https://discord.js.org/docs/packages/rest/main/RESTOptions:Interface}
  */
+
+/**
+ * @external WSWebSocketManager
+ * @see {@link https://discord.js.org/#/docs/ws/main/class/WebSocketManager}
+ */
+
+/**
+ * @external IShardingStrategy
+ * @see {@link https://discord.js.org/#/docs/ws/main/typedef/IShardingStrategy}
+ */
diff --git a/src/util/Sweepers.js b/src/util/Sweepers.js
index 79ca54d44a974d1238b90e6ba24302a2558ba18b..e29076b1cad5bf19c54b8cc6e79da02f7abd8222 100644
--- a/src/util/Sweepers.js
+++ b/src/util/Sweepers.js
@@ -460,7 +460,7 @@ class Sweepers {
       if (sweepFn === null) return;
       if (typeof sweepFn !== 'function') throw new DiscordjsTypeError(ErrorCodes.SweepFilterReturn);
       this[sweepKey](sweepFn);
-    }, opts.interval * 1_000).unref();
+    }, opts.interval * 1_000);
   }
 }

diff --git a/typings/index.d.ts b/typings/index.d.ts
index fb06027cefd300f1151feeb25822a33cdaa62dab..9b018b8d91814359f7247a5e08a30cec6bb24561 100644
--- a/typings/index.d.ts
+++ b/typings/index.d.ts
@@ -1,6 +1,3 @@
-// DOM types required for undici
-/// <reference lib="dom" />
-
 import {
   ActionRowBuilder as BuilderActionRow,
   MessageActionRowComponentBuilder,
@@ -40,6 +37,7 @@ import {
 import { Awaitable, JSONEncodable } from '@discordjs/util';
 import { Collection } from '@discordjs/collection';
 import { BaseImageURLOptions, ImageURLOptions, RawFile, REST, RESTOptions } from '@discordjs/rest';
+import { WebSocketManager as WSWebSocketManager, IShardingStrategy, SessionInfo } from '@discordjs/ws';
 import {
   APIActionRowComponent,
   APIApplicationCommandInteractionData,
@@ -308,7 +306,13 @@ export type MessageActionRowComponent =
   | RoleSelectMenuComponent
   | MentionableSelectMenuComponent
   | ChannelSelectMenuComponent;
-export type ModalActionRowComponent = TextInputComponent;
+export type ModalActionRowComponent =
+  | TextInputComponent
+  | StringSelectMenuComponent
+  | UserSelectMenuComponent
+  | RoleSelectMenuComponent
+  | MentionableSelectMenuComponent
+  | ChannelSelectMenuComponent;

 export class ActionRow<T extends MessageActionRowComponent | ModalActionRowComponent> extends Component<
   APIActionRowComponent<APIMessageActionRowComponent | APIModalActionRowComponent>
@@ -685,6 +689,7 @@ export class ButtonInteraction<Cached extends CacheType = CacheType> extends Mes
     ButtonComponent,
     APIButtonComponent,
     ButtonComponent | APIButtonComponent,
+    ButtonComponent | APIButtonComponent,
     ButtonComponent | APIButtonComponent
   >;
   public inGuild(): this is ButtonInteraction<'raw' | 'cached'>;
@@ -852,7 +857,7 @@ export class EmbedBuilder extends BuildersEmbed {
 export class Embed {
   private constructor(data: APIEmbed);
   public readonly data: Readonly<APIEmbed>;
-  public get fields(): APIEmbedField[];
+  public get fields(): APIEmbedField[] | null;
   public get footer(): EmbedFooterData | null;
   public get title(): string | null;
   public get description(): string | null;
@@ -1700,7 +1705,7 @@ export class IntentsBitField extends BitField<GatewayIntentsString> {
   public static resolve(bit?: BitFieldResolvable<GatewayIntentsString, number>): number;
 }

-export type CacheType = 'cached' | 'raw' | undefined;
+export type CacheType = 'cached' | 'raw' | 'DM' | 'cachedOrDM' | undefined;

 export type CacheTypeReducer<
   State extends CacheType,
@@ -1708,12 +1713,18 @@ export type CacheTypeReducer<
   RawType = CachedType,
   PresentType = CachedType | RawType,
   Fallback = PresentType | null,
+  DMType = null,
+  CachedOrDMType = CachedType | DMType,
 > = [State] extends ['cached']
   ? CachedType
   : [State] extends ['raw']
   ? RawType
   : [State] extends ['raw' | 'cached']
   ? PresentType
+  : [State] extends ['DM']
+  ? DMType
+  : [State] extends ['cachedOrDM']
+  ? CachedOrDMType
   : Fallback;

 export type Interaction<Cached extends CacheType = CacheType> =
@@ -1740,7 +1751,8 @@ export class BaseInteraction<Cached extends CacheType = CacheType> extends Base
     GuildTextBasedChannel | null,
     GuildTextBasedChannel | null,
     GuildTextBasedChannel | null,
-    TextBasedChannel | null
+    TextBasedChannel | null,
+    DMChannel | null
   >;
   public channelId: Snowflake | null;
   public get createdAt(): Date;
@@ -1994,16 +2006,16 @@ export class Message<InGuild extends boolean = boolean> extends Base {
 }

 export class AttachmentBuilder {
-  public constructor(attachment: BufferResolvable | Stream, data?: AttachmentData);
+  public constructor(data?: Partial<AttachmentPayload>);
   public attachment: BufferResolvable | Stream;
   public description: string | null;
   public name: string | null;
   public get spoiler(): boolean;
   public setDescription(description: string): this;
-  public setFile(attachment: BufferResolvable | Stream, name?: string): this;
+  public setFile(attachment: BufferResolvable | Stream): this;
   public setName(name: string): this;
   public setSpoiler(spoiler?: boolean): this;
-  public toJSON(): unknown;
+  public toJSON(): AttachmentPayload;
   public static from(other: JSONEncodable<AttachmentPayload>): AttachmentBuilder;
 }

@@ -2045,6 +2057,7 @@ export class MessageComponentInteraction<Cached extends CacheType = CacheType> e
     MessageActionRowComponent,
     Exclude<APIMessageComponent, APIActionRowComponent<APIMessageActionRowComponent>>,
     MessageActionRowComponent | Exclude<APIMessageComponent, APIActionRowComponent<APIMessageActionRowComponent>>,
+    MessageActionRowComponent | Exclude<APIMessageComponent, APIActionRowComponent<APIMessageActionRowComponent>>,
     MessageActionRowComponent | Exclude<APIMessageComponent, APIActionRowComponent<APIMessageActionRowComponent>>
   >;
   public componentType: Exclude<ComponentType, ComponentType.ActionRow | ComponentType.TextInput>;
@@ -2213,12 +2226,17 @@ export interface TextInputModalData extends BaseModalData {
   value: string;
 }

+export interface SelectMenuModalData extends BaseModalData {
+  type: ComponentType.SelectMenu;
+  values: string[];
+}
+
 export interface ActionRowModalData {
   type: ComponentType.ActionRow;
   components: ModalData[];
 }

-export type ModalData = TextInputModalData | ActionRowModalData;
+export type ModalData = ActionRowModalData | TextInputModalData | SelectMenuModalData;

 export class ModalSubmitFields {
   constructor(components: ModalActionRowComponent[][]);
@@ -2227,6 +2245,7 @@ export class ModalSubmitFields {
   public getField<T extends ComponentType>(customId: string, type: T): { type: T } & ModalData;
   public getField(customId: string, type?: ComponentType): ModalData;
   public getTextInputValue(customId: string): string;
+  public getSelectMenuValues(customId: string): string[];
 }

 export interface ModalMessageModalSubmitInteraction<Cached extends CacheType = CacheType>
@@ -2503,6 +2522,7 @@ export class StringSelectMenuInteraction<
     StringSelectMenuComponent,
     APIStringSelectComponent,
     StringSelectMenuComponent | APIStringSelectComponent,
+    StringSelectMenuComponent | APIStringSelectComponent,
     StringSelectMenuComponent | APIStringSelectComponent
   >;
   public componentType: ComponentType.StringSelect;
@@ -2526,6 +2546,7 @@ export class UserSelectMenuInteraction<
     UserSelectMenuComponent,
     APIUserSelectComponent,
     UserSelectMenuComponent | APIUserSelectComponent,
+    UserSelectMenuComponent | APIUserSelectComponent,
     UserSelectMenuComponent | APIUserSelectComponent
   >;
   public componentType: ComponentType.UserSelect;
@@ -2549,6 +2570,7 @@ export class RoleSelectMenuInteraction<
     RoleSelectMenuComponent,
     APIRoleSelectComponent,
     RoleSelectMenuComponent | APIRoleSelectComponent,
+    RoleSelectMenuComponent | APIRoleSelectComponent,
     RoleSelectMenuComponent | APIRoleSelectComponent
   >;
   public componentType: ComponentType.RoleSelect;
@@ -2568,6 +2590,7 @@ export class MentionableSelectMenuInteraction<
     MentionableSelectMenuComponent,
     APIMentionableSelectComponent,
     MentionableSelectMenuComponent | APIMentionableSelectComponent,
+    MentionableSelectMenuComponent | APIMentionableSelectComponent,
     MentionableSelectMenuComponent | APIMentionableSelectComponent
   >;
   public componentType: ComponentType.MentionableSelect;
@@ -2592,6 +2615,7 @@ export class ChannelSelectMenuInteraction<
     ChannelSelectMenuComponent,
     APIChannelSelectComponent,
     ChannelSelectMenuComponent | APIChannelSelectComponent,
+    ChannelSelectMenuComponent | APIChannelSelectComponent,
     ChannelSelectMenuComponent | APIChannelSelectComponent
   >;
   public componentType: ComponentType.ChannelSelect;
@@ -3299,11 +3323,8 @@ export class WebhookClient extends WebhookMixin(BaseClient) {

 export class WebSocketManager extends EventEmitter {
   private constructor(client: Client);
-  private totalShards: number | string;
-  private shardQueue: Set<WebSocketShard>;
   private readonly packetQueue: unknown[];
   private destroyed: boolean;
-  private reconnecting: boolean;

   public readonly client: Client;
   public gateway: string | null;
@@ -3314,10 +3335,8 @@ export class WebSocketManager extends EventEmitter {
   public on(event: GatewayDispatchEvents, listener: (data: any, shardId: number) => void): this;
   public once(event: GatewayDispatchEvents, listener: (data: any, shardId: number) => void): this;

-  private debug(message: string, shard?: WebSocketShard): void;
+  private debug(message: string, shardId?: number): void;
   private connect(): Promise<void>;
-  private createShards(): Promise<void>;
-  private reconnect(): Promise<void>;
   private broadcast(packet: unknown): void;
   private destroy(): void;
   private handlePacket(packet?: unknown, shard?: WebSocketShard): boolean;
@@ -3336,26 +3355,11 @@ export interface WebSocketShardEventTypes {

 export class WebSocketShard extends EventEmitter {
   private constructor(manager: WebSocketManager, id: number);
-  private sequence: number;
   private closeSequence: number;
-  private sessionId: string | null;
-  private resumeURL: string | null;
+  private sessionInfo: SessionInfo | null;
   public lastPingTimestamp: number;
-  private lastHeartbeatAcked: boolean;
-  private readonly ratelimit: {
-    queue: unknown[];
-    total: number;
-    remaining: number;
-    time: 60e3;
-    timer: NodeJS.Timeout | null;
-  };
-  private connection: WebSocket | null;
-  private helloTimeout: NodeJS.Timeout | null;
-  private eventsAttached: boolean;
   private expectedGuilds: Set<Snowflake> | null;
   private readyTimeout: NodeJS.Timeout | null;
-  private closeEmitted: boolean;
-  private wsCloseTimeout: NodeJS.Timeout | null;

   public manager: WebSocketManager;
   public id: number;
@@ -3363,27 +3367,10 @@ export class WebSocketShard extends EventEmitter {
   public ping: number;

   private debug(message: string): void;
-  private connect(): Promise<void>;
-  private onOpen(): void;
-  private onMessage(event: MessageEvent): void;
-  private onError(error: ErrorEvent | unknown): void;
-  private onClose(event: CloseEvent): void;
-  private onPacket(packet: unknown): void;
+  private onReadyPacket(packet: unknown): void;
+  private gotGuild(guildId: Snowflake): void;
   private checkReady(): void;
-  private setHelloTimeout(time?: number): void;
-  private setWsCloseTimeout(time?: number): void;
-  private setHeartbeatTimer(time: number): void;
-  private sendHeartbeat(): void;
-  private ackHeartbeat(): void;
-  private identify(): void;
-  private identifyNew(): void;
-  private identifyResume(): void;
-  private _send(data: unknown): void;
-  private processQueue(): void;
-  private destroy(destroyOptions?: { closeCode?: number; reset?: boolean; emit?: boolean; log?: boolean }): void;
   private emitClose(event?: CloseEvent): void;
-  private _cleanupConnection(): void;
-  private _emitDestroyed(): void;

   public send(data: unknown, important?: boolean): void;

@@ -3506,16 +3493,23 @@ export enum DiscordjsErrorCodes {
   TokenMissing = 'TokenMissing',
   ApplicationCommandPermissionsTokenMissing = 'ApplicationCommandPermissionsTokenMissing',

+  /** @deprecated */
   WSCloseRequested = 'WSCloseRequested',
+  /** @deprecated */
   WSConnectionExists = 'WSConnectionExists',
+  /** @deprecated */
   WSNotOpen = 'WSNotOpen',
   ManagerDestroyed = 'ManagerDestroyed',

   BitFieldInvalid = 'BitFieldInvalid',

+  /** @deprecated */
   ShardingInvalid = 'ShardingInvalid',
+  /** @deprecated */
   ShardingRequired = 'ShardingRequired',
+  /** @deprecated */
   InvalidIntents = 'InvalidIntents',
+  /** @deprecated */
   DisallowedIntents = 'DisallowedIntents',
   ShardingNoShards = 'ShardingNoShards',
   ShardingInProcess = 'ShardingInProcess',
@@ -3754,7 +3748,7 @@ export class ApplicationCommandPermissionsManager<
     },
   ): Promise<boolean>;
   public fetch(options: FetchSingleOptions): Promise<ApplicationCommandPermissions[]>;
-  public fetch(options: BaseOptions): Promise<Collection<Snowflake, ApplicationCommandPermissions[]>>;
+  public fetch(options?: BaseOptions): Promise<Collection<Snowflake, ApplicationCommandPermissions[]>>;
   public remove(
     options:
       | (FetchSingleOptions & {
@@ -4284,11 +4278,6 @@ export interface BaseApplicationCommandData {
   nsfw?: boolean;
 }

-export interface AttachmentData {
-  name?: string;
-  description?: string;
-}
-
 export type CommandOptionDataTypeResolvable = ApplicationCommandOptionType;

 export type CommandOptionChannelResolvableType = ApplicationCommandOptionType.Channel;
@@ -4867,10 +4856,11 @@ export interface ClientUserEditOptions {
 }

 export interface CloseEvent {
+  /** @deprecated */
   wasClean: boolean;
   code: number;
+  /** @deprecated */
   reason: string;
-  target: WebSocket;
 }

 export type CollectorFilter<T extends unknown[]> = (...args: T) => boolean | Promise<boolean>;
@@ -5823,14 +5813,7 @@ export interface BaseMessageOptions {
   content?: string;
   embeds?: (JSONEncodable<APIEmbed> | APIEmbed)[];
   allowedMentions?: MessageMentionOptions;
-  files?: (
-    | BufferResolvable
-    | Stream
-    | JSONEncodable<APIAttachment>
-    | Attachment
-    | AttachmentBuilder
-    | AttachmentPayload
-  )[];
+  files?: (BufferResolvable | Stream | AttachmentPayload | JSONEncodable<AttachmentPayload>)[];
   components?: (
     | JSONEncodable<APIActionRowComponent<APIMessageActionRowComponent>>
     | ActionRowData<MessageActionRowComponentData | MessageActionRowComponentBuilder>
@@ -6324,9 +6307,9 @@ export interface WebhookMessageCreateOptions extends Omit<MessageCreateOptions,

 export interface WebSocketOptions {
   large_threshold?: number;
-  compress?: boolean;
   properties?: WebSocketProperties;
   version?: number;
+  buildStrategy?(manager: WSWebSocketManager): IShardingStrategy;
 }

 export interface WebSocketProperties {
@@ -6410,3 +6393,4 @@ export * from '@discordjs/builders';
 export * from '@discordjs/formatters';
 export * from '@discordjs/rest';
 export * from '@discordjs/util';
+export * from '@discordjs/ws';
