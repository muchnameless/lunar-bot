diff --git a/dist/defaultWorker.js b/dist/defaultWorker.js
index 885892691d4549b37cd3704cf03185d3e3a5184a..a6db93c217aeeaf81a41c1232f197dc8b07b0b15 100644
--- a/dist/defaultWorker.js
+++ b/dist/defaultWorker.js
@@ -287,7 +287,6 @@ var DefaultWebSocketManagerOptions = {
       store.delete(shardId);
     }
   },
-  handshakeTimeout: 3e4,
   helloTimeout: 6e4,
   readyTimeout: 15e3
 };
@@ -333,11 +332,12 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   initialHeartbeatTimeoutController = null;
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
-  session = null;
   // Indicates whether the shard has already resolved its original connect() call
   initialConnectResolved = false;
+  // Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)
+  failedToConnectDueToNetworkError = false;
   sendQueue = new import_async_queue2.AsyncQueue();
-  timeouts = new import_collection5.Collection();
+  timeoutAbortControllers = new import_collection5.Collection();
   strategy;
   id;
   #status = 0 /* Idle */;
@@ -350,6 +350,12 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     this.id = id;
   }
   async connect() {
+    const promise = this.initialConnectResolved ? Promise.resolve() : (0, import_node_events2.once)(this, "ready" /* Ready */);
+    void this.internalConnect();
+    await promise;
+    this.initialConnectResolved = true;
+  }
+  async internalConnect() {
     if (this.#status !== 0 /* Idle */) {
       throw new Error("Tried to connect a shard that wasn't idle");
     }
@@ -370,27 +376,23 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         );
       }
     }
-    const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
+    const session = await this.strategy.retrieveSessionInfo(this.id);
     const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
     this.debug([`Connecting to ${url}`]);
-    const connection = new import_ws.WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
+    const connection = new import_ws.WebSocket(url).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
     connection.binaryType = "arraybuffer";
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    const { ok } = await this.bubbleWaitForEventError(
-      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
-    );
+    const { ok } = await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
     if (!ok) {
       return;
     }
     if (session?.shardCount === this.strategy.options.shardCount) {
-      this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
-    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -415,8 +417,11 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       this.initialHeartbeatTimeoutController = null;
     }
     this.lastHeartbeatAt = -1;
-    if (options.recover !== 1 /* Resume */ && this.session) {
-      this.session = null;
+    for (const controller of this.timeoutAbortControllers.values()) {
+      controller.abort();
+    }
+    this.timeoutAbortControllers.clear();
+    if (options.recover !== 1 /* Resume */) {
       await this.strategy.updateSessionInfo(this.id, null);
     }
     if (this.connection) {
@@ -439,46 +444,36 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
     this.#status = 0 /* Idle */;
     if (options.recover !== void 0) {
-      return this.connect();
+      return this.internalConnect();
     }
   }
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
-    const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
-    if (timeout) {
-      this.timeouts.set(event, timeout);
-    }
-    await (0, import_node_events2.once)(this, event, { signal: controller.signal }).finally(() => {
-      if (timeout) {
-        (0, import_node_timers.clearTimeout)(timeout);
-        this.timeouts.delete(event);
-      }
-    });
-  }
-  /**
-   * Does special error handling for waitForEvent calls, depending on the current state of the connection lifecycle
-   * (i.e. whether or not the original connect() call has resolved or if the user has an error listener)
-   */
-  async bubbleWaitForEventError(promise) {
+    const timeoutController = new AbortController();
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration) : null;
+    this.timeoutAbortControllers.set(event, timeoutController);
+    const closeController = new AbortController();
     try {
-      await promise;
-      return { ok: true };
-    } catch (error) {
-      const isAbortError = error instanceof Error && error.name === "AbortError";
-      if (isAbortError) {
-        this.emit("error" /* Error */, { error });
-      }
-      error = error instanceof Error ? error : error.error;
-      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
-        throw error;
-      }
+      const closed = await Promise.race([
+        (0, import_node_events2.once)(this, event, { signal: timeoutController.signal }).then(() => false),
+        (0, import_node_events2.once)(this, "closed" /* Closed */, { signal: closeController.signal }).then(() => true)
+      ]);
+      return { ok: !closed };
+    } catch {
       void this.destroy({
         code: 1e3 /* Normal */,
         reason: "Something timed out or went wrong while waiting for an event",
         recover: 0 /* Reconnect */
       });
-      return { ok: false, error };
+      return { ok: false };
+    } finally {
+      if (timeout) {
+        (0, import_node_timers.clearTimeout)(timeout);
+      }
+      this.timeoutAbortControllers.delete(event);
+      if (!closeController.signal.aborted) {
+        closeController.abort();
+      }
     }
   }
   async send(payload) {
@@ -543,12 +538,15 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       op: import_v102.GatewayOpcodes.Identify,
       d
     });
-    await this.bubbleWaitForEventError(
-      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
-    );
+    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
   }
   async resume(session) {
-    this.debug(["Resuming session"]);
+    this.debug([
+      "Resuming session",
+      `resume url: ${session.resumeURL}`,
+      `sequence: ${session.sequence}`,
+      `shard id: ${this.id.toString()}`
+    ]);
     this.#status = 2 /* Resuming */;
     this.replayedEvents = 0;
     return this.send({
@@ -564,9 +562,10 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     if (!this.isAck && !requested) {
       return this.destroy({ reason: "Zombie connection", recover: 1 /* Resume */ });
     }
+    const session = await this.strategy.retrieveSessionInfo(this.id);
     await this.send({
       op: import_v102.GatewayOpcodes.Heartbeat,
-      d: this.session?.sequence ?? null
+      d: session?.sequence ?? null
     });
     this.lastHeartbeatAt = Date.now();
     this.isAck = false;
@@ -627,14 +626,14 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         switch (payload.t) {
           case import_v102.GatewayDispatchEvents.Ready: {
             this.#status = 3 /* Ready */;
-            this.session ??= {
+            const session2 = {
               sequence: payload.s,
               sessionId: payload.d.session_id,
               shardId: this.id,
               shardCount: this.strategy.options.shardCount,
               resumeURL: payload.d.resume_gateway_url
             };
-            await this.strategy.updateSessionInfo(this.id, this.session);
+            await this.strategy.updateSessionInfo(this.id, session2);
             this.emit("ready" /* Ready */, { data: payload.d });
             break;
           }
@@ -648,9 +647,15 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
             break;
           }
         }
-        if (this.session && payload.s > this.session.sequence) {
-          this.session.sequence = payload.s;
-          await this.strategy.updateSessionInfo(this.id, this.session);
+        const session = await this.strategy.retrieveSessionInfo(this.id);
+        if (session) {
+          if (payload.s > session.sequence) {
+            await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
+          }
+        } else {
+          this.debug([
+            `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
+          ]);
         }
         this.emit("dispatch" /* Dispatch */, { data: payload });
         break;
@@ -667,10 +672,8 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         break;
       }
       case import_v102.GatewayOpcodes.InvalidSession: {
-        const readyTimeout = this.timeouts.get("ready" /* Ready */);
-        readyTimeout?.refresh();
         this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
-        const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
+        const session = await this.strategy.retrieveSessionInfo(this.id);
         if (payload.d && session) {
           await this.resume(session);
         } else {
@@ -714,6 +717,11 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
   }
   onError(error) {
+    if ("code" in error && ["ECONNRESET", "ECONNREFUSED"].includes(error.code)) {
+      this.debug(["Failed to connect to the gateway URL specified"]);
+      this.failedToConnectDueToNetworkError = true;
+      return;
+    }
     this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
@@ -780,8 +788,13 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         throw new Error("Used disallowed intents");
       }
       default: {
-        this.debug([`The gateway closed with an unexpected code ${code}, attempting to resume.`]);
-        return this.destroy({ code, recover: 1 /* Resume */ });
+        this.debug([
+          `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
+        ]);
+        return this.destroy({
+          code,
+          recover: this.failedToConnectDueToNetworkError ? 0 /* Reconnect */ : 1 /* Resume */
+        });
       }
     }
   }
diff --git a/dist/defaultWorker.mjs b/dist/defaultWorker.mjs
index fa7541aa7c5e5a0d8d66b45b58e1f750fdf6e9c6..278163ef3e389e452a573d95487b56febc9aca50 100644
--- a/dist/defaultWorker.mjs
+++ b/dist/defaultWorker.mjs
@@ -121,7 +121,7 @@ __name(WorkerContextFetchingStrategy, "WorkerContextFetchingStrategy");
 // src/ws/WebSocketShard.ts
 import { Buffer as Buffer2 } from "node:buffer";
 import { once as once2 } from "node:events";
-import { setTimeout, clearInterval, clearTimeout, setInterval } from "node:timers";
+import { clearInterval, clearTimeout, setInterval, setTimeout } from "node:timers";
 import { setTimeout as sleep2 } from "node:timers/promises";
 import { URLSearchParams } from "node:url";
 import { TextDecoder } from "node:util";
@@ -269,7 +269,6 @@ var DefaultWebSocketManagerOptions = {
       store.delete(shardId);
     }
   },
-  handshakeTimeout: 3e4,
   helloTimeout: 6e4,
   readyTimeout: 15e3
 };
@@ -315,11 +314,12 @@ var WebSocketShard = class extends AsyncEventEmitter {
   initialHeartbeatTimeoutController = null;
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
-  session = null;
   // Indicates whether the shard has already resolved its original connect() call
   initialConnectResolved = false;
+  // Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)
+  failedToConnectDueToNetworkError = false;
   sendQueue = new AsyncQueue2();
-  timeouts = new Collection5();
+  timeoutAbortControllers = new Collection5();
   strategy;
   id;
   #status = 0 /* Idle */;
@@ -332,6 +332,12 @@ var WebSocketShard = class extends AsyncEventEmitter {
     this.id = id;
   }
   async connect() {
+    const promise = this.initialConnectResolved ? Promise.resolve() : once2(this, "ready" /* Ready */);
+    void this.internalConnect();
+    await promise;
+    this.initialConnectResolved = true;
+  }
+  async internalConnect() {
     if (this.#status !== 0 /* Idle */) {
       throw new Error("Tried to connect a shard that wasn't idle");
     }
@@ -352,27 +358,23 @@ var WebSocketShard = class extends AsyncEventEmitter {
         );
       }
     }
-    const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
+    const session = await this.strategy.retrieveSessionInfo(this.id);
     const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
     this.debug([`Connecting to ${url}`]);
-    const connection = new WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
+    const connection = new WebSocket(url).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
     connection.binaryType = "arraybuffer";
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    const { ok } = await this.bubbleWaitForEventError(
-      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
-    );
+    const { ok } = await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
     if (!ok) {
       return;
     }
     if (session?.shardCount === this.strategy.options.shardCount) {
-      this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
-    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -397,8 +399,11 @@ var WebSocketShard = class extends AsyncEventEmitter {
       this.initialHeartbeatTimeoutController = null;
     }
     this.lastHeartbeatAt = -1;
-    if (options.recover !== 1 /* Resume */ && this.session) {
-      this.session = null;
+    for (const controller of this.timeoutAbortControllers.values()) {
+      controller.abort();
+    }
+    this.timeoutAbortControllers.clear();
+    if (options.recover !== 1 /* Resume */) {
       await this.strategy.updateSessionInfo(this.id, null);
     }
     if (this.connection) {
@@ -421,46 +426,36 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
     this.#status = 0 /* Idle */;
     if (options.recover !== void 0) {
-      return this.connect();
+      return this.internalConnect();
     }
   }
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
-    const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
-    if (timeout) {
-      this.timeouts.set(event, timeout);
-    }
-    await once2(this, event, { signal: controller.signal }).finally(() => {
-      if (timeout) {
-        clearTimeout(timeout);
-        this.timeouts.delete(event);
-      }
-    });
-  }
-  /**
-   * Does special error handling for waitForEvent calls, depending on the current state of the connection lifecycle
-   * (i.e. whether or not the original connect() call has resolved or if the user has an error listener)
-   */
-  async bubbleWaitForEventError(promise) {
+    const timeoutController = new AbortController();
+    const timeout = timeoutDuration ? setTimeout(() => timeoutController.abort(), timeoutDuration) : null;
+    this.timeoutAbortControllers.set(event, timeoutController);
+    const closeController = new AbortController();
     try {
-      await promise;
-      return { ok: true };
-    } catch (error) {
-      const isAbortError = error instanceof Error && error.name === "AbortError";
-      if (isAbortError) {
-        this.emit("error" /* Error */, { error });
-      }
-      error = error instanceof Error ? error : error.error;
-      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
-        throw error;
-      }
+      const closed = await Promise.race([
+        once2(this, event, { signal: timeoutController.signal }).then(() => false),
+        once2(this, "closed" /* Closed */, { signal: closeController.signal }).then(() => true)
+      ]);
+      return { ok: !closed };
+    } catch {
       void this.destroy({
         code: 1e3 /* Normal */,
         reason: "Something timed out or went wrong while waiting for an event",
         recover: 0 /* Reconnect */
       });
-      return { ok: false, error };
+      return { ok: false };
+    } finally {
+      if (timeout) {
+        clearTimeout(timeout);
+      }
+      this.timeoutAbortControllers.delete(event);
+      if (!closeController.signal.aborted) {
+        closeController.abort();
+      }
     }
   }
   async send(payload) {
@@ -525,12 +520,15 @@ var WebSocketShard = class extends AsyncEventEmitter {
       op: GatewayOpcodes2.Identify,
       d
     });
-    await this.bubbleWaitForEventError(
-      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
-    );
+    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
   }
   async resume(session) {
-    this.debug(["Resuming session"]);
+    this.debug([
+      "Resuming session",
+      `resume url: ${session.resumeURL}`,
+      `sequence: ${session.sequence}`,
+      `shard id: ${this.id.toString()}`
+    ]);
     this.#status = 2 /* Resuming */;
     this.replayedEvents = 0;
     return this.send({
@@ -546,9 +544,10 @@ var WebSocketShard = class extends AsyncEventEmitter {
     if (!this.isAck && !requested) {
       return this.destroy({ reason: "Zombie connection", recover: 1 /* Resume */ });
     }
+    const session = await this.strategy.retrieveSessionInfo(this.id);
     await this.send({
       op: GatewayOpcodes2.Heartbeat,
-      d: this.session?.sequence ?? null
+      d: session?.sequence ?? null
     });
     this.lastHeartbeatAt = Date.now();
     this.isAck = false;
@@ -609,14 +608,14 @@ var WebSocketShard = class extends AsyncEventEmitter {
         switch (payload.t) {
           case GatewayDispatchEvents.Ready: {
             this.#status = 3 /* Ready */;
-            this.session ??= {
+            const session2 = {
               sequence: payload.s,
               sessionId: payload.d.session_id,
               shardId: this.id,
               shardCount: this.strategy.options.shardCount,
               resumeURL: payload.d.resume_gateway_url
             };
-            await this.strategy.updateSessionInfo(this.id, this.session);
+            await this.strategy.updateSessionInfo(this.id, session2);
             this.emit("ready" /* Ready */, { data: payload.d });
             break;
           }
@@ -630,9 +629,15 @@ var WebSocketShard = class extends AsyncEventEmitter {
             break;
           }
         }
-        if (this.session && payload.s > this.session.sequence) {
-          this.session.sequence = payload.s;
-          await this.strategy.updateSessionInfo(this.id, this.session);
+        const session = await this.strategy.retrieveSessionInfo(this.id);
+        if (session) {
+          if (payload.s > session.sequence) {
+            await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
+          }
+        } else {
+          this.debug([
+            `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
+          ]);
         }
         this.emit("dispatch" /* Dispatch */, { data: payload });
         break;
@@ -649,10 +654,8 @@ var WebSocketShard = class extends AsyncEventEmitter {
         break;
       }
       case GatewayOpcodes2.InvalidSession: {
-        const readyTimeout = this.timeouts.get("ready" /* Ready */);
-        readyTimeout?.refresh();
         this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
-        const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
+        const session = await this.strategy.retrieveSessionInfo(this.id);
         if (payload.d && session) {
           await this.resume(session);
         } else {
@@ -696,6 +699,11 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
   }
   onError(error) {
+    if ("code" in error && ["ECONNRESET", "ECONNREFUSED"].includes(error.code)) {
+      this.debug(["Failed to connect to the gateway URL specified"]);
+      this.failedToConnectDueToNetworkError = true;
+      return;
+    }
     this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
@@ -762,8 +770,13 @@ var WebSocketShard = class extends AsyncEventEmitter {
         throw new Error("Used disallowed intents");
       }
       default: {
-        this.debug([`The gateway closed with an unexpected code ${code}, attempting to resume.`]);
-        return this.destroy({ code, recover: 1 /* Resume */ });
+        this.debug([
+          `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
+        ]);
+        return this.destroy({
+          code,
+          recover: this.failedToConnectDueToNetworkError ? 0 /* Reconnect */ : 1 /* Resume */
+        });
       }
     }
   }
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 7329474005b987f0a4f78a8a5948fa9412a911f1..2f5205903c2e4aa65e59b86512d54e0eee7e6110 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -75,22 +75,18 @@ declare class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap>
     private initialHeartbeatTimeoutController;
     private heartbeatInterval;
     private lastHeartbeatAt;
-    private session;
     private initialConnectResolved;
+    private failedToConnectDueToNetworkError;
     private readonly sendQueue;
-    private readonly timeouts;
+    private readonly timeoutAbortControllers;
     private readonly strategy;
     readonly id: number;
     get status(): WebSocketShardStatus;
     constructor(strategy: IContextFetchingStrategy, id: number);
     connect(): Promise<void>;
+    private internalConnect;
     destroy(options?: WebSocketShardDestroyOptions): Promise<void>;
     private waitForEvent;
-    /**
-     * Does special error handling for waitForEvent calls, depending on the current state of the connection lifecycle
-     * (i.e. whether or not the original connect() call has resolved or if the user has an error listener)
-     */
-    private bubbleWaitForEventError;
     send(payload: GatewaySendPayload): Promise<void>;
     private identify;
     private resume;
@@ -189,7 +185,6 @@ declare const DefaultWebSocketManagerOptions: {
     readonly compression: null;
     readonly retrieveSessionInfo: (shardId: number) => SessionInfo | null;
     readonly updateSessionInfo: (shardId: number, info: SessionInfo | null) => void;
-    readonly handshakeTimeout: 30000;
     readonly helloTimeout: 60000;
     readonly readyTimeout: 15000;
 };
@@ -275,10 +270,6 @@ interface OptionalWebSocketManagerOptions {
      * @defaultValue `'json'`
      */
     encoding: Encoding;
-    /**
-     * How long to wait for a shard to connect before giving up
-     */
-    handshakeTimeout: number | null;
     /**
      * How long to wait for a shard's HELLO packet before giving up
      */
diff --git a/dist/index.js b/dist/index.js
index ddebbdf044aa9ddda71f062aff478c45ece4dec1..6aab2358ec44b1bc095d11adc819512786d49908 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -477,7 +477,6 @@ var DefaultWebSocketManagerOptions = {
       store.delete(shardId);
     }
   },
-  handshakeTimeout: 3e4,
   helloTimeout: 6e4,
   readyTimeout: 15e3
 };
@@ -535,11 +534,12 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   initialHeartbeatTimeoutController = null;
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
-  session = null;
   // Indicates whether the shard has already resolved its original connect() call
   initialConnectResolved = false;
+  // Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)
+  failedToConnectDueToNetworkError = false;
   sendQueue = new import_async_queue2.AsyncQueue();
-  timeouts = new import_collection4.Collection();
+  timeoutAbortControllers = new import_collection4.Collection();
   strategy;
   id;
   #status = 0 /* Idle */;
@@ -552,6 +552,12 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     this.id = id;
   }
   async connect() {
+    const promise = this.initialConnectResolved ? Promise.resolve() : (0, import_node_events2.once)(this, "ready" /* Ready */);
+    void this.internalConnect();
+    await promise;
+    this.initialConnectResolved = true;
+  }
+  async internalConnect() {
     if (this.#status !== 0 /* Idle */) {
       throw new Error("Tried to connect a shard that wasn't idle");
     }
@@ -572,27 +578,23 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         );
       }
     }
-    const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
+    const session = await this.strategy.retrieveSessionInfo(this.id);
     const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
     this.debug([`Connecting to ${url}`]);
-    const connection = new import_ws.WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
+    const connection = new import_ws.WebSocket(url).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
     connection.binaryType = "arraybuffer";
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    const { ok } = await this.bubbleWaitForEventError(
-      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
-    );
+    const { ok } = await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
     if (!ok) {
       return;
     }
     if (session?.shardCount === this.strategy.options.shardCount) {
-      this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
-    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -617,8 +619,11 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       this.initialHeartbeatTimeoutController = null;
     }
     this.lastHeartbeatAt = -1;
-    if (options.recover !== 1 /* Resume */ && this.session) {
-      this.session = null;
+    for (const controller of this.timeoutAbortControllers.values()) {
+      controller.abort();
+    }
+    this.timeoutAbortControllers.clear();
+    if (options.recover !== 1 /* Resume */) {
       await this.strategy.updateSessionInfo(this.id, null);
     }
     if (this.connection) {
@@ -641,46 +646,36 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
     this.#status = 0 /* Idle */;
     if (options.recover !== void 0) {
-      return this.connect();
+      return this.internalConnect();
     }
   }
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
-    const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
-    if (timeout) {
-      this.timeouts.set(event, timeout);
-    }
-    await (0, import_node_events2.once)(this, event, { signal: controller.signal }).finally(() => {
-      if (timeout) {
-        (0, import_node_timers.clearTimeout)(timeout);
-        this.timeouts.delete(event);
-      }
-    });
-  }
-  /**
-   * Does special error handling for waitForEvent calls, depending on the current state of the connection lifecycle
-   * (i.e. whether or not the original connect() call has resolved or if the user has an error listener)
-   */
-  async bubbleWaitForEventError(promise) {
+    const timeoutController = new AbortController();
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration) : null;
+    this.timeoutAbortControllers.set(event, timeoutController);
+    const closeController = new AbortController();
     try {
-      await promise;
-      return { ok: true };
-    } catch (error) {
-      const isAbortError = error instanceof Error && error.name === "AbortError";
-      if (isAbortError) {
-        this.emit("error" /* Error */, { error });
-      }
-      error = error instanceof Error ? error : error.error;
-      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
-        throw error;
-      }
+      const closed = await Promise.race([
+        (0, import_node_events2.once)(this, event, { signal: timeoutController.signal }).then(() => false),
+        (0, import_node_events2.once)(this, "closed" /* Closed */, { signal: closeController.signal }).then(() => true)
+      ]);
+      return { ok: !closed };
+    } catch {
       void this.destroy({
         code: 1e3 /* Normal */,
         reason: "Something timed out or went wrong while waiting for an event",
         recover: 0 /* Reconnect */
       });
-      return { ok: false, error };
+      return { ok: false };
+    } finally {
+      if (timeout) {
+        (0, import_node_timers.clearTimeout)(timeout);
+      }
+      this.timeoutAbortControllers.delete(event);
+      if (!closeController.signal.aborted) {
+        closeController.abort();
+      }
     }
   }
   async send(payload) {
@@ -745,12 +740,15 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       op: import_v102.GatewayOpcodes.Identify,
       d
     });
-    await this.bubbleWaitForEventError(
-      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
-    );
+    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
   }
   async resume(session) {
-    this.debug(["Resuming session"]);
+    this.debug([
+      "Resuming session",
+      `resume url: ${session.resumeURL}`,
+      `sequence: ${session.sequence}`,
+      `shard id: ${this.id.toString()}`
+    ]);
     this.#status = 2 /* Resuming */;
     this.replayedEvents = 0;
     return this.send({
@@ -766,9 +764,10 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     if (!this.isAck && !requested) {
       return this.destroy({ reason: "Zombie connection", recover: 1 /* Resume */ });
     }
+    const session = await this.strategy.retrieveSessionInfo(this.id);
     await this.send({
       op: import_v102.GatewayOpcodes.Heartbeat,
-      d: this.session?.sequence ?? null
+      d: session?.sequence ?? null
     });
     this.lastHeartbeatAt = Date.now();
     this.isAck = false;
@@ -829,14 +828,14 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         switch (payload.t) {
           case import_v102.GatewayDispatchEvents.Ready: {
             this.#status = 3 /* Ready */;
-            this.session ??= {
+            const session2 = {
               sequence: payload.s,
               sessionId: payload.d.session_id,
               shardId: this.id,
               shardCount: this.strategy.options.shardCount,
               resumeURL: payload.d.resume_gateway_url
             };
-            await this.strategy.updateSessionInfo(this.id, this.session);
+            await this.strategy.updateSessionInfo(this.id, session2);
             this.emit("ready" /* Ready */, { data: payload.d });
             break;
           }
@@ -850,9 +849,15 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
             break;
           }
         }
-        if (this.session && payload.s > this.session.sequence) {
-          this.session.sequence = payload.s;
-          await this.strategy.updateSessionInfo(this.id, this.session);
+        const session = await this.strategy.retrieveSessionInfo(this.id);
+        if (session) {
+          if (payload.s > session.sequence) {
+            await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
+          }
+        } else {
+          this.debug([
+            `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
+          ]);
         }
         this.emit("dispatch" /* Dispatch */, { data: payload });
         break;
@@ -869,10 +874,8 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         break;
       }
       case import_v102.GatewayOpcodes.InvalidSession: {
-        const readyTimeout = this.timeouts.get("ready" /* Ready */);
-        readyTimeout?.refresh();
         this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
-        const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
+        const session = await this.strategy.retrieveSessionInfo(this.id);
         if (payload.d && session) {
           await this.resume(session);
         } else {
@@ -916,6 +919,11 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
   }
   onError(error) {
+    if ("code" in error && ["ECONNRESET", "ECONNREFUSED"].includes(error.code)) {
+      this.debug(["Failed to connect to the gateway URL specified"]);
+      this.failedToConnectDueToNetworkError = true;
+      return;
+    }
     this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
@@ -982,8 +990,13 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         throw new Error("Used disallowed intents");
       }
       default: {
-        this.debug([`The gateway closed with an unexpected code ${code}, attempting to resume.`]);
-        return this.destroy({ code, recover: 1 /* Resume */ });
+        this.debug([
+          `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
+        ]);
+        return this.destroy({
+          code,
+          recover: this.failedToConnectDueToNetworkError ? 0 /* Reconnect */ : 1 /* Resume */
+        });
       }
     }
   }
diff --git a/dist/index.mjs b/dist/index.mjs
index 879b726a03ff7cd045cc60c3b6f0028542d5e2fb..1280c1b1fa19159a3907d0bc4cf17dfece22b5ee 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -383,7 +383,7 @@ import { Collection as Collection5 } from "@discordjs/collection";
 // src/ws/WebSocketShard.ts
 import { Buffer as Buffer2 } from "node:buffer";
 import { once as once2 } from "node:events";
-import { setTimeout, clearInterval, clearTimeout, setInterval } from "node:timers";
+import { clearInterval, clearTimeout, setInterval, setTimeout } from "node:timers";
 import { setTimeout as sleep2 } from "node:timers/promises";
 import { URLSearchParams } from "node:url";
 import { TextDecoder } from "node:util";
@@ -440,7 +440,6 @@ var DefaultWebSocketManagerOptions = {
       store.delete(shardId);
     }
   },
-  handshakeTimeout: 3e4,
   helloTimeout: 6e4,
   readyTimeout: 15e3
 };
@@ -498,11 +497,12 @@ var WebSocketShard = class extends AsyncEventEmitter {
   initialHeartbeatTimeoutController = null;
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
-  session = null;
   // Indicates whether the shard has already resolved its original connect() call
   initialConnectResolved = false;
+  // Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)
+  failedToConnectDueToNetworkError = false;
   sendQueue = new AsyncQueue2();
-  timeouts = new Collection4();
+  timeoutAbortControllers = new Collection4();
   strategy;
   id;
   #status = 0 /* Idle */;
@@ -515,6 +515,12 @@ var WebSocketShard = class extends AsyncEventEmitter {
     this.id = id;
   }
   async connect() {
+    const promise = this.initialConnectResolved ? Promise.resolve() : once2(this, "ready" /* Ready */);
+    void this.internalConnect();
+    await promise;
+    this.initialConnectResolved = true;
+  }
+  async internalConnect() {
     if (this.#status !== 0 /* Idle */) {
       throw new Error("Tried to connect a shard that wasn't idle");
     }
@@ -535,27 +541,23 @@ var WebSocketShard = class extends AsyncEventEmitter {
         );
       }
     }
-    const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
+    const session = await this.strategy.retrieveSessionInfo(this.id);
     const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
     this.debug([`Connecting to ${url}`]);
-    const connection = new WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
+    const connection = new WebSocket(url).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
     connection.binaryType = "arraybuffer";
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    const { ok } = await this.bubbleWaitForEventError(
-      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
-    );
+    const { ok } = await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
     if (!ok) {
       return;
     }
     if (session?.shardCount === this.strategy.options.shardCount) {
-      this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
-    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -580,8 +582,11 @@ var WebSocketShard = class extends AsyncEventEmitter {
       this.initialHeartbeatTimeoutController = null;
     }
     this.lastHeartbeatAt = -1;
-    if (options.recover !== 1 /* Resume */ && this.session) {
-      this.session = null;
+    for (const controller of this.timeoutAbortControllers.values()) {
+      controller.abort();
+    }
+    this.timeoutAbortControllers.clear();
+    if (options.recover !== 1 /* Resume */) {
       await this.strategy.updateSessionInfo(this.id, null);
     }
     if (this.connection) {
@@ -604,46 +609,36 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
     this.#status = 0 /* Idle */;
     if (options.recover !== void 0) {
-      return this.connect();
+      return this.internalConnect();
     }
   }
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
-    const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
-    if (timeout) {
-      this.timeouts.set(event, timeout);
-    }
-    await once2(this, event, { signal: controller.signal }).finally(() => {
-      if (timeout) {
-        clearTimeout(timeout);
-        this.timeouts.delete(event);
-      }
-    });
-  }
-  /**
-   * Does special error handling for waitForEvent calls, depending on the current state of the connection lifecycle
-   * (i.e. whether or not the original connect() call has resolved or if the user has an error listener)
-   */
-  async bubbleWaitForEventError(promise) {
+    const timeoutController = new AbortController();
+    const timeout = timeoutDuration ? setTimeout(() => timeoutController.abort(), timeoutDuration) : null;
+    this.timeoutAbortControllers.set(event, timeoutController);
+    const closeController = new AbortController();
     try {
-      await promise;
-      return { ok: true };
-    } catch (error) {
-      const isAbortError = error instanceof Error && error.name === "AbortError";
-      if (isAbortError) {
-        this.emit("error" /* Error */, { error });
-      }
-      error = error instanceof Error ? error : error.error;
-      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
-        throw error;
-      }
+      const closed = await Promise.race([
+        once2(this, event, { signal: timeoutController.signal }).then(() => false),
+        once2(this, "closed" /* Closed */, { signal: closeController.signal }).then(() => true)
+      ]);
+      return { ok: !closed };
+    } catch {
       void this.destroy({
         code: 1e3 /* Normal */,
         reason: "Something timed out or went wrong while waiting for an event",
         recover: 0 /* Reconnect */
       });
-      return { ok: false, error };
+      return { ok: false };
+    } finally {
+      if (timeout) {
+        clearTimeout(timeout);
+      }
+      this.timeoutAbortControllers.delete(event);
+      if (!closeController.signal.aborted) {
+        closeController.abort();
+      }
     }
   }
   async send(payload) {
@@ -708,12 +703,15 @@ var WebSocketShard = class extends AsyncEventEmitter {
       op: GatewayOpcodes2.Identify,
       d
     });
-    await this.bubbleWaitForEventError(
-      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
-    );
+    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
   }
   async resume(session) {
-    this.debug(["Resuming session"]);
+    this.debug([
+      "Resuming session",
+      `resume url: ${session.resumeURL}`,
+      `sequence: ${session.sequence}`,
+      `shard id: ${this.id.toString()}`
+    ]);
     this.#status = 2 /* Resuming */;
     this.replayedEvents = 0;
     return this.send({
@@ -729,9 +727,10 @@ var WebSocketShard = class extends AsyncEventEmitter {
     if (!this.isAck && !requested) {
       return this.destroy({ reason: "Zombie connection", recover: 1 /* Resume */ });
     }
+    const session = await this.strategy.retrieveSessionInfo(this.id);
     await this.send({
       op: GatewayOpcodes2.Heartbeat,
-      d: this.session?.sequence ?? null
+      d: session?.sequence ?? null
     });
     this.lastHeartbeatAt = Date.now();
     this.isAck = false;
@@ -792,14 +791,14 @@ var WebSocketShard = class extends AsyncEventEmitter {
         switch (payload.t) {
           case GatewayDispatchEvents.Ready: {
             this.#status = 3 /* Ready */;
-            this.session ??= {
+            const session2 = {
               sequence: payload.s,
               sessionId: payload.d.session_id,
               shardId: this.id,
               shardCount: this.strategy.options.shardCount,
               resumeURL: payload.d.resume_gateway_url
             };
-            await this.strategy.updateSessionInfo(this.id, this.session);
+            await this.strategy.updateSessionInfo(this.id, session2);
             this.emit("ready" /* Ready */, { data: payload.d });
             break;
           }
@@ -813,9 +812,15 @@ var WebSocketShard = class extends AsyncEventEmitter {
             break;
           }
         }
-        if (this.session && payload.s > this.session.sequence) {
-          this.session.sequence = payload.s;
-          await this.strategy.updateSessionInfo(this.id, this.session);
+        const session = await this.strategy.retrieveSessionInfo(this.id);
+        if (session) {
+          if (payload.s > session.sequence) {
+            await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
+          }
+        } else {
+          this.debug([
+            `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
+          ]);
         }
         this.emit("dispatch" /* Dispatch */, { data: payload });
         break;
@@ -832,10 +837,8 @@ var WebSocketShard = class extends AsyncEventEmitter {
         break;
       }
       case GatewayOpcodes2.InvalidSession: {
-        const readyTimeout = this.timeouts.get("ready" /* Ready */);
-        readyTimeout?.refresh();
         this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
-        const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
+        const session = await this.strategy.retrieveSessionInfo(this.id);
         if (payload.d && session) {
           await this.resume(session);
         } else {
@@ -879,6 +882,11 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
   }
   onError(error) {
+    if ("code" in error && ["ECONNRESET", "ECONNREFUSED"].includes(error.code)) {
+      this.debug(["Failed to connect to the gateway URL specified"]);
+      this.failedToConnectDueToNetworkError = true;
+      return;
+    }
     this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
@@ -945,8 +953,13 @@ var WebSocketShard = class extends AsyncEventEmitter {
         throw new Error("Used disallowed intents");
       }
       default: {
-        this.debug([`The gateway closed with an unexpected code ${code}, attempting to resume.`]);
-        return this.destroy({ code, recover: 1 /* Resume */ });
+        this.debug([
+          `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
+        ]);
+        return this.destroy({
+          code,
+          recover: this.failedToConnectDueToNetworkError ? 0 /* Reconnect */ : 1 /* Resume */
+        });
       }
     }
   }
