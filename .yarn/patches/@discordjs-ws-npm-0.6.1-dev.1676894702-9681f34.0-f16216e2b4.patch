diff --git a/dist/defaultWorker.js b/dist/defaultWorker.js
index 9b9142b22cba1b415a3280ce38798bec8639b20d..b4390d9569176d1eb2a838218be900d4ee5ee963 100644
--- a/dist/defaultWorker.js
+++ b/dist/defaultWorker.js
@@ -356,7 +356,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
     const { ok } = await this.bubbleWaitForEventError(
-      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
+      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
     );
     if (!ok) {
       return;
@@ -418,7 +418,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
@@ -654,6 +654,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       case import_v102.GatewayOpcodes.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
diff --git a/dist/defaultWorker.mjs b/dist/defaultWorker.mjs
index 4f639854606fd9cc185c2f04624fe95d2c23cde4..b0dd423289fa517e8791ede0967fee6e31d09b66 100644
--- a/dist/defaultWorker.mjs
+++ b/dist/defaultWorker.mjs
@@ -342,7 +342,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
     const { ok } = await this.bubbleWaitForEventError(
-      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
+      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
     );
     if (!ok) {
       return;
@@ -404,7 +404,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
@@ -640,6 +640,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
       case GatewayOpcodes2.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
diff --git a/dist/index.js b/dist/index.js
index 786fd067c3733b85136fabb4d11129f42ecf01ec..5842ec43b933cefd6f6088b02dd0af218a6e67f3 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -557,7 +557,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
     const { ok } = await this.bubbleWaitForEventError(
-      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
+      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
     );
     if (!ok) {
       return;
@@ -619,7 +619,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
@@ -855,6 +855,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       case import_v102.GatewayOpcodes.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
diff --git a/dist/index.mjs b/dist/index.mjs
index 81abbc645507e822545dda08ebaa593c21ad9130..1f237cdd0cbe31f6879208a8be1ed94c8232801f 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -524,7 +524,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
     const { ok } = await this.bubbleWaitForEventError(
-      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
+      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
     );
     if (!ok) {
       return;
@@ -586,7 +586,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
@@ -822,6 +822,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
       case GatewayOpcodes2.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
