diff --git a/dist/defaultWorker.js b/dist/defaultWorker.js
index 913aea654a06745b0bfb67fafe50a8cccb1f5db8..d19be2a5e6f2f9b809d3088949094752e2b11600 100644
--- a/dist/defaultWorker.js
+++ b/dist/defaultWorker.js
@@ -287,7 +287,6 @@ var DefaultWebSocketManagerOptions = {
       store.delete(shardId);
     }
   },
-  handshakeTimeout: 3e4,
   helloTimeout: 6e4,
   readyTimeout: 15e3
 };
@@ -380,7 +379,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     const session = await this.strategy.retrieveSessionInfo(this.id);
     const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
     this.debug([`Connecting to ${url}`]);
-    const connection = new import_ws.WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
+    const connection = new import_ws.WebSocket(url).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
     connection.binaryType = "arraybuffer";
     this.connection = connection;
     this.#status = 1 /* Connecting */;
@@ -452,7 +451,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const timeoutController = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration) : null;
     this.timeoutAbortControllers.set(event, timeoutController);
     const closeController = new AbortController();
     try {
diff --git a/dist/defaultWorker.mjs b/dist/defaultWorker.mjs
index f65b2c2a9153637dc2f62a63876ca4b22e679819..58745cb68a8ad83ccda85b4f27aa1c7728a3505c 100644
--- a/dist/defaultWorker.mjs
+++ b/dist/defaultWorker.mjs
@@ -269,7 +269,6 @@ var DefaultWebSocketManagerOptions = {
       store.delete(shardId);
     }
   },
-  handshakeTimeout: 3e4,
   helloTimeout: 6e4,
   readyTimeout: 15e3
 };
@@ -362,7 +361,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
     const session = await this.strategy.retrieveSessionInfo(this.id);
     const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
     this.debug([`Connecting to ${url}`]);
-    const connection = new WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
+    const connection = new WebSocket(url).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
     connection.binaryType = "arraybuffer";
     this.connection = connection;
     this.#status = 1 /* Connecting */;
@@ -434,7 +433,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const timeoutController = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => timeoutController.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => timeoutController.abort(), timeoutDuration) : null;
     this.timeoutAbortControllers.set(event, timeoutController);
     const closeController = new AbortController();
     try {
diff --git a/dist/index.d.ts b/dist/index.d.ts
index dfd19d0d9942c992d1f319fe1f8c8e9e27e4b731..2f5205903c2e4aa65e59b86512d54e0eee7e6110 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -185,7 +185,6 @@ declare const DefaultWebSocketManagerOptions: {
     readonly compression: null;
     readonly retrieveSessionInfo: (shardId: number) => SessionInfo | null;
     readonly updateSessionInfo: (shardId: number, info: SessionInfo | null) => void;
-    readonly handshakeTimeout: 30000;
     readonly helloTimeout: 60000;
     readonly readyTimeout: 15000;
 };
@@ -271,10 +270,6 @@ interface OptionalWebSocketManagerOptions {
      * @defaultValue `'json'`
      */
     encoding: Encoding;
-    /**
-     * How long to wait for a shard to connect before giving up
-     */
-    handshakeTimeout: number | null;
     /**
      * How long to wait for a shard's HELLO packet before giving up
      */
diff --git a/dist/index.js b/dist/index.js
index 0c5858e22f42ec629d96afa26440e1f3320e2bf6..7a6d4cb0aee0bf4bc2ff918ea630a1eea70fd02a 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -477,7 +477,6 @@ var DefaultWebSocketManagerOptions = {
       store.delete(shardId);
     }
   },
-  handshakeTimeout: 3e4,
   helloTimeout: 6e4,
   readyTimeout: 15e3
 };
@@ -582,7 +581,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     const session = await this.strategy.retrieveSessionInfo(this.id);
     const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
     this.debug([`Connecting to ${url}`]);
-    const connection = new import_ws.WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
+    const connection = new import_ws.WebSocket(url).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
     connection.binaryType = "arraybuffer";
     this.connection = connection;
     this.#status = 1 /* Connecting */;
@@ -654,7 +653,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const timeoutController = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration) : null;
     this.timeoutAbortControllers.set(event, timeoutController);
     const closeController = new AbortController();
     try {
diff --git a/dist/index.mjs b/dist/index.mjs
index 26a88085fef7833d5e1ec78e20d160314abcb434..3fe98789e13aaee28fb5684b911d1400fa19af92 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -440,7 +440,6 @@ var DefaultWebSocketManagerOptions = {
       store.delete(shardId);
     }
   },
-  handshakeTimeout: 3e4,
   helloTimeout: 6e4,
   readyTimeout: 15e3
 };
@@ -545,7 +544,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
     const session = await this.strategy.retrieveSessionInfo(this.id);
     const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
     this.debug([`Connecting to ${url}`]);
-    const connection = new WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
+    const connection = new WebSocket(url).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
     connection.binaryType = "arraybuffer";
     this.connection = connection;
     this.#status = 1 /* Connecting */;
@@ -617,7 +616,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   async waitForEvent(event, timeoutDuration) {
     this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const timeoutController = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => timeoutController.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => timeoutController.abort(), timeoutDuration) : null;
     this.timeoutAbortControllers.set(event, timeoutController);
     const closeController = new AbortController();
     try {
