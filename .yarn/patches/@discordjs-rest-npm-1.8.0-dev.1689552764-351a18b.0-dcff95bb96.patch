diff --git a/dist/CDN-03f06673.d.ts b/dist/CDN-03f06673.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..247849789d8769f09047dadbb0f45f98dad6306e
--- /dev/null
+++ b/dist/CDN-03f06673.d.ts
@@ -0,0 +1,779 @@
+import * as undici from 'undici';
+import { RequestInit, BodyInit, Agent, Dispatcher, Response } from 'undici';
+import { Readable } from 'node:stream';
+import { ReadableStream } from 'node:stream/web';
+import { Collection } from '@discordjs/collection';
+import { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';
+
+interface IHandler {
+    /**
+     * The unique id of the handler
+     */
+    readonly id: string;
+    /**
+     * If the bucket is currently inactive (no pending requests)
+     */
+    get inactive(): boolean;
+    /**
+     * Queues a request to be sent
+     *
+     * @param routeId - The generalized api route with literal ids for major parameters
+     * @param url - The url to do the request on
+     * @param options - All the information needed to make a request
+     * @param requestData - Extra data from the user's request needed for errors and additional processing
+     */
+    queueRequest(routeId: RouteData, url: string, options: RequestInit, requestData: HandlerRequestData): Promise<ResponseLike>;
+}
+
+/**
+ * Represents a file to be added to the request
+ */
+interface RawFile {
+    /**
+     * Content-Type of the file
+     */
+    contentType?: string;
+    /**
+     * The actual data for the file
+     */
+    data: Buffer | Uint8Array | boolean | number | string;
+    /**
+     * An explicit key to use for key of the formdata field for this file.
+     * When not provided, the index of the file in the files array is used in the form `files[${index}]`.
+     * If you wish to alter the placeholder snowflake, you must provide this property in the same form (`files[${placeholder}]`)
+     */
+    key?: string;
+    /**
+     * The name of the file
+     */
+    name: string;
+}
+/**
+ * Represents possible data to be given to an endpoint
+ */
+interface RequestData {
+    /**
+     * Whether to append JSON data to form data instead of `payload_json` when sending files
+     */
+    appendToFormData?: boolean;
+    /**
+     * If this request needs the `Authorization` header
+     *
+     * @defaultValue `true`
+     */
+    auth?: boolean;
+    /**
+     * The authorization prefix to use for this request, useful if you use this with bearer tokens
+     *
+     * @defaultValue `'Bot'`
+     */
+    authPrefix?: 'Bearer' | 'Bot';
+    /**
+     * The body to send to this request.
+     * If providing as BodyInit, set `passThroughBody: true`
+     */
+    body?: BodyInit | unknown;
+    /**
+     * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} to use for the request.
+     */
+    dispatcher?: Agent;
+    /**
+     * Files to be attached to this request
+     */
+    files?: RawFile[] | undefined;
+    /**
+     * Additional headers to add to this request
+     */
+    headers?: Record<string, string>;
+    /**
+     * Whether to pass-through the body property directly to `fetch()`.
+     * <warn>This only applies when files is NOT present</warn>
+     */
+    passThroughBody?: boolean;
+    /**
+     * Query string parameters to append to the called endpoint
+     */
+    query?: URLSearchParams;
+    /**
+     * Reason to show in the audit logs
+     */
+    reason?: string | undefined;
+    /**
+     * The signal to abort the queue entry or the REST call, where applicable
+     */
+    signal?: AbortSignal | undefined;
+    /**
+     * If this request should be versioned
+     *
+     * @defaultValue `true`
+     */
+    versioned?: boolean;
+}
+/**
+ * Possible headers for an API call
+ */
+interface RequestHeaders {
+    Authorization?: string;
+    'User-Agent': string;
+    'X-Audit-Log-Reason'?: string;
+}
+/**
+ * Possible API methods to be used when doing requests
+ */
+declare enum RequestMethod {
+    Delete = "DELETE",
+    Get = "GET",
+    Patch = "PATCH",
+    Post = "POST",
+    Put = "PUT"
+}
+type RouteLike = `/${string}`;
+/**
+ * Internal request options
+ *
+ * @internal
+ */
+interface InternalRequest extends RequestData {
+    fullRoute: RouteLike;
+    method: RequestMethod;
+}
+type HandlerRequestData = Pick<InternalRequest, 'auth' | 'body' | 'files' | 'signal'>;
+/**
+ * Parsed route data for an endpoint
+ *
+ * @internal
+ */
+interface RouteData {
+    bucketRoute: string;
+    majorParameter: string;
+    original: RouteLike;
+}
+/**
+ * Represents a hash and its associated fields
+ *
+ * @internal
+ */
+interface HashData {
+    lastAccess: number;
+    value: string;
+}
+/**
+ * Represents the class that manages handlers for endpoints
+ */
+declare class RequestManager extends AsyncEventEmitter<RestEventsMap> {
+    #private;
+    /**
+     * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
+     * performed by this manager.
+     */
+    agent: Dispatcher | null;
+    /**
+     * The number of requests remaining in the global bucket
+     */
+    globalRemaining: number;
+    /**
+     * The promise used to wait out the global rate limit
+     */
+    globalDelay: Promise<void> | null;
+    /**
+     * The timestamp at which the global bucket resets
+     */
+    globalReset: number;
+    /**
+     * API bucket hashes that are cached from provided routes
+     */
+    readonly hashes: Collection<string, HashData>;
+    /**
+     * Request handlers created from the bucket hash and the major parameters
+     */
+    readonly handlers: Collection<string, IHandler>;
+    private hashTimer;
+    private handlerTimer;
+    readonly options: RESTOptions;
+    constructor(options: Partial<RESTOptions>);
+    private setupSweepers;
+    /**
+     * Sets the default agent to use for requests performed by this manager
+     *
+     * @param agent - The agent to use
+     */
+    setAgent(agent: Dispatcher): this;
+    /**
+     * Sets the authorization token that should be used for requests
+     *
+     * @param token - The authorization token to use
+     */
+    setToken(token: string): this;
+    /**
+     * Queues a request to be sent
+     *
+     * @param request - All the information needed to make a request
+     * @returns The response from the api request
+     */
+    queueRequest(request: InternalRequest): Promise<ResponseLike>;
+    /**
+     * Creates a new rate limit handler from a hash, based on the hash and the major parameter
+     *
+     * @param hash - The hash for the route
+     * @param majorParameter - The major parameter for this handler
+     * @internal
+     */
+    private createHandler;
+    /**
+     * Formats the request data to a usable format for fetch
+     *
+     * @param request - The request data
+     */
+    private resolveRequest;
+    /**
+     * Stops the hash sweeping interval
+     */
+    clearHashSweeper(): void;
+    /**
+     * Stops the request handler sweeping interval
+     */
+    clearHandlerSweeper(): void;
+    /**
+     * Generates route data for an endpoint:method
+     *
+     * @param endpoint - The raw endpoint to generalize
+     * @param method - The HTTP method this endpoint is called without
+     * @internal
+     */
+    private static generateRouteData;
+}
+
+/**
+ * Options to be passed when creating the REST instance
+ */
+interface RESTOptions {
+    /**
+     * The agent to set globally
+     */
+    agent: Dispatcher | null;
+    /**
+     * The base api path, without version
+     *
+     * @defaultValue `'https://discord.com/api'`
+     */
+    api: string;
+    /**
+     * The authorization prefix to use for requests, useful if you want to use
+     * bearer tokens
+     *
+     * @defaultValue `'Bot'`
+     */
+    authPrefix: 'Bearer' | 'Bot';
+    /**
+     * The cdn path
+     *
+     * @defaultValue `'https://cdn.discordapp.com'`
+     */
+    cdn: string;
+    /**
+     * How many requests to allow sending per second (Infinity for unlimited, 50 for the standard global limit used by Discord)
+     *
+     * @defaultValue `50`
+     */
+    globalRequestsPerSecond: number;
+    /**
+     * The amount of time in milliseconds that passes between each hash sweep. (defaults to 1h)
+     *
+     * @defaultValue `3_600_000`
+     */
+    handlerSweepInterval: number;
+    /**
+     * The maximum amount of time a hash can exist in milliseconds without being hit with a request (defaults to 24h)
+     *
+     * @defaultValue `86_400_000`
+     */
+    hashLifetime: number;
+    /**
+     * The amount of time in milliseconds that passes between each hash sweep. (defaults to 4h)
+     *
+     * @defaultValue `14_400_000`
+     */
+    hashSweepInterval: number;
+    /**
+     * Additional headers to send for all API requests
+     *
+     * @defaultValue `{}`
+     */
+    headers: Record<string, string>;
+    /**
+     * The number of invalid REST requests (those that return 401, 403, or 429) in a 10 minute window between emitted warnings (0 for no warnings).
+     * That is, if set to 500, warnings will be emitted at invalid request number 500, 1000, 1500, and so on.
+     *
+     * @defaultValue `0`
+     */
+    invalidRequestWarningInterval: number;
+    /**
+     * The method called to perform the actual HTTP request given a url and web `fetch` options
+     * For example, to use global fetch, simply provide `makeRequest: fetch`
+     *
+     * @defaultValue `undici.request`
+     */
+    makeRequest(url: string, init: RequestInit): Promise<ResponseLike>;
+    /**
+     * The extra offset to add to rate limits in milliseconds
+     *
+     * @defaultValue `50`
+     */
+    offset: number;
+    /**
+     * Determines how rate limiting and pre-emptive throttling should be handled.
+     * When an array of strings, each element is treated as a prefix for the request route
+     * (e.g. `/channels` to match any route starting with `/channels` such as `/channels/:id/messages`)
+     * for which to throw {@link RateLimitError}s. All other request routes will be queued normally
+     *
+     * @defaultValue `null`
+     */
+    rejectOnRateLimit: RateLimitQueueFilter | string[] | null;
+    /**
+     * The number of retries for errors with the 500 code, or errors
+     * that timeout
+     *
+     * @defaultValue `3`
+     */
+    retries: number;
+    /**
+     * The time to wait in milliseconds before a request is aborted
+     *
+     * @defaultValue `15_000`
+     */
+    timeout: number;
+    /**
+     * Extra information to add to the user agent
+     *
+     * @defaultValue DefaultUserAgentAppendix
+     */
+    userAgentAppendix: string;
+    /**
+     * The version of the API to use
+     *
+     * @defaultValue `'10'`
+     */
+    version: string;
+}
+/**
+ * Data emitted on `RESTEvents.RateLimited`
+ */
+interface RateLimitData {
+    /**
+     * Whether the rate limit that was reached was the global limit
+     */
+    global: boolean;
+    /**
+     * The bucket hash for this request
+     */
+    hash: string;
+    /**
+     * The amount of requests we can perform before locking requests
+     */
+    limit: number;
+    /**
+     * The major parameter of the route
+     *
+     * For example, in `/channels/x`, this will be `x`.
+     * If there is no major parameter (e.g: `/bot/gateway`) this will be `global`.
+     */
+    majorParameter: string;
+    /**
+     * The HTTP method being performed
+     */
+    method: string;
+    /**
+     * The route being hit in this request
+     */
+    route: string;
+    /**
+     * The time, in milliseconds, until the request-lock is reset
+     */
+    timeToReset: number;
+    /**
+     * The full URL for this request
+     */
+    url: string;
+}
+/**
+ * A function that determines whether the rate limit hit should throw an Error
+ */
+type RateLimitQueueFilter = (rateLimitData: RateLimitData) => Promise<boolean> | boolean;
+interface APIRequest {
+    /**
+     * The data that was used to form the body of this request
+     */
+    data: HandlerRequestData;
+    /**
+     * The HTTP method used in this request
+     */
+    method: string;
+    /**
+     * Additional HTTP options for this request
+     */
+    options: RequestInit;
+    /**
+     * The full path used to make the request
+     */
+    path: RouteLike;
+    /**
+     * The number of times this request has been attempted
+     */
+    retries: number;
+    /**
+     * The API route identifying the ratelimit for this request
+     */
+    route: string;
+}
+interface ResponseLike extends Pick<Response, 'arrayBuffer' | 'bodyUsed' | 'headers' | 'json' | 'ok' | 'status' | 'statusText' | 'text'> {
+    body: Readable | ReadableStream | null;
+}
+interface InvalidRequestWarningData {
+    /**
+     * Number of invalid requests that have been made in the window
+     */
+    count: number;
+    /**
+     * Time in milliseconds remaining before the count resets
+     */
+    remainingTime: number;
+}
+interface RestEvents {
+    handlerSweep: [sweptHandlers: Collection<string, IHandler>];
+    hashSweep: [sweptHashes: Collection<string, HashData>];
+    invalidRequestWarning: [invalidRequestInfo: InvalidRequestWarningData];
+    rateLimited: [rateLimitInfo: RateLimitData];
+    response: [request: APIRequest, response: ResponseLike];
+    restDebug: [info: string];
+}
+type RestEventsMap = {
+    [K in keyof RestEvents]: RestEvents[K];
+};
+declare class REST extends AsyncEventEmitter<RestEventsMap> {
+    readonly cdn: CDN;
+    readonly requestManager: RequestManager;
+    constructor(options?: Partial<RESTOptions>);
+    /**
+     * Gets the agent set for this instance
+     */
+    getAgent(): Dispatcher | null;
+    /**
+     * Sets the default agent to use for requests performed by this instance
+     *
+     * @param agent - Sets the agent to use
+     */
+    setAgent(agent: Dispatcher): this;
+    /**
+     * Sets the authorization token that should be used for requests
+     *
+     * @param token - The authorization token to use
+     */
+    setToken(token: string): this;
+    /**
+     * Runs a get request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    get(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a delete request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    delete(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a post request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    post(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a put request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    put(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a patch request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    patch(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a request from the api
+     *
+     * @param options - Request options
+     */
+    request(options: InternalRequest): Promise<unknown>;
+    /**
+     * Runs a request from the API, yielding the raw Response object
+     *
+     * @param options - Request options
+     */
+    raw(options: InternalRequest): Promise<ResponseLike>;
+}
+
+declare const DefaultUserAgent: `DiscordBot (https://discord.js.org, ${string})`;
+/**
+ * The default string to append onto the user agent.
+ */
+declare const DefaultUserAgentAppendix: string;
+declare const DefaultRestOptions: {
+    readonly agent: null;
+    readonly api: "https://discord.com/api";
+    readonly authPrefix: "Bot";
+    readonly cdn: "https://cdn.discordapp.com";
+    readonly headers: {};
+    readonly invalidRequestWarningInterval: 0;
+    readonly globalRequestsPerSecond: 50;
+    readonly offset: 50;
+    readonly rejectOnRateLimit: null;
+    readonly retries: 3;
+    readonly timeout: 15000;
+    readonly userAgentAppendix: string;
+    readonly version: "10";
+    readonly hashSweepInterval: 14400000;
+    readonly hashLifetime: 86400000;
+    readonly handlerSweepInterval: 3600000;
+    readonly makeRequest: (url: string, init: undici.RequestInit) => Promise<ResponseLike>;
+};
+/**
+ * The events that the REST manager emits
+ */
+declare enum RESTEvents {
+    Debug = "restDebug",
+    HandlerSweep = "handlerSweep",
+    HashSweep = "hashSweep",
+    InvalidRequestWarning = "invalidRequestWarning",
+    RateLimited = "rateLimited",
+    Response = "response"
+}
+declare const ALLOWED_EXTENSIONS: readonly ["webp", "png", "jpg", "jpeg", "gif"];
+declare const ALLOWED_STICKER_EXTENSIONS: readonly ["png", "json", "gif"];
+declare const ALLOWED_SIZES: readonly [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
+type ImageExtension = (typeof ALLOWED_EXTENSIONS)[number];
+type StickerExtension = (typeof ALLOWED_STICKER_EXTENSIONS)[number];
+type ImageSize = (typeof ALLOWED_SIZES)[number];
+declare const OverwrittenMimeTypes: {
+    readonly 'image/apng': "image/png";
+};
+declare const BurstHandlerMajorIdKey = "burst";
+
+/**
+ * The options used for image URLs
+ */
+interface BaseImageURLOptions {
+    /**
+     * The extension to use for the image URL
+     *
+     * @defaultValue `'webp'`
+     */
+    extension?: ImageExtension;
+    /**
+     * The size specified in the image URL
+     */
+    size?: ImageSize;
+}
+/**
+ * The options used for image URLs with animated content
+ */
+interface ImageURLOptions extends BaseImageURLOptions {
+    /**
+     * Whether or not to prefer the static version of an image asset.
+     */
+    forceStatic?: boolean;
+}
+/**
+ * The options to use when making a CDN URL
+ */
+interface MakeURLOptions {
+    /**
+     * The allowed extensions that can be used
+     */
+    allowedExtensions?: readonly string[];
+    /**
+     * The extension to use for the image URL
+     *
+     * @defaultValue `'webp'`
+     */
+    extension?: string | undefined;
+    /**
+     * The size specified in the image URL
+     */
+    size?: ImageSize;
+}
+/**
+ * The CDN link builder
+ */
+declare class CDN {
+    private readonly base;
+    constructor(base?: string);
+    /**
+     * Generates an app asset URL for a client's asset.
+     *
+     * @param clientId - The client id that has the asset
+     * @param assetHash - The hash provided by Discord for this asset
+     * @param options - Optional options for the asset
+     */
+    appAsset(clientId: string, assetHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates an app icon URL for a client's icon.
+     *
+     * @param clientId - The client id that has the icon
+     * @param iconHash - The hash provided by Discord for this icon
+     * @param options - Optional options for the icon
+     */
+    appIcon(clientId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates an avatar URL, e.g. for a user or a webhook.
+     *
+     * @param id - The id that has the icon
+     * @param avatarHash - The hash provided by Discord for this avatar
+     * @param options - Optional options for the avatar
+     */
+    avatar(id: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates a user avatar decoration URL.
+     *
+     * @param userId - The id of the user
+     * @param userAvatarDecoration - The hash provided by Discord for this avatar decoration
+     * @param options - Optional options for the avatar decoration
+     */
+    avatarDecoration(userId: string, userAvatarDecoration: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a banner URL, e.g. for a user or a guild.
+     *
+     * @param id - The id that has the banner splash
+     * @param bannerHash - The hash provided by Discord for this banner
+     * @param options - Optional options for the banner
+     */
+    banner(id: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates an icon URL for a channel, e.g. a group DM.
+     *
+     * @param channelId - The channel id that has the icon
+     * @param iconHash - The hash provided by Discord for this channel
+     * @param options - Optional options for the icon
+     */
+    channelIcon(channelId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a default avatar URL
+     *
+     * @param index - The default avatar index
+     * @remarks
+     * To calculate the index for a user do `(userId >> 22) % 6`,
+     * or `discriminator % 5` if they're using the legacy username system.
+     */
+    defaultAvatar(index: number): string;
+    /**
+     * Generates a discovery splash URL for a guild's discovery splash.
+     *
+     * @param guildId - The guild id that has the discovery splash
+     * @param splashHash - The hash provided by Discord for this splash
+     * @param options - Optional options for the splash
+     */
+    discoverySplash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates an emoji's URL for an emoji.
+     *
+     * @param emojiId - The emoji id
+     * @param extension - The extension of the emoji
+     */
+    emoji(emojiId: string, extension?: ImageExtension): string;
+    /**
+     * Generates a guild member avatar URL.
+     *
+     * @param guildId - The id of the guild
+     * @param userId - The id of the user
+     * @param avatarHash - The hash provided by Discord for this avatar
+     * @param options - Optional options for the avatar
+     */
+    guildMemberAvatar(guildId: string, userId: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates a guild member banner URL.
+     *
+     * @param guildId - The id of the guild
+     * @param userId - The id of the user
+     * @param bannerHash - The hash provided by Discord for this banner
+     * @param options - Optional options for the banner
+     */
+    guildMemberBanner(guildId: string, userId: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates an icon URL, e.g. for a guild.
+     *
+     * @param id - The id that has the icon splash
+     * @param iconHash - The hash provided by Discord for this icon
+     * @param options - Optional options for the icon
+     */
+    icon(id: string, iconHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates a URL for the icon of a role
+     *
+     * @param roleId - The id of the role that has the icon
+     * @param roleIconHash - The hash provided by Discord for this role icon
+     * @param options - Optional options for the role icon
+     */
+    roleIcon(roleId: string, roleIconHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a guild invite splash URL for a guild's invite splash.
+     *
+     * @param guildId - The guild id that has the invite splash
+     * @param splashHash - The hash provided by Discord for this splash
+     * @param options - Optional options for the splash
+     */
+    splash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a sticker URL.
+     *
+     * @param stickerId - The sticker id
+     * @param extension - The extension of the sticker
+     * @privateRemarks
+     * Stickers cannot have a `.webp` extension, so we default to a `.png`
+     */
+    sticker(stickerId: string, extension?: StickerExtension): string;
+    /**
+     * Generates a sticker pack banner URL.
+     *
+     * @param bannerId - The banner id
+     * @param options - Optional options for the banner
+     */
+    stickerPackBanner(bannerId: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a team icon URL for a team's icon.
+     *
+     * @param teamId - The team id that has the icon
+     * @param iconHash - The hash provided by Discord for this icon
+     * @param options - Optional options for the icon
+     */
+    teamIcon(teamId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a cover image for a guild scheduled event.
+     *
+     * @param scheduledEventId - The scheduled event id
+     * @param coverHash - The hash provided by discord for this cover image
+     * @param options - Optional options for the cover image
+     */
+    guildScheduledEventCover(scheduledEventId: string, coverHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.
+     *
+     * @param route - The base cdn route
+     * @param hash - The hash provided by Discord for this icon
+     * @param options - Optional options for the link
+     */
+    private dynamicMakeURL;
+    /**
+     * Constructs the URL for the resource
+     *
+     * @param route - The base cdn route
+     * @param options - The extension/size options for the link
+     */
+    private makeURL;
+}
+
+export { APIRequest as A, BaseImageURLOptions as B, CDN as C, DefaultUserAgent as D, HandlerRequestData as H, InternalRequest as I, MakeURLOptions as M, OverwrittenMimeTypes as O, ResponseLike as R, StickerExtension as S, RawFile as a, RateLimitData as b, ImageURLOptions as c, RequestData as d, RequestHeaders as e, RequestMethod as f, RouteLike as g, RouteData as h, HashData as i, RequestManager as j, RESTOptions as k, RateLimitQueueFilter as l, InvalidRequestWarningData as m, RestEvents as n, RestEventsMap as o, REST as p, DefaultUserAgentAppendix as q, DefaultRestOptions as r, RESTEvents as s, ALLOWED_EXTENSIONS as t, ALLOWED_STICKER_EXTENSIONS as u, ALLOWED_SIZES as v, ImageExtension as w, ImageSize as x, BurstHandlerMajorIdKey as y };
diff --git a/dist/index.d.mts b/dist/index.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..ba3a73fe92f87b1712d2b187009808001f409354
--- /dev/null
+++ b/dist/index.d.mts
@@ -0,0 +1,123 @@
+import { a as RawFile, I as InternalRequest, b as RateLimitData, R as ResponseLike } from './CDN-03f06673.js';
+export { t as ALLOWED_EXTENSIONS, v as ALLOWED_SIZES, u as ALLOWED_STICKER_EXTENSIONS, A as APIRequest, B as BaseImageURLOptions, y as BurstHandlerMajorIdKey, C as CDN, r as DefaultRestOptions, D as DefaultUserAgent, q as DefaultUserAgentAppendix, H as HandlerRequestData, i as HashData, w as ImageExtension, x as ImageSize, c as ImageURLOptions, m as InvalidRequestWarningData, M as MakeURLOptions, O as OverwrittenMimeTypes, p as REST, s as RESTEvents, k as RESTOptions, l as RateLimitQueueFilter, d as RequestData, e as RequestHeaders, j as RequestManager, f as RequestMethod, n as RestEvents, o as RestEventsMap, h as RouteData, g as RouteLike, S as StickerExtension } from './CDN-03f06673.js';
+import * as url from 'url';
+import { Snowflake } from 'discord-api-types/v10';
+import 'undici';
+import 'node:stream';
+import 'node:stream/web';
+import '@discordjs/collection';
+import '@vladfrangu/async_event_emitter';
+
+interface DiscordErrorFieldInformation {
+    code: string;
+    message: string;
+}
+interface DiscordErrorGroupWrapper {
+    _errors: DiscordError[];
+}
+type DiscordError = DiscordErrorFieldInformation | DiscordErrorGroupWrapper | string | {
+    [k: string]: DiscordError;
+};
+interface DiscordErrorData {
+    code: number;
+    errors?: DiscordError;
+    message: string;
+}
+interface OAuthErrorData {
+    error: string;
+    error_description?: string;
+}
+interface RequestBody {
+    files: RawFile[] | undefined;
+    json: unknown | undefined;
+}
+/**
+ * Represents an API error returned by Discord
+ */
+declare class DiscordAPIError extends Error {
+    rawError: DiscordErrorData | OAuthErrorData;
+    code: number | string;
+    status: number;
+    method: string;
+    url: string;
+    requestBody: RequestBody;
+    /**
+     * @param rawError - The error reported by Discord
+     * @param code - The error code reported by Discord
+     * @param status - The status code of the response
+     * @param method - The method of the request that erred
+     * @param url - The url of the request that erred
+     * @param bodyData - The unparsed data for the request that errored
+     */
+    constructor(rawError: DiscordErrorData | OAuthErrorData, code: number | string, status: number, method: string, url: string, bodyData: Pick<InternalRequest, 'body' | 'files'>);
+    /**
+     * The name of the error
+     */
+    get name(): string;
+    private static getMessage;
+    private static flattenDiscordError;
+}
+
+/**
+ * Represents a HTTP error
+ */
+declare class HTTPError extends Error {
+    status: number;
+    method: string;
+    url: string;
+    requestBody: RequestBody;
+    name: string;
+    /**
+     * @param status - The status code of the response
+     * @param statusText - The status text of the response
+     * @param method - The method of the request that erred
+     * @param url - The url of the request that erred
+     * @param bodyData - The unparsed data for the request that errored
+     */
+    constructor(status: number, statusText: string, method: string, url: string, bodyData: Pick<InternalRequest, 'body' | 'files'>);
+}
+
+declare class RateLimitError extends Error implements RateLimitData {
+    timeToReset: number;
+    limit: number;
+    method: string;
+    hash: string;
+    url: string;
+    route: string;
+    majorParameter: string;
+    global: boolean;
+    constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global }: RateLimitData);
+    /**
+     * The name of the error
+     */
+    get name(): string;
+}
+
+/**
+ * Creates and populates an URLSearchParams instance from an object, stripping
+ * out null and undefined values, while also coercing non-strings to strings.
+ *
+ * @param options - The options to use
+ * @returns A populated URLSearchParams instance
+ */
+declare function makeURLSearchParams<T extends object>(options?: Readonly<T>): url.URLSearchParams;
+/**
+ * Converts the response to usable data
+ *
+ * @param res - The fetch response
+ */
+declare function parseResponse(res: ResponseLike): Promise<unknown>;
+/**
+ * Calculates the default avatar index for a given user id.
+ *
+ * @param userId - The user id to calculate the default avatar index for
+ */
+declare function calculateUserDefaultAvatarIndex(userId: Snowflake): number;
+
+/**
+ * The {@link https://github.com/discordjs/discord.js/blob/main/packages/rest/#readme | @discordjs/rest} version
+ * that you are currently using.
+ */
+declare const version: string;
+
+export { DiscordAPIError, DiscordErrorData, HTTPError, InternalRequest, OAuthErrorData, RateLimitData, RateLimitError, RawFile, RequestBody, ResponseLike, calculateUserDefaultAvatarIndex, makeURLSearchParams, parseResponse, version };
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 1f07da3cdf73c2a5c16d62fdc5a1bc43acc10b48..ba3a73fe92f87b1712d2b187009808001f409354 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,13 +1,12 @@
-import { R as RawFile, I as InternalRequest, a as RateLimitData, b as ResponseLike } from './CDN-3496e0d7.js';
-export { s as ALLOWED_EXTENSIONS, u as ALLOWED_SIZES, t as ALLOWED_STICKER_EXTENSIONS, A as APIRequest, B as BaseImageURLOptions, x as BurstHandlerMajorIdKey, C as CDN, q as DefaultRestOptions, D as DefaultUserAgent, p as DefaultUserAgentAppendix, H as HandlerRequestData, i as HashData, v as ImageExtension, w as ImageSize, c as ImageURLOptions, m as InvalidRequestWarningData, M as MakeURLOptions, O as OverwrittenMimeTypes, o as REST, r as RESTEvents, k as RESTOptions, l as RateLimitQueueFilter, d as RequestData, e as RequestHeaders, j as RequestManager, f as RequestMethod, n as RestEvents, h as RouteData, g as RouteLike, S as StickerExtension } from './CDN-3496e0d7.js';
-import { URLSearchParams } from 'node:url';
+import { a as RawFile, I as InternalRequest, b as RateLimitData, R as ResponseLike } from './CDN-03f06673.js';
+export { t as ALLOWED_EXTENSIONS, v as ALLOWED_SIZES, u as ALLOWED_STICKER_EXTENSIONS, A as APIRequest, B as BaseImageURLOptions, y as BurstHandlerMajorIdKey, C as CDN, r as DefaultRestOptions, D as DefaultUserAgent, q as DefaultUserAgentAppendix, H as HandlerRequestData, i as HashData, w as ImageExtension, x as ImageSize, c as ImageURLOptions, m as InvalidRequestWarningData, M as MakeURLOptions, O as OverwrittenMimeTypes, p as REST, s as RESTEvents, k as RESTOptions, l as RateLimitQueueFilter, d as RequestData, e as RequestHeaders, j as RequestManager, f as RequestMethod, n as RestEvents, o as RestEventsMap, h as RouteData, g as RouteLike, S as StickerExtension } from './CDN-03f06673.js';
+import * as url from 'url';
 import { Snowflake } from 'discord-api-types/v10';
-import 'node:events';
+import 'undici';
 import 'node:stream';
 import 'node:stream/web';
 import '@discordjs/collection';
-import 'undici';
-import 'node:buffer';
+import '@vladfrangu/async_event_emitter';

 interface DiscordErrorFieldInformation {
     code: string;
@@ -70,11 +69,12 @@ declare class HTTPError extends Error {
     name: string;
     /**
      * @param status - The status code of the response
+     * @param statusText - The status text of the response
      * @param method - The method of the request that erred
      * @param url - The url of the request that erred
      * @param bodyData - The unparsed data for the request that errored
      */
-    constructor(status: number, method: string, url: string, bodyData: Pick<InternalRequest, 'body' | 'files'>);
+    constructor(status: number, statusText: string, method: string, url: string, bodyData: Pick<InternalRequest, 'body' | 'files'>);
 }

 declare class RateLimitError extends Error implements RateLimitData {
@@ -100,7 +100,7 @@ declare class RateLimitError extends Error implements RateLimitData {
  * @param options - The options to use
  * @returns A populated URLSearchParams instance
  */
-declare function makeURLSearchParams<T extends object>(options?: Readonly<T>): URLSearchParams;
+declare function makeURLSearchParams<T extends object>(options?: Readonly<T>): url.URLSearchParams;
 /**
  * Converts the response to usable data
  *
diff --git a/dist/index.js b/dist/index.js
index 9d53ab7d39ed05843cb4bf20c8325ee0914597c5..5bcdcacd6c0c2140f44f0dfab6279149fef6ff6c 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1,14 +1,9 @@
 "use strict";
-var __create = Object.create;
 var __defProp = Object.defineProperty;
 var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
 var __getOwnPropNames = Object.getOwnPropertyNames;
-var __getProtoOf = Object.getPrototypeOf;
 var __hasOwnProp = Object.prototype.hasOwnProperty;
 var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
-var __esm = (fn, res) => function __init() {
-  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
-};
 var __export = (target, all) => {
   for (var name in all)
     __defProp(target, name, { get: all[name], enumerable: true });
@@ -21,28 +16,51 @@ var __copyProps = (to, from, except, desc) => {
   }
   return to;
 };
-var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
-  // If the importer is in node compatibility mode or this is not an ESM
-  // file that has been converted to a CommonJS file using a Babel-
-  // compatible transform (i.e. "__esModule" has not been set), then set
-  // "default" to the CommonJS "module.exports" for node compatibility.
-  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
-  mod
-));
 var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

-// ../../node_modules/tsup/assets/cjs_shims.js
-var init_cjs_shims = __esm({
-  "../../node_modules/tsup/assets/cjs_shims.js"() {
-  }
+// src/index.ts
+var src_exports = {};
+__export(src_exports, {
+  ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
+  ALLOWED_SIZES: () => ALLOWED_SIZES,
+  ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
+  CDN: () => CDN,
+  DefaultRestOptions: () => DefaultRestOptions,
+  DefaultUserAgent: () => DefaultUserAgent,
+  DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
+  DiscordAPIError: () => DiscordAPIError,
+  HTTPError: () => HTTPError,
+  OverwrittenMimeTypes: () => OverwrittenMimeTypes,
+  REST: () => REST,
+  RESTEvents: () => RESTEvents,
+  RateLimitError: () => RateLimitError,
+  RequestManager: () => RequestManager,
+  RequestMethod: () => RequestMethod,
+  calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
+  makeURLSearchParams: () => makeURLSearchParams,
+  parseResponse: () => parseResponse,
+  version: () => version
 });
+module.exports = __toCommonJS(src_exports);
+var import_util2 = require("@discordjs/util");
+
+// src/environment.ts
+var defaultStrategy;
+function setDefaultStrategy(newStrategy) {
+  defaultStrategy = newStrategy;
+}
+__name(setDefaultStrategy, "setDefaultStrategy");
+function getDefaultStrategy() {
+  return defaultStrategy;
+}
+__name(getDefaultStrategy, "getDefaultStrategy");

 // src/strategies/undiciRequest.ts
-var undiciRequest_exports = {};
-__export(undiciRequest_exports, {
-  makeRequest: () => makeRequest,
-  resolveBody: () => resolveBody
-});
+var import_node_http = require("http");
+var import_node_url = require("url");
+var import_node_util = require("util");
+var import_undici = require("undici");
 async function makeRequest(url, init) {
   const options = {
     ...init,
@@ -65,9 +83,11 @@ async function makeRequest(url, init) {
     },
     headers: new Headers(res.headers),
     status: res.statusCode,
+    statusText: import_node_http.STATUS_CODES[res.statusCode],
     ok: res.statusCode >= 200 && res.statusCode < 300
   };
 }
+__name(makeRequest, "makeRequest");
 async function resolveBody(body) {
   if (body == null) {
     return null;
@@ -87,71 +107,23 @@ async function resolveBody(body) {
     return body;
   } else if (body[Symbol.iterator]) {
     const chunks = [...body];
-    return import_node_buffer.Buffer.concat(chunks);
+    return Buffer.concat(chunks);
   } else if (body[Symbol.asyncIterator]) {
     const chunks = [];
     for await (const chunk of body) {
       chunks.push(chunk);
     }
-    return import_node_buffer.Buffer.concat(chunks);
+    return Buffer.concat(chunks);
   }
   throw new TypeError(`Unable to resolve body.`);
 }
-var import_node_buffer, import_node_url, import_node_util, import_undici;
-var init_undiciRequest = __esm({
-  "src/strategies/undiciRequest.ts"() {
-    "use strict";
-    init_cjs_shims();
-    import_node_buffer = require("buffer");
-    import_node_url = require("url");
-    import_node_util = require("util");
-    import_undici = require("undici");
-    __name(makeRequest, "makeRequest");
-    __name(resolveBody, "resolveBody");
-  }
-});
-
-// src/index.ts
-var src_exports = {};
-__export(src_exports, {
-  ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
-  ALLOWED_SIZES: () => ALLOWED_SIZES,
-  ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
-  BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
-  CDN: () => CDN,
-  DefaultRestOptions: () => DefaultRestOptions,
-  DefaultUserAgent: () => DefaultUserAgent,
-  DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
-  DiscordAPIError: () => DiscordAPIError,
-  HTTPError: () => HTTPError,
-  OverwrittenMimeTypes: () => OverwrittenMimeTypes,
-  REST: () => REST,
-  RESTEvents: () => RESTEvents,
-  RateLimitError: () => RateLimitError,
-  RequestManager: () => RequestManager,
-  RequestMethod: () => RequestMethod,
-  calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
-  makeURLSearchParams: () => makeURLSearchParams,
-  parseResponse: () => parseResponse,
-  version: () => version
-});
-module.exports = __toCommonJS(src_exports);
-init_cjs_shims();
-
-// src/lib/CDN.ts
-init_cjs_shims();
-var import_node_url2 = require("url");
+__name(resolveBody, "resolveBody");

 // src/lib/utils/constants.ts
-init_cjs_shims();
-var import_node_process = __toESM(require("process"));
 var import_util = require("@discordjs/util");
 var import_v10 = require("discord-api-types/v10");
-var getUndiciRequest = (0, import_util.lazy)(async () => {
-  return Promise.resolve().then(() => (init_undiciRequest(), undiciRequest_exports));
-});
 var DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.8.0-dev.1689552764-351a18b.0)`;
-var DefaultUserAgentAppendix = import_node_process.default.release?.name === "node" ? `Node.js/${import_node_process.default.version}` : "";
+var DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();
 var DefaultRestOptions = {
   agent: null,
   api: "https://discord.com/api",
@@ -173,8 +145,7 @@ var DefaultRestOptions = {
   handlerSweepInterval: 36e5,
   // 1 Hour
   async makeRequest(...args) {
-    const strategy = await getUndiciRequest();
-    return strategy.makeRequest(...args);
+    return getDefaultStrategy()(...args);
   }
 };
 var RESTEvents = /* @__PURE__ */ ((RESTEvents2) => {
@@ -200,6 +171,9 @@ var CDN = class {
   constructor(base = DefaultRestOptions.cdn) {
     this.base = base;
   }
+  static {
+    __name(this, "CDN");
+  }
   /**
    * Generates an app asset URL for a client's asset.
    *
@@ -408,17 +382,15 @@ Must be one of: ${allowedExtensions.join(", ")}`);
       throw new RangeError(`Invalid size provided: ${size}
 Must be one of: ${ALLOWED_SIZES.join(", ")}`);
     }
-    const url = new import_node_url2.URL(`${this.base}${route}.${extension}`);
+    const url = new URL(`${this.base}${route}.${extension}`);
     if (size) {
       url.searchParams.set("size", String(size));
     }
     return url.toString();
   }
 };
-__name(CDN, "CDN");

 // src/lib/errors/DiscordAPIError.ts
-init_cjs_shims();
 function isErrorGroupWrapper(error) {
   return Reflect.has(error, "_errors");
 }
@@ -427,7 +399,7 @@ function isErrorResponse(error) {
   return typeof Reflect.get(error, "message") === "string";
 }
 __name(isErrorResponse, "isErrorResponse");
-var DiscordAPIError = class extends Error {
+var DiscordAPIError = class _DiscordAPIError extends Error {
   /**
    * @param rawError - The error reported by Discord
    * @param code - The error code reported by Discord
@@ -437,7 +409,7 @@ var DiscordAPIError = class extends Error {
    * @param bodyData - The unparsed data for the request that errored
    */
   constructor(rawError, code, status, method, url, bodyData) {
-    super(DiscordAPIError.getMessage(rawError));
+    super(_DiscordAPIError.getMessage(rawError));
     this.rawError = rawError;
     this.code = code;
     this.status = status;
@@ -445,12 +417,15 @@ var DiscordAPIError = class extends Error {
     this.url = url;
     this.requestBody = { files: bodyData.files, json: bodyData.body };
   }
+  static {
+    __name(this, "DiscordAPIError");
+  }
   requestBody;
   /**
    * The name of the error
    */
   get name() {
-    return `${DiscordAPIError.name}[${this.code}]`;
+    return `${_DiscordAPIError.name}[${this.code}]`;
   }
   static getMessage(error) {
     let flattened = "";
@@ -481,33 +456,35 @@ ${flattened}` : error.message || flattened || "Unknown Error";
     }
   }
 };
-__name(DiscordAPIError, "DiscordAPIError");

 // src/lib/errors/HTTPError.ts
-init_cjs_shims();
-var import_node_http = require("http");
-var HTTPError = class extends Error {
+var HTTPError = class _HTTPError extends Error {
   /**
    * @param status - The status code of the response
+   * @param statusText - The status text of the response
    * @param method - The method of the request that erred
    * @param url - The url of the request that erred
    * @param bodyData - The unparsed data for the request that errored
    */
-  constructor(status, method, url, bodyData) {
-    super(import_node_http.STATUS_CODES[status]);
+  constructor(status, statusText, method, url, bodyData) {
+    super(statusText);
     this.status = status;
     this.method = method;
     this.url = url;
     this.requestBody = { files: bodyData.files, json: bodyData.body };
   }
+  static {
+    __name(this, "HTTPError");
+  }
   requestBody;
-  name = HTTPError.name;
+  name = _HTTPError.name;
 };
-__name(HTTPError, "HTTPError");

 // src/lib/errors/RateLimitError.ts
-init_cjs_shims();
-var RateLimitError = class extends Error {
+var RateLimitError = class _RateLimitError extends Error {
+  static {
+    __name(this, "RateLimitError");
+  }
   timeToReset;
   limit;
   method;
@@ -531,27 +508,17 @@ var RateLimitError = class extends Error {
    * The name of the error
    */
   get name() {
-    return `${RateLimitError.name}[${this.route}]`;
+    return `${_RateLimitError.name}[${this.route}]`;
   }
 };
-__name(RateLimitError, "RateLimitError");

 // src/lib/RequestManager.ts
-init_cjs_shims();
-var import_node_buffer2 = require("buffer");
-var import_node_events = require("events");
-var import_node_timers2 = require("timers");
 var import_collection = require("@discordjs/collection");
-var import_util2 = require("@discordjs/util");
 var import_snowflake = require("@sapphire/snowflake");
-
-// src/lib/handlers/BurstHandler.ts
-init_cjs_shims();
-var import_promises = require("timers/promises");
+var import_async_event_emitter = require("@vladfrangu/async_event_emitter");
+var import_magic_bytes = require("magic-bytes.js");

 // src/lib/utils/utils.ts
-init_cjs_shims();
-var import_node_url3 = require("url");
 function serializeSearchParam(value) {
   switch (typeof value) {
     case "string":
@@ -575,7 +542,7 @@ function serializeSearchParam(value) {
 }
 __name(serializeSearchParam, "serializeSearchParam");
 function makeURLSearchParams(options) {
-  const params = new import_node_url3.URLSearchParams();
+  const params = new URLSearchParams();
   if (!options)
     return params;
   for (const [key, value] of Object.entries(options)) {
@@ -625,10 +592,18 @@ function calculateUserDefaultAvatarIndex(userId) {
   return Number(BigInt(userId) >> 22n) % 6;
 }
 __name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
+async function sleep(ms) {
+  return new Promise((resolve) => {
+    setTimeout(() => resolve(), ms);
+  });
+}
+__name(sleep, "sleep");
+function isBufferLike(value) {
+  return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
+}
+__name(isBufferLike, "isBufferLike");

 // src/lib/handlers/Shared.ts
-init_cjs_shims();
-var import_node_timers = require("timers");
 var import_undici2 = require("undici");
 var invalidCount = 0;
 var invalidCountResetTime = null;
@@ -649,7 +624,7 @@ function incrementInvalidCount(manager) {
 __name(incrementInvalidCount, "incrementInvalidCount");
 async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
   const controller = new AbortController();
-  const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), manager.options.timeout).unref();
+  const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
   if (requestData.signal) {
     if (requestData.signal.aborted)
       controller.abort();
@@ -667,13 +642,13 @@ async function makeNetworkRequest(manager, routeId, url, options, requestData, r
     }
     throw error;
   } finally {
-    (0, import_node_timers.clearTimeout)(timeout);
+    clearTimeout(timeout);
   }
   if (manager.listenerCount("response" /* Response */)) {
     manager.emit(
       "response" /* Response */,
       {
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         path: routeId.original,
         route: routeId.bucketRoute,
         options,
@@ -692,7 +667,7 @@ async function handleErrors(manager, res, method, url, requestData, retries) {
     if (retries !== manager.options.retries) {
       return null;
     }
-    throw new HTTPError(status, method, url, requestData);
+    throw new HTTPError(status, res.statusText, method, url, requestData);
   } else {
     if (status >= 400 && status < 500) {
       if (status === 401 && requestData.auth) {
@@ -719,6 +694,9 @@ var BurstHandler = class {
     this.majorParameter = majorParameter;
     this.id = `${hash}:${majorParameter}`;
   }
+  static {
+    __name(this, "BurstHandler");
+  }
   /**
    * {@inheritdoc IHandler.id}
    */
@@ -751,10 +729,10 @@ var BurstHandler = class {
    * @param retries - The number of retries this request has already attempted (recursion)
    */
   async runRequest(routeId, url, options, requestData, retries = 0) {
-    const method = options.method ?? "get";
+    const method = options.method ?? "GET" /* Get */;
     const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
     if (res === null) {
-      return this.runRequest(routeId, url, options, requestData, ++retries);
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.status;
     let retryAfter = 0;
@@ -792,22 +770,19 @@ var BurstHandler = class {
           `  Sublimit       : None`
         ].join("\n")
       );
-      await (0, import_promises.setTimeout)(retryAfter);
+      await sleep(retryAfter);
       return this.runRequest(routeId, url, options, requestData, retries);
     } else {
       const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
       if (handled === null) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       return handled;
     }
   }
 };
-__name(BurstHandler, "BurstHandler");

 // src/lib/handlers/SequentialHandler.ts
-init_cjs_shims();
-var import_promises2 = require("timers/promises");
 var import_async_queue = require("@sapphire/async-queue");
 var SequentialHandler = class {
   /**
@@ -821,6 +796,9 @@ var SequentialHandler = class {
     this.majorParameter = majorParameter;
     this.id = `${hash}:${majorParameter}`;
   }
+  static {
+    __name(this, "SequentialHandler");
+  }
   /**
    * {@inheritDoc IHandler.id}
    */
@@ -897,7 +875,7 @@ var SequentialHandler = class {
    * @param time - The amount of time to delay all requests for
    */
   async globalDelayFor(time) {
-    await (0, import_promises2.setTimeout)(time);
+    await sleep(time);
     this.manager.globalDelay = null;
   }
   /**
@@ -960,12 +938,12 @@ var SequentialHandler = class {
       } else {
         limit2 = this.limit;
         timeout = this.timeToReset;
-        delay = (0, import_promises2.setTimeout)(timeout);
+        delay = sleep(timeout);
       }
       const rateLimitData = {
         timeToReset: timeout,
         limit: limit2,
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         hash: this.hash,
         url,
         route: routeId.bucketRoute,
@@ -986,10 +964,10 @@ var SequentialHandler = class {
       this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
     }
     this.manager.globalRemaining--;
-    const method = options.method ?? "get";
+    const method = options.method ?? "GET" /* Get */;
     const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
     if (res === null) {
-      return this.runRequest(routeId, url, options, requestData, ++retries);
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.status;
     let retryAfter = 0;
@@ -1070,7 +1048,7 @@ var SequentialHandler = class {
         }
         this.#sublimitPromise?.resolve();
         this.#sublimitPromise = null;
-        await (0, import_promises2.setTimeout)(sublimitTimeout);
+        await sleep(sublimitTimeout);
         let resolve;
         const promise = new Promise((res2) => resolve = res2);
         this.#sublimitPromise = { promise, resolve };
@@ -1083,16 +1061,14 @@ var SequentialHandler = class {
     } else {
       const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
       if (handled === null) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       return handled;
     }
   }
 };
-__name(SequentialHandler, "SequentialHandler");

 // src/lib/RequestManager.ts
-var getFileType = (0, import_util2.lazy)(async () => import("file-type"));
 var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Delete"] = "DELETE";
   RequestMethod2["Get"] = "GET";
@@ -1101,7 +1077,10 @@ var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Put"] = "PUT";
   return RequestMethod2;
 })(RequestMethod || {});
-var RequestManager = class extends import_node_events.EventEmitter {
+var RequestManager = class _RequestManager extends import_async_event_emitter.AsyncEventEmitter {
+  static {
+    __name(this, "RequestManager");
+  }
   /**
    * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
    * performed by this manager.
@@ -1147,7 +1126,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
     }, "validateMaxInterval");
     if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.hashSweepInterval);
-      this.hashTimer = (0, import_node_timers2.setInterval)(() => {
+      this.hashTimer = setInterval(() => {
         const sweptHashes = new import_collection.Collection();
         const currentDate = Date.now();
         this.hashes.sweep((val, key) => {
@@ -1161,11 +1140,11 @@ var RequestManager = class extends import_node_events.EventEmitter {
           return shouldSweep;
         });
         this.emit("hashSweep" /* HashSweep */, sweptHashes);
-      }, this.options.hashSweepInterval).unref();
+      }, this.options.hashSweepInterval);
     }
     if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.handlerSweepInterval);
-      this.handlerTimer = (0, import_node_timers2.setInterval)(() => {
+      this.handlerTimer = setInterval(() => {
         const sweptHandlers = new import_collection.Collection();
         this.handlers.sweep((val, key) => {
           const { inactive } = val;
@@ -1176,7 +1155,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
           return inactive;
         });
         this.emit("handlerSweep" /* HandlerSweep */, sweptHandlers);
-      }, this.options.handlerSweepInterval).unref();
+      }, this.options.handlerSweepInterval);
     }
   }
   /**
@@ -1204,7 +1183,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
    * @returns The response from the api request
    */
   async queueRequest(request2) {
-    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
+    const routeId = _RequestManager.generateRouteData(request2.fullRoute, request2.method);
     const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
       value: `Global(${request2.method}:${routeId.bucketRoute})`,
       lastAccess: -1
@@ -1264,18 +1243,17 @@ var RequestManager = class extends import_node_events.EventEmitter {
       const formData = new FormData();
       for (const [index, file] of request2.files.entries()) {
         const fileKey = file.key ?? `files[${index}]`;
-        if (import_node_buffer2.Buffer.isBuffer(file.data)) {
-          const { fileTypeFromBuffer } = await getFileType();
+        if (isBufferLike(file.data)) {
           let contentType = file.contentType;
           if (!contentType) {
-            const parsedType = (await fileTypeFromBuffer(file.data))?.mime;
+            const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);
             if (parsedType) {
-              contentType = OverwrittenMimeTypes[parsedType] ?? parsedType;
+              contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
             }
           }
-          formData.append(fileKey, new import_node_buffer2.Blob([file.data], { type: contentType }), file.name);
+          formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
         } else {
-          formData.append(fileKey, new import_node_buffer2.Blob([`${file.data}`], { type: file.contentType }), file.name);
+          formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
         }
       }
       if (request2.body != null) {
@@ -1311,13 +1289,13 @@ var RequestManager = class extends import_node_events.EventEmitter {
    * Stops the hash sweeping interval
    */
   clearHashSweeper() {
-    (0, import_node_timers2.clearInterval)(this.hashTimer);
+    clearInterval(this.hashTimer);
   }
   /**
    * Stops the request handler sweeping interval
    */
   clearHandlerSweeper() {
-    (0, import_node_timers2.clearInterval)(this.handlerTimer);
+    clearInterval(this.handlerTimer);
   }
   /**
    * Generates route data for an endpoint:method
@@ -1352,12 +1330,13 @@ var RequestManager = class extends import_node_events.EventEmitter {
     };
   }
 };
-__name(RequestManager, "RequestManager");

 // src/lib/REST.ts
-init_cjs_shims();
-var import_node_events2 = require("events");
-var REST = class extends import_node_events2.EventEmitter {
+var import_async_event_emitter2 = require("@vladfrangu/async_event_emitter");
+var REST = class extends import_async_event_emitter2.AsyncEventEmitter {
+  static {
+    __name(this, "REST");
+  }
   cdn;
   requestManager;
   constructor(options = {}) {
@@ -1403,7 +1382,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async get(fullRoute, options = {}) {
+  async get(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "GET" /* Get */ });
   }
   /**
@@ -1412,7 +1391,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async delete(fullRoute, options = {}) {
+  async delete(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "DELETE" /* Delete */ });
   }
   /**
@@ -1421,7 +1400,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async post(fullRoute, options = {}) {
+  async post(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "POST" /* Post */ });
   }
   /**
@@ -1430,7 +1409,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async put(fullRoute, options = {}) {
+  async put(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PUT" /* Put */ });
   }
   /**
@@ -1439,7 +1418,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async patch(fullRoute, options = {}) {
+  async patch(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PATCH" /* Patch */ });
   }
   /**
@@ -1460,10 +1439,12 @@ var REST = class extends import_node_events2.EventEmitter {
     return this.requestManager.queueRequest(options);
   }
 };
-__name(REST, "REST");

-// src/index.ts
+// src/shared.ts
 var version = "1.8.0-dev.1689552764-351a18b.0";
+
+// src/index.ts
+setDefaultStrategy((0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? fetch : makeRequest);
 // Annotate the CommonJS export names for ESM import in node:
 0 && (module.exports = {
   ALLOWED_EXTENSIONS,
diff --git a/dist/index.mjs b/dist/index.mjs
index 0d8749715fa5bcc965237ebb0ee166db78c69973..72a40c27974fe180809b4a28aa077cf1eddfa652 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -1,30 +1,23 @@
 var __defProp = Object.defineProperty;
-var __getOwnPropNames = Object.getOwnPropertyNames;
 var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
-var __esm = (fn, res) => function __init() {
-  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
-};
-var __export = (target, all) => {
-  for (var name in all)
-    __defProp(target, name, { get: all[name], enumerable: true });
-};

-// ../../node_modules/tsup/assets/esm_shims.js
-import { fileURLToPath } from "url";
-import path from "path";
-var init_esm_shims = __esm({
-  "../../node_modules/tsup/assets/esm_shims.js"() {
-  }
-});
+// src/index.ts
+import { shouldUseGlobalFetchAndWebSocket } from "@discordjs/util";
+
+// src/environment.ts
+var defaultStrategy;
+function setDefaultStrategy(newStrategy) {
+  defaultStrategy = newStrategy;
+}
+__name(setDefaultStrategy, "setDefaultStrategy");
+function getDefaultStrategy() {
+  return defaultStrategy;
+}
+__name(getDefaultStrategy, "getDefaultStrategy");

 // src/strategies/undiciRequest.ts
-var undiciRequest_exports = {};
-__export(undiciRequest_exports, {
-  makeRequest: () => makeRequest,
-  resolveBody: () => resolveBody
-});
-import { Buffer as Buffer2 } from "node:buffer";
-import { URLSearchParams } from "node:url";
+import { STATUS_CODES } from "node:http";
+import { URLSearchParams as URLSearchParams2 } from "node:url";
 import { types } from "node:util";
 import { request } from "undici";
 async function makeRequest(url, init) {
@@ -49,9 +42,11 @@ async function makeRequest(url, init) {
     },
     headers: new Headers(res.headers),
     status: res.statusCode,
+    statusText: STATUS_CODES[res.statusCode],
     ok: res.statusCode >= 200 && res.statusCode < 300
   };
 }
+__name(makeRequest, "makeRequest");
 async function resolveBody(body) {
   if (body == null) {
     return null;
@@ -61,7 +56,7 @@ async function resolveBody(body) {
     return body;
   } else if (types.isArrayBuffer(body)) {
     return new Uint8Array(body);
-  } else if (body instanceof URLSearchParams) {
+  } else if (body instanceof URLSearchParams2) {
     return body.toString();
   } else if (body instanceof DataView) {
     return new Uint8Array(body.buffer);
@@ -71,42 +66,23 @@ async function resolveBody(body) {
     return body;
   } else if (body[Symbol.iterator]) {
     const chunks = [...body];
-    return Buffer2.concat(chunks);
+    return Buffer.concat(chunks);
   } else if (body[Symbol.asyncIterator]) {
     const chunks = [];
     for await (const chunk of body) {
       chunks.push(chunk);
     }
-    return Buffer2.concat(chunks);
+    return Buffer.concat(chunks);
   }
   throw new TypeError(`Unable to resolve body.`);
 }
-var init_undiciRequest = __esm({
-  "src/strategies/undiciRequest.ts"() {
-    "use strict";
-    init_esm_shims();
-    __name(makeRequest, "makeRequest");
-    __name(resolveBody, "resolveBody");
-  }
-});
-
-// src/index.ts
-init_esm_shims();
-
-// src/lib/CDN.ts
-init_esm_shims();
-import { URL } from "node:url";
+__name(resolveBody, "resolveBody");

 // src/lib/utils/constants.ts
-init_esm_shims();
-import process from "node:process";
-import { lazy } from "@discordjs/util";
+import { getUserAgentAppendix } from "@discordjs/util";
 import { APIVersion } from "discord-api-types/v10";
-var getUndiciRequest = lazy(async () => {
-  return Promise.resolve().then(() => (init_undiciRequest(), undiciRequest_exports));
-});
 var DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.8.0-dev.1689552764-351a18b.0)`;
-var DefaultUserAgentAppendix = process.release?.name === "node" ? `Node.js/${process.version}` : "";
+var DefaultUserAgentAppendix = getUserAgentAppendix();
 var DefaultRestOptions = {
   agent: null,
   api: "https://discord.com/api",
@@ -128,8 +104,7 @@ var DefaultRestOptions = {
   handlerSweepInterval: 36e5,
   // 1 Hour
   async makeRequest(...args) {
-    const strategy = await getUndiciRequest();
-    return strategy.makeRequest(...args);
+    return getDefaultStrategy()(...args);
   }
 };
 var RESTEvents = /* @__PURE__ */ ((RESTEvents2) => {
@@ -155,6 +130,9 @@ var CDN = class {
   constructor(base = DefaultRestOptions.cdn) {
     this.base = base;
   }
+  static {
+    __name(this, "CDN");
+  }
   /**
    * Generates an app asset URL for a client's asset.
    *
@@ -370,10 +348,8 @@ Must be one of: ${ALLOWED_SIZES.join(", ")}`);
     return url.toString();
   }
 };
-__name(CDN, "CDN");

 // src/lib/errors/DiscordAPIError.ts
-init_esm_shims();
 function isErrorGroupWrapper(error) {
   return Reflect.has(error, "_errors");
 }
@@ -382,7 +358,7 @@ function isErrorResponse(error) {
   return typeof Reflect.get(error, "message") === "string";
 }
 __name(isErrorResponse, "isErrorResponse");
-var DiscordAPIError = class extends Error {
+var DiscordAPIError = class _DiscordAPIError extends Error {
   /**
    * @param rawError - The error reported by Discord
    * @param code - The error code reported by Discord
@@ -392,7 +368,7 @@ var DiscordAPIError = class extends Error {
    * @param bodyData - The unparsed data for the request that errored
    */
   constructor(rawError, code, status, method, url, bodyData) {
-    super(DiscordAPIError.getMessage(rawError));
+    super(_DiscordAPIError.getMessage(rawError));
     this.rawError = rawError;
     this.code = code;
     this.status = status;
@@ -400,12 +376,15 @@ var DiscordAPIError = class extends Error {
     this.url = url;
     this.requestBody = { files: bodyData.files, json: bodyData.body };
   }
+  static {
+    __name(this, "DiscordAPIError");
+  }
   requestBody;
   /**
    * The name of the error
    */
   get name() {
-    return `${DiscordAPIError.name}[${this.code}]`;
+    return `${_DiscordAPIError.name}[${this.code}]`;
   }
   static getMessage(error) {
     let flattened = "";
@@ -436,33 +415,35 @@ ${flattened}` : error.message || flattened || "Unknown Error";
     }
   }
 };
-__name(DiscordAPIError, "DiscordAPIError");

 // src/lib/errors/HTTPError.ts
-init_esm_shims();
-import { STATUS_CODES } from "node:http";
-var HTTPError = class extends Error {
+var HTTPError = class _HTTPError extends Error {
   /**
    * @param status - The status code of the response
+   * @param statusText - The status text of the response
    * @param method - The method of the request that erred
    * @param url - The url of the request that erred
    * @param bodyData - The unparsed data for the request that errored
    */
-  constructor(status, method, url, bodyData) {
-    super(STATUS_CODES[status]);
+  constructor(status, statusText, method, url, bodyData) {
+    super(statusText);
     this.status = status;
     this.method = method;
     this.url = url;
     this.requestBody = { files: bodyData.files, json: bodyData.body };
   }
+  static {
+    __name(this, "HTTPError");
+  }
   requestBody;
-  name = HTTPError.name;
+  name = _HTTPError.name;
 };
-__name(HTTPError, "HTTPError");

 // src/lib/errors/RateLimitError.ts
-init_esm_shims();
-var RateLimitError = class extends Error {
+var RateLimitError = class _RateLimitError extends Error {
+  static {
+    __name(this, "RateLimitError");
+  }
   timeToReset;
   limit;
   method;
@@ -486,27 +467,17 @@ var RateLimitError = class extends Error {
    * The name of the error
    */
   get name() {
-    return `${RateLimitError.name}[${this.route}]`;
+    return `${_RateLimitError.name}[${this.route}]`;
   }
 };
-__name(RateLimitError, "RateLimitError");

 // src/lib/RequestManager.ts
-init_esm_shims();
-import { Blob as Blob2, Buffer as Buffer3 } from "node:buffer";
-import { EventEmitter } from "node:events";
-import { setInterval, clearInterval } from "node:timers";
 import { Collection } from "@discordjs/collection";
-import { lazy as lazy2 } from "@discordjs/util";
 import { DiscordSnowflake } from "@sapphire/snowflake";
-
-// src/lib/handlers/BurstHandler.ts
-init_esm_shims();
-import { setTimeout as sleep } from "node:timers/promises";
+import { AsyncEventEmitter } from "@vladfrangu/async_event_emitter";
+import { filetypeinfo } from "magic-bytes.js";

 // src/lib/utils/utils.ts
-init_esm_shims();
-import { URLSearchParams as URLSearchParams2 } from "node:url";
 function serializeSearchParam(value) {
   switch (typeof value) {
     case "string":
@@ -530,7 +501,7 @@ function serializeSearchParam(value) {
 }
 __name(serializeSearchParam, "serializeSearchParam");
 function makeURLSearchParams(options) {
-  const params = new URLSearchParams2();
+  const params = new URLSearchParams();
   if (!options)
     return params;
   for (const [key, value] of Object.entries(options)) {
@@ -580,10 +551,18 @@ function calculateUserDefaultAvatarIndex(userId) {
   return Number(BigInt(userId) >> 22n) % 6;
 }
 __name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
+async function sleep(ms) {
+  return new Promise((resolve) => {
+    setTimeout(() => resolve(), ms);
+  });
+}
+__name(sleep, "sleep");
+function isBufferLike(value) {
+  return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
+}
+__name(isBufferLike, "isBufferLike");

 // src/lib/handlers/Shared.ts
-init_esm_shims();
-import { setTimeout, clearTimeout } from "node:timers";
 import { Response } from "undici";
 var invalidCount = 0;
 var invalidCountResetTime = null;
@@ -604,7 +583,7 @@ function incrementInvalidCount(manager) {
 __name(incrementInvalidCount, "incrementInvalidCount");
 async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
   const controller = new AbortController();
-  const timeout = setTimeout(() => controller.abort(), manager.options.timeout).unref();
+  const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
   if (requestData.signal) {
     if (requestData.signal.aborted)
       controller.abort();
@@ -628,7 +607,7 @@ async function makeNetworkRequest(manager, routeId, url, options, requestData, r
     manager.emit(
       "response" /* Response */,
       {
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         path: routeId.original,
         route: routeId.bucketRoute,
         options,
@@ -647,7 +626,7 @@ async function handleErrors(manager, res, method, url, requestData, retries) {
     if (retries !== manager.options.retries) {
       return null;
     }
-    throw new HTTPError(status, method, url, requestData);
+    throw new HTTPError(status, res.statusText, method, url, requestData);
   } else {
     if (status >= 400 && status < 500) {
       if (status === 401 && requestData.auth) {
@@ -674,6 +653,9 @@ var BurstHandler = class {
     this.majorParameter = majorParameter;
     this.id = `${hash}:${majorParameter}`;
   }
+  static {
+    __name(this, "BurstHandler");
+  }
   /**
    * {@inheritdoc IHandler.id}
    */
@@ -706,10 +688,10 @@ var BurstHandler = class {
    * @param retries - The number of retries this request has already attempted (recursion)
    */
   async runRequest(routeId, url, options, requestData, retries = 0) {
-    const method = options.method ?? "get";
+    const method = options.method ?? "GET" /* Get */;
     const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
     if (res === null) {
-      return this.runRequest(routeId, url, options, requestData, ++retries);
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.status;
     let retryAfter = 0;
@@ -752,17 +734,14 @@ var BurstHandler = class {
     } else {
       const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
       if (handled === null) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       return handled;
     }
   }
 };
-__name(BurstHandler, "BurstHandler");

 // src/lib/handlers/SequentialHandler.ts
-init_esm_shims();
-import { setTimeout as sleep2 } from "node:timers/promises";
 import { AsyncQueue } from "@sapphire/async-queue";
 var SequentialHandler = class {
   /**
@@ -776,6 +755,9 @@ var SequentialHandler = class {
     this.majorParameter = majorParameter;
     this.id = `${hash}:${majorParameter}`;
   }
+  static {
+    __name(this, "SequentialHandler");
+  }
   /**
    * {@inheritDoc IHandler.id}
    */
@@ -852,7 +834,7 @@ var SequentialHandler = class {
    * @param time - The amount of time to delay all requests for
    */
   async globalDelayFor(time) {
-    await sleep2(time);
+    await sleep(time);
     this.manager.globalDelay = null;
   }
   /**
@@ -915,12 +897,12 @@ var SequentialHandler = class {
       } else {
         limit2 = this.limit;
         timeout = this.timeToReset;
-        delay = sleep2(timeout);
+        delay = sleep(timeout);
       }
       const rateLimitData = {
         timeToReset: timeout,
         limit: limit2,
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         hash: this.hash,
         url,
         route: routeId.bucketRoute,
@@ -941,10 +923,10 @@ var SequentialHandler = class {
       this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
     }
     this.manager.globalRemaining--;
-    const method = options.method ?? "get";
+    const method = options.method ?? "GET" /* Get */;
     const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
     if (res === null) {
-      return this.runRequest(routeId, url, options, requestData, ++retries);
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.status;
     let retryAfter = 0;
@@ -1025,7 +1007,7 @@ var SequentialHandler = class {
         }
         this.#sublimitPromise?.resolve();
         this.#sublimitPromise = null;
-        await sleep2(sublimitTimeout);
+        await sleep(sublimitTimeout);
         let resolve;
         const promise = new Promise((res2) => resolve = res2);
         this.#sublimitPromise = { promise, resolve };
@@ -1038,16 +1020,14 @@ var SequentialHandler = class {
     } else {
       const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
       if (handled === null) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       return handled;
     }
   }
 };
-__name(SequentialHandler, "SequentialHandler");

 // src/lib/RequestManager.ts
-var getFileType = lazy2(async () => import("file-type"));
 var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Delete"] = "DELETE";
   RequestMethod2["Get"] = "GET";
@@ -1056,7 +1036,10 @@ var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Put"] = "PUT";
   return RequestMethod2;
 })(RequestMethod || {});
-var RequestManager = class extends EventEmitter {
+var RequestManager = class _RequestManager extends AsyncEventEmitter {
+  static {
+    __name(this, "RequestManager");
+  }
   /**
    * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
    * performed by this manager.
@@ -1116,7 +1099,7 @@ var RequestManager = class extends EventEmitter {
           return shouldSweep;
         });
         this.emit("hashSweep" /* HashSweep */, sweptHashes);
-      }, this.options.hashSweepInterval).unref();
+      }, this.options.hashSweepInterval);
     }
     if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.handlerSweepInterval);
@@ -1131,7 +1114,7 @@ var RequestManager = class extends EventEmitter {
           return inactive;
         });
         this.emit("handlerSweep" /* HandlerSweep */, sweptHandlers);
-      }, this.options.handlerSweepInterval).unref();
+      }, this.options.handlerSweepInterval);
     }
   }
   /**
@@ -1159,7 +1142,7 @@ var RequestManager = class extends EventEmitter {
    * @returns The response from the api request
    */
   async queueRequest(request2) {
-    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
+    const routeId = _RequestManager.generateRouteData(request2.fullRoute, request2.method);
     const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
       value: `Global(${request2.method}:${routeId.bucketRoute})`,
       lastAccess: -1
@@ -1219,18 +1202,17 @@ var RequestManager = class extends EventEmitter {
       const formData = new FormData();
       for (const [index, file] of request2.files.entries()) {
         const fileKey = file.key ?? `files[${index}]`;
-        if (Buffer3.isBuffer(file.data)) {
-          const { fileTypeFromBuffer } = await getFileType();
+        if (isBufferLike(file.data)) {
           let contentType = file.contentType;
           if (!contentType) {
-            const parsedType = (await fileTypeFromBuffer(file.data))?.mime;
+            const [parsedType] = filetypeinfo(file.data);
             if (parsedType) {
-              contentType = OverwrittenMimeTypes[parsedType] ?? parsedType;
+              contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
             }
           }
-          formData.append(fileKey, new Blob2([file.data], { type: contentType }), file.name);
+          formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
         } else {
-          formData.append(fileKey, new Blob2([`${file.data}`], { type: file.contentType }), file.name);
+          formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
         }
       }
       if (request2.body != null) {
@@ -1307,12 +1289,13 @@ var RequestManager = class extends EventEmitter {
     };
   }
 };
-__name(RequestManager, "RequestManager");

 // src/lib/REST.ts
-init_esm_shims();
-import { EventEmitter as EventEmitter2 } from "node:events";
-var REST = class extends EventEmitter2 {
+import { AsyncEventEmitter as AsyncEventEmitter2 } from "@vladfrangu/async_event_emitter";
+var REST = class extends AsyncEventEmitter2 {
+  static {
+    __name(this, "REST");
+  }
   cdn;
   requestManager;
   constructor(options = {}) {
@@ -1358,7 +1341,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async get(fullRoute, options = {}) {
+  async get(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "GET" /* Get */ });
   }
   /**
@@ -1367,7 +1350,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async delete(fullRoute, options = {}) {
+  async delete(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "DELETE" /* Delete */ });
   }
   /**
@@ -1376,7 +1359,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async post(fullRoute, options = {}) {
+  async post(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "POST" /* Post */ });
   }
   /**
@@ -1385,7 +1368,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async put(fullRoute, options = {}) {
+  async put(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PUT" /* Put */ });
   }
   /**
@@ -1394,7 +1377,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async patch(fullRoute, options = {}) {
+  async patch(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PATCH" /* Patch */ });
   }
   /**
@@ -1415,10 +1398,12 @@ var REST = class extends EventEmitter2 {
     return this.requestManager.queueRequest(options);
   }
 };
-__name(REST, "REST");

-// src/index.ts
+// src/shared.ts
 var version = "1.8.0-dev.1689552764-351a18b.0";
+
+// src/index.ts
+setDefaultStrategy(shouldUseGlobalFetchAndWebSocket() ? fetch : makeRequest);
 export {
   ALLOWED_EXTENSIONS,
   ALLOWED_SIZES,
diff --git a/dist/strategies/undiciRequest.d.mts b/dist/strategies/undiciRequest.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..b12b72afb96edb598c7c4b8e7981b58a47be228d
--- /dev/null
+++ b/dist/strategies/undiciRequest.d.mts
@@ -0,0 +1,12 @@
+import { request, RequestInit } from 'undici';
+import { R as ResponseLike } from '../CDN-03f06673.js';
+import 'node:stream';
+import 'node:stream/web';
+import '@discordjs/collection';
+import '@vladfrangu/async_event_emitter';
+
+type RequestOptions = Exclude<Parameters<typeof request>[1], undefined>;
+declare function makeRequest(url: string, init: RequestInit): Promise<ResponseLike>;
+declare function resolveBody(body: RequestInit['body']): Promise<Exclude<RequestOptions['body'], undefined>>;
+
+export { RequestOptions, makeRequest, resolveBody };
diff --git a/dist/strategies/undiciRequest.d.ts b/dist/strategies/undiciRequest.d.ts
index 51292b562b3ff757ea3dbcb61a487be69bc2ffcc..b12b72afb96edb598c7c4b8e7981b58a47be228d 100644
--- a/dist/strategies/undiciRequest.d.ts
+++ b/dist/strategies/undiciRequest.d.ts
@@ -1,11 +1,9 @@
 import { request, RequestInit } from 'undici';
-import { b as ResponseLike } from '../CDN-3496e0d7.js';
-import 'node:events';
+import { R as ResponseLike } from '../CDN-03f06673.js';
 import 'node:stream';
 import 'node:stream/web';
 import '@discordjs/collection';
-import 'node:buffer';
-import 'node:url';
+import '@vladfrangu/async_event_emitter';

 type RequestOptions = Exclude<Parameters<typeof request>[1], undefined>;
 declare function makeRequest(url: string, init: RequestInit): Promise<ResponseLike>;
diff --git a/dist/strategies/undiciRequest.js b/dist/strategies/undiciRequest.js
index 2f76b7a07cecf88feee63ff9728a10e6bf8b052b..3d750502df41bfae6f90df094b2043d7cfeee757 100644
--- a/dist/strategies/undiciRequest.js
+++ b/dist/strategies/undiciRequest.js
@@ -25,7 +25,7 @@ __export(undiciRequest_exports, {
   resolveBody: () => resolveBody
 });
 module.exports = __toCommonJS(undiciRequest_exports);
-var import_node_buffer = require("buffer");
+var import_node_http = require("http");
 var import_node_url = require("url");
 var import_node_util = require("util");
 var import_undici = require("undici");
@@ -51,6 +51,7 @@ async function makeRequest(url, init) {
     },
     headers: new Headers(res.headers),
     status: res.statusCode,
+    statusText: import_node_http.STATUS_CODES[res.statusCode],
     ok: res.statusCode >= 200 && res.statusCode < 300
   };
 }
@@ -74,13 +75,13 @@ async function resolveBody(body) {
     return body;
   } else if (body[Symbol.iterator]) {
     const chunks = [...body];
-    return import_node_buffer.Buffer.concat(chunks);
+    return Buffer.concat(chunks);
   } else if (body[Symbol.asyncIterator]) {
     const chunks = [];
     for await (const chunk of body) {
       chunks.push(chunk);
     }
-    return import_node_buffer.Buffer.concat(chunks);
+    return Buffer.concat(chunks);
   }
   throw new TypeError(`Unable to resolve body.`);
 }
diff --git a/dist/strategies/undiciRequest.mjs b/dist/strategies/undiciRequest.mjs
index a7732073550349fd9b5075825a1488b7568c19c6..b43879efbc08ae9e7da5b2bdccfa20fddabd20a0 100644
--- a/dist/strategies/undiciRequest.mjs
+++ b/dist/strategies/undiciRequest.mjs
@@ -2,7 +2,7 @@ var __defProp = Object.defineProperty;
 var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

 // src/strategies/undiciRequest.ts
-import { Buffer as Buffer2 } from "node:buffer";
+import { STATUS_CODES } from "node:http";
 import { URLSearchParams } from "node:url";
 import { types } from "node:util";
 import { request } from "undici";
@@ -28,6 +28,7 @@ async function makeRequest(url, init) {
     },
     headers: new Headers(res.headers),
     status: res.statusCode,
+    statusText: STATUS_CODES[res.statusCode],
     ok: res.statusCode >= 200 && res.statusCode < 300
   };
 }
@@ -51,13 +52,13 @@ async function resolveBody(body) {
     return body;
   } else if (body[Symbol.iterator]) {
     const chunks = [...body];
-    return Buffer2.concat(chunks);
+    return Buffer.concat(chunks);
   } else if (body[Symbol.asyncIterator]) {
     const chunks = [];
     for await (const chunk of body) {
       chunks.push(chunk);
     }
-    return Buffer2.concat(chunks);
+    return Buffer.concat(chunks);
   }
   throw new TypeError(`Unable to resolve body.`);
 }
diff --git a/dist/web.d.mts b/dist/web.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..60c0f675b0aa28bb627a53dd2993a30c90e68d07
--- /dev/null
+++ b/dist/web.d.mts
@@ -0,0 +1,9 @@
+export { DiscordAPIError, DiscordErrorData, HTTPError, OAuthErrorData, RateLimitError, RequestBody, calculateUserDefaultAvatarIndex, makeURLSearchParams, parseResponse, version } from './index.mjs';
+export { t as ALLOWED_EXTENSIONS, v as ALLOWED_SIZES, u as ALLOWED_STICKER_EXTENSIONS, A as APIRequest, B as BaseImageURLOptions, y as BurstHandlerMajorIdKey, C as CDN, r as DefaultRestOptions, D as DefaultUserAgent, q as DefaultUserAgentAppendix, H as HandlerRequestData, i as HashData, w as ImageExtension, x as ImageSize, c as ImageURLOptions, I as InternalRequest, m as InvalidRequestWarningData, M as MakeURLOptions, O as OverwrittenMimeTypes, p as REST, s as RESTEvents, k as RESTOptions, b as RateLimitData, l as RateLimitQueueFilter, a as RawFile, d as RequestData, e as RequestHeaders, j as RequestManager, f as RequestMethod, R as ResponseLike, n as RestEvents, o as RestEventsMap, h as RouteData, g as RouteLike, S as StickerExtension } from './CDN-03f06673.js';
+import 'url';
+import 'discord-api-types/v10';
+import 'undici';
+import 'node:stream';
+import 'node:stream/web';
+import '@discordjs/collection';
+import '@vladfrangu/async_event_emitter';
diff --git a/dist/web.d.ts b/dist/web.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9911324a0027a37bf1698e7418f9f60968b9ca1e
--- /dev/null
+++ b/dist/web.d.ts
@@ -0,0 +1,9 @@
+export { DiscordAPIError, DiscordErrorData, HTTPError, OAuthErrorData, RateLimitError, RequestBody, calculateUserDefaultAvatarIndex, makeURLSearchParams, parseResponse, version } from './index.js';
+export { t as ALLOWED_EXTENSIONS, v as ALLOWED_SIZES, u as ALLOWED_STICKER_EXTENSIONS, A as APIRequest, B as BaseImageURLOptions, y as BurstHandlerMajorIdKey, C as CDN, r as DefaultRestOptions, D as DefaultUserAgent, q as DefaultUserAgentAppendix, H as HandlerRequestData, i as HashData, w as ImageExtension, x as ImageSize, c as ImageURLOptions, I as InternalRequest, m as InvalidRequestWarningData, M as MakeURLOptions, O as OverwrittenMimeTypes, p as REST, s as RESTEvents, k as RESTOptions, b as RateLimitData, l as RateLimitQueueFilter, a as RawFile, d as RequestData, e as RequestHeaders, j as RequestManager, f as RequestMethod, R as ResponseLike, n as RestEvents, o as RestEventsMap, h as RouteData, g as RouteLike, S as StickerExtension } from './CDN-03f06673.js';
+import 'url';
+import 'discord-api-types/v10';
+import 'undici';
+import 'node:stream';
+import 'node:stream/web';
+import '@discordjs/collection';
+import '@vladfrangu/async_event_emitter';
diff --git a/dist/web.js b/dist/web.js
new file mode 100644
index 0000000000000000000000000000000000000000..8b4ce69e59171ac2cb28d5247c94bd0fab2c2e6a
--- /dev/null
+++ b/dist/web.js
@@ -0,0 +1,1407 @@
+"use strict";
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
+var __export = (target, all) => {
+  for (var name in all)
+    __defProp(target, name, { get: all[name], enumerable: true });
+};
+var __copyProps = (to, from, except, desc) => {
+  if (from && typeof from === "object" || typeof from === "function") {
+    for (let key of __getOwnPropNames(from))
+      if (!__hasOwnProp.call(to, key) && key !== except)
+        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  }
+  return to;
+};
+var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+
+// src/web.ts
+var web_exports = {};
+__export(web_exports, {
+  ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
+  ALLOWED_SIZES: () => ALLOWED_SIZES,
+  ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
+  CDN: () => CDN,
+  DefaultRestOptions: () => DefaultRestOptions,
+  DefaultUserAgent: () => DefaultUserAgent,
+  DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
+  DiscordAPIError: () => DiscordAPIError,
+  HTTPError: () => HTTPError,
+  OverwrittenMimeTypes: () => OverwrittenMimeTypes,
+  REST: () => REST,
+  RESTEvents: () => RESTEvents,
+  RateLimitError: () => RateLimitError,
+  RequestManager: () => RequestManager,
+  RequestMethod: () => RequestMethod,
+  calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
+  makeURLSearchParams: () => makeURLSearchParams,
+  parseResponse: () => parseResponse,
+  version: () => version
+});
+module.exports = __toCommonJS(web_exports);
+
+// src/environment.ts
+var defaultStrategy;
+function setDefaultStrategy(newStrategy) {
+  defaultStrategy = newStrategy;
+}
+__name(setDefaultStrategy, "setDefaultStrategy");
+function getDefaultStrategy() {
+  return defaultStrategy;
+}
+__name(getDefaultStrategy, "getDefaultStrategy");
+
+// src/lib/utils/constants.ts
+var import_util = require("@discordjs/util");
+var import_v10 = require("discord-api-types/v10");
+var DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.8.0-dev.1689552764-351a18b.0)`;
+var DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();
+var DefaultRestOptions = {
+  agent: null,
+  api: "https://discord.com/api",
+  authPrefix: "Bot",
+  cdn: "https://cdn.discordapp.com",
+  headers: {},
+  invalidRequestWarningInterval: 0,
+  globalRequestsPerSecond: 50,
+  offset: 50,
+  rejectOnRateLimit: null,
+  retries: 3,
+  timeout: 15e3,
+  userAgentAppendix: DefaultUserAgentAppendix,
+  version: import_v10.APIVersion,
+  hashSweepInterval: 144e5,
+  // 4 Hours
+  hashLifetime: 864e5,
+  // 24 Hours
+  handlerSweepInterval: 36e5,
+  // 1 Hour
+  async makeRequest(...args) {
+    return getDefaultStrategy()(...args);
+  }
+};
+var RESTEvents = /* @__PURE__ */ ((RESTEvents2) => {
+  RESTEvents2["Debug"] = "restDebug";
+  RESTEvents2["HandlerSweep"] = "handlerSweep";
+  RESTEvents2["HashSweep"] = "hashSweep";
+  RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
+  RESTEvents2["RateLimited"] = "rateLimited";
+  RESTEvents2["Response"] = "response";
+  return RESTEvents2;
+})(RESTEvents || {});
+var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
+var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
+var ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
+var OverwrittenMimeTypes = {
+  // https://github.com/discordjs/discord.js/issues/8557
+  "image/apng": "image/png"
+};
+var BurstHandlerMajorIdKey = "burst";
+
+// src/lib/CDN.ts
+var CDN = class {
+  constructor(base = DefaultRestOptions.cdn) {
+    this.base = base;
+  }
+  static {
+    __name(this, "CDN");
+  }
+  /**
+   * Generates an app asset URL for a client's asset.
+   *
+   * @param clientId - The client id that has the asset
+   * @param assetHash - The hash provided by Discord for this asset
+   * @param options - Optional options for the asset
+   */
+  appAsset(clientId, assetHash, options) {
+    return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
+  }
+  /**
+   * Generates an app icon URL for a client's icon.
+   *
+   * @param clientId - The client id that has the icon
+   * @param iconHash - The hash provided by Discord for this icon
+   * @param options - Optional options for the icon
+   */
+  appIcon(clientId, iconHash, options) {
+    return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
+  }
+  /**
+   * Generates an avatar URL, e.g. for a user or a webhook.
+   *
+   * @param id - The id that has the icon
+   * @param avatarHash - The hash provided by Discord for this avatar
+   * @param options - Optional options for the avatar
+   */
+  avatar(id, avatarHash, options) {
+    return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
+  }
+  /**
+   * Generates a user avatar decoration URL.
+   *
+   * @param userId - The id of the user
+   * @param userAvatarDecoration - The hash provided by Discord for this avatar decoration
+   * @param options - Optional options for the avatar decoration
+   */
+  avatarDecoration(userId, userAvatarDecoration, options) {
+    return this.makeURL(`/avatar-decorations/${userId}/${userAvatarDecoration}`, options);
+  }
+  /**
+   * Generates a banner URL, e.g. for a user or a guild.
+   *
+   * @param id - The id that has the banner splash
+   * @param bannerHash - The hash provided by Discord for this banner
+   * @param options - Optional options for the banner
+   */
+  banner(id, bannerHash, options) {
+    return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
+  }
+  /**
+   * Generates an icon URL for a channel, e.g. a group DM.
+   *
+   * @param channelId - The channel id that has the icon
+   * @param iconHash - The hash provided by Discord for this channel
+   * @param options - Optional options for the icon
+   */
+  channelIcon(channelId, iconHash, options) {
+    return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
+  }
+  /**
+   * Generates a default avatar URL
+   *
+   * @param index - The default avatar index
+   * @remarks
+   * To calculate the index for a user do `(userId >> 22) % 6`,
+   * or `discriminator % 5` if they're using the legacy username system.
+   */
+  defaultAvatar(index) {
+    return this.makeURL(`/embed/avatars/${index}`, { extension: "png" });
+  }
+  /**
+   * Generates a discovery splash URL for a guild's discovery splash.
+   *
+   * @param guildId - The guild id that has the discovery splash
+   * @param splashHash - The hash provided by Discord for this splash
+   * @param options - Optional options for the splash
+   */
+  discoverySplash(guildId, splashHash, options) {
+    return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
+  }
+  /**
+   * Generates an emoji's URL for an emoji.
+   *
+   * @param emojiId - The emoji id
+   * @param extension - The extension of the emoji
+   */
+  emoji(emojiId, extension) {
+    return this.makeURL(`/emojis/${emojiId}`, { extension });
+  }
+  /**
+   * Generates a guild member avatar URL.
+   *
+   * @param guildId - The id of the guild
+   * @param userId - The id of the user
+   * @param avatarHash - The hash provided by Discord for this avatar
+   * @param options - Optional options for the avatar
+   */
+  guildMemberAvatar(guildId, userId, avatarHash, options) {
+    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
+  }
+  /**
+   * Generates a guild member banner URL.
+   *
+   * @param guildId - The id of the guild
+   * @param userId - The id of the user
+   * @param bannerHash - The hash provided by Discord for this banner
+   * @param options - Optional options for the banner
+   */
+  guildMemberBanner(guildId, userId, bannerHash, options) {
+    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);
+  }
+  /**
+   * Generates an icon URL, e.g. for a guild.
+   *
+   * @param id - The id that has the icon splash
+   * @param iconHash - The hash provided by Discord for this icon
+   * @param options - Optional options for the icon
+   */
+  icon(id, iconHash, options) {
+    return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
+  }
+  /**
+   * Generates a URL for the icon of a role
+   *
+   * @param roleId - The id of the role that has the icon
+   * @param roleIconHash - The hash provided by Discord for this role icon
+   * @param options - Optional options for the role icon
+   */
+  roleIcon(roleId, roleIconHash, options) {
+    return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
+  }
+  /**
+   * Generates a guild invite splash URL for a guild's invite splash.
+   *
+   * @param guildId - The guild id that has the invite splash
+   * @param splashHash - The hash provided by Discord for this splash
+   * @param options - Optional options for the splash
+   */
+  splash(guildId, splashHash, options) {
+    return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
+  }
+  /**
+   * Generates a sticker URL.
+   *
+   * @param stickerId - The sticker id
+   * @param extension - The extension of the sticker
+   * @privateRemarks
+   * Stickers cannot have a `.webp` extension, so we default to a `.png`
+   */
+  sticker(stickerId, extension = "png") {
+    return this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });
+  }
+  /**
+   * Generates a sticker pack banner URL.
+   *
+   * @param bannerId - The banner id
+   * @param options - Optional options for the banner
+   */
+  stickerPackBanner(bannerId, options) {
+    return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
+  }
+  /**
+   * Generates a team icon URL for a team's icon.
+   *
+   * @param teamId - The team id that has the icon
+   * @param iconHash - The hash provided by Discord for this icon
+   * @param options - Optional options for the icon
+   */
+  teamIcon(teamId, iconHash, options) {
+    return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
+  }
+  /**
+   * Generates a cover image for a guild scheduled event.
+   *
+   * @param scheduledEventId - The scheduled event id
+   * @param coverHash - The hash provided by discord for this cover image
+   * @param options - Optional options for the cover image
+   */
+  guildScheduledEventCover(scheduledEventId, coverHash, options) {
+    return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
+  }
+  /**
+   * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.
+   *
+   * @param route - The base cdn route
+   * @param hash - The hash provided by Discord for this icon
+   * @param options - Optional options for the link
+   */
+  dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
+    return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
+  }
+  /**
+   * Constructs the URL for the resource
+   *
+   * @param route - The base cdn route
+   * @param options - The extension/size options for the link
+   */
+  makeURL(route, { allowedExtensions = ALLOWED_EXTENSIONS, extension = "webp", size } = {}) {
+    extension = String(extension).toLowerCase();
+    if (!allowedExtensions.includes(extension)) {
+      throw new RangeError(`Invalid extension provided: ${extension}
+Must be one of: ${allowedExtensions.join(", ")}`);
+    }
+    if (size && !ALLOWED_SIZES.includes(size)) {
+      throw new RangeError(`Invalid size provided: ${size}
+Must be one of: ${ALLOWED_SIZES.join(", ")}`);
+    }
+    const url = new URL(`${this.base}${route}.${extension}`);
+    if (size) {
+      url.searchParams.set("size", String(size));
+    }
+    return url.toString();
+  }
+};
+
+// src/lib/errors/DiscordAPIError.ts
+function isErrorGroupWrapper(error) {
+  return Reflect.has(error, "_errors");
+}
+__name(isErrorGroupWrapper, "isErrorGroupWrapper");
+function isErrorResponse(error) {
+  return typeof Reflect.get(error, "message") === "string";
+}
+__name(isErrorResponse, "isErrorResponse");
+var DiscordAPIError = class _DiscordAPIError extends Error {
+  /**
+   * @param rawError - The error reported by Discord
+   * @param code - The error code reported by Discord
+   * @param status - The status code of the response
+   * @param method - The method of the request that erred
+   * @param url - The url of the request that erred
+   * @param bodyData - The unparsed data for the request that errored
+   */
+  constructor(rawError, code, status, method, url, bodyData) {
+    super(_DiscordAPIError.getMessage(rawError));
+    this.rawError = rawError;
+    this.code = code;
+    this.status = status;
+    this.method = method;
+    this.url = url;
+    this.requestBody = { files: bodyData.files, json: bodyData.body };
+  }
+  static {
+    __name(this, "DiscordAPIError");
+  }
+  requestBody;
+  /**
+   * The name of the error
+   */
+  get name() {
+    return `${_DiscordAPIError.name}[${this.code}]`;
+  }
+  static getMessage(error) {
+    let flattened = "";
+    if ("code" in error) {
+      if (error.errors) {
+        flattened = [...this.flattenDiscordError(error.errors)].join("\n");
+      }
+      return error.message && flattened ? `${error.message}
+${flattened}` : error.message || flattened || "Unknown Error";
+    }
+    return error.error_description ?? "No Description";
+  }
+  static *flattenDiscordError(obj, key = "") {
+    if (isErrorResponse(obj)) {
+      return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
+    }
+    for (const [otherKey, val] of Object.entries(obj)) {
+      const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
+      if (typeof val === "string") {
+        yield val;
+      } else if (isErrorGroupWrapper(val)) {
+        for (const error of val._errors) {
+          yield* this.flattenDiscordError(error, nextKey);
+        }
+      } else {
+        yield* this.flattenDiscordError(val, nextKey);
+      }
+    }
+  }
+};
+
+// src/lib/errors/HTTPError.ts
+var HTTPError = class _HTTPError extends Error {
+  /**
+   * @param status - The status code of the response
+   * @param statusText - The status text of the response
+   * @param method - The method of the request that erred
+   * @param url - The url of the request that erred
+   * @param bodyData - The unparsed data for the request that errored
+   */
+  constructor(status, statusText, method, url, bodyData) {
+    super(statusText);
+    this.status = status;
+    this.method = method;
+    this.url = url;
+    this.requestBody = { files: bodyData.files, json: bodyData.body };
+  }
+  static {
+    __name(this, "HTTPError");
+  }
+  requestBody;
+  name = _HTTPError.name;
+};
+
+// src/lib/errors/RateLimitError.ts
+var RateLimitError = class _RateLimitError extends Error {
+  static {
+    __name(this, "RateLimitError");
+  }
+  timeToReset;
+  limit;
+  method;
+  hash;
+  url;
+  route;
+  majorParameter;
+  global;
+  constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global }) {
+    super();
+    this.timeToReset = timeToReset;
+    this.limit = limit;
+    this.method = method;
+    this.hash = hash;
+    this.url = url;
+    this.route = route;
+    this.majorParameter = majorParameter;
+    this.global = global;
+  }
+  /**
+   * The name of the error
+   */
+  get name() {
+    return `${_RateLimitError.name}[${this.route}]`;
+  }
+};
+
+// src/lib/RequestManager.ts
+var import_collection = require("@discordjs/collection");
+var import_snowflake = require("@sapphire/snowflake");
+var import_async_event_emitter = require("@vladfrangu/async_event_emitter");
+var import_magic_bytes = require("magic-bytes.js");
+
+// src/lib/utils/utils.ts
+function serializeSearchParam(value) {
+  switch (typeof value) {
+    case "string":
+      return value;
+    case "number":
+    case "bigint":
+    case "boolean":
+      return value.toString();
+    case "object":
+      if (value === null)
+        return null;
+      if (value instanceof Date) {
+        return Number.isNaN(value.getTime()) ? null : value.toISOString();
+      }
+      if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
+        return value.toString();
+      return null;
+    default:
+      return null;
+  }
+}
+__name(serializeSearchParam, "serializeSearchParam");
+function makeURLSearchParams(options) {
+  const params = new URLSearchParams();
+  if (!options)
+    return params;
+  for (const [key, value] of Object.entries(options)) {
+    const serialized = serializeSearchParam(value);
+    if (serialized !== null)
+      params.append(key, serialized);
+  }
+  return params;
+}
+__name(makeURLSearchParams, "makeURLSearchParams");
+async function parseResponse(res) {
+  if (res.headers.get("Content-Type")?.startsWith("application/json")) {
+    return res.json();
+  }
+  return res.arrayBuffer();
+}
+__name(parseResponse, "parseResponse");
+function hasSublimit(bucketRoute, body, method) {
+  if (bucketRoute === "/channels/:id") {
+    if (typeof body !== "object" || body === null)
+      return false;
+    if (method !== "PATCH" /* Patch */)
+      return false;
+    const castedBody = body;
+    return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
+  }
+  return true;
+}
+__name(hasSublimit, "hasSublimit");
+function shouldRetry(error) {
+  if (error.name === "AbortError")
+    return true;
+  return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
+}
+__name(shouldRetry, "shouldRetry");
+async function onRateLimit(manager, rateLimitData) {
+  const { options } = manager;
+  if (!options.rejectOnRateLimit)
+    return;
+  const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
+  if (shouldThrow) {
+    throw new RateLimitError(rateLimitData);
+  }
+}
+__name(onRateLimit, "onRateLimit");
+function calculateUserDefaultAvatarIndex(userId) {
+  return Number(BigInt(userId) >> 22n) % 6;
+}
+__name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
+async function sleep(ms) {
+  return new Promise((resolve) => {
+    setTimeout(() => resolve(), ms);
+  });
+}
+__name(sleep, "sleep");
+function isBufferLike(value) {
+  return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
+}
+__name(isBufferLike, "isBufferLike");
+
+// src/lib/handlers/Shared.ts
+var import_undici = require("undici");
+var invalidCount = 0;
+var invalidCountResetTime = null;
+function incrementInvalidCount(manager) {
+  if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
+    invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
+    invalidCount = 0;
+  }
+  invalidCount++;
+  const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
+  if (emitInvalid) {
+    manager.emit("invalidRequestWarning" /* InvalidRequestWarning */, {
+      count: invalidCount,
+      remainingTime: invalidCountResetTime - Date.now()
+    });
+  }
+}
+__name(incrementInvalidCount, "incrementInvalidCount");
+async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
+  const controller = new AbortController();
+  const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
+  if (requestData.signal) {
+    if (requestData.signal.aborted)
+      controller.abort();
+    else
+      requestData.signal.addEventListener("abort", () => controller.abort());
+  }
+  let res;
+  try {
+    res = await manager.options.makeRequest(url, { ...options, signal: controller.signal });
+  } catch (error) {
+    if (!(error instanceof Error))
+      throw error;
+    if (shouldRetry(error) && retries !== manager.options.retries) {
+      return null;
+    }
+    throw error;
+  } finally {
+    clearTimeout(timeout);
+  }
+  if (manager.listenerCount("response" /* Response */)) {
+    manager.emit(
+      "response" /* Response */,
+      {
+        method: options.method ?? "GET" /* Get */,
+        path: routeId.original,
+        route: routeId.bucketRoute,
+        options,
+        data: requestData,
+        retries
+      },
+      res instanceof import_undici.Response ? res.clone() : { ...res }
+    );
+  }
+  return res;
+}
+__name(makeNetworkRequest, "makeNetworkRequest");
+async function handleErrors(manager, res, method, url, requestData, retries) {
+  const status = res.status;
+  if (status >= 500 && status < 600) {
+    if (retries !== manager.options.retries) {
+      return null;
+    }
+    throw new HTTPError(status, res.statusText, method, url, requestData);
+  } else {
+    if (status >= 400 && status < 500) {
+      if (status === 401 && requestData.auth) {
+        manager.setToken(null);
+      }
+      const data = await parseResponse(res);
+      throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
+    }
+    return res;
+  }
+}
+__name(handleErrors, "handleErrors");
+
+// src/lib/handlers/BurstHandler.ts
+var BurstHandler = class {
+  /**
+   * @param manager - The request manager
+   * @param hash - The hash that this RequestHandler handles
+   * @param majorParameter - The major parameter for this handler
+   */
+  constructor(manager, hash, majorParameter) {
+    this.manager = manager;
+    this.hash = hash;
+    this.majorParameter = majorParameter;
+    this.id = `${hash}:${majorParameter}`;
+  }
+  static {
+    __name(this, "BurstHandler");
+  }
+  /**
+   * {@inheritdoc IHandler.id}
+   */
+  id;
+  /**
+   * {@inheritDoc IHandler.inactive}
+   */
+  inactive = false;
+  /**
+   * Emits a debug message
+   *
+   * @param message - The message to debug
+   */
+  debug(message) {
+    this.manager.emit("restDebug" /* Debug */, `[REST ${this.id}] ${message}`);
+  }
+  /**
+   * {@inheritDoc IHandler.queueRequest}
+   */
+  async queueRequest(routeId, url, options, requestData) {
+    return this.runRequest(routeId, url, options, requestData);
+  }
+  /**
+   * The method that actually makes the request to the API, and updates info about the bucket accordingly
+   *
+   * @param routeId - The generalized API route with literal ids for major parameters
+   * @param url - The fully resolved URL to make the request to
+   * @param options - The fetch options needed to make the request
+   * @param requestData - Extra data from the user's request needed for errors and additional processing
+   * @param retries - The number of retries this request has already attempted (recursion)
+   */
+  async runRequest(routeId, url, options, requestData, retries = 0) {
+    const method = options.method ?? "GET" /* Get */;
+    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
+    if (res === null) {
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
+    }
+    const status = res.status;
+    let retryAfter = 0;
+    const retry = res.headers.get("Retry-After");
+    if (retry)
+      retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
+    if (status === 401 || status === 403 || status === 429) {
+      incrementInvalidCount(this.manager);
+    }
+    if (status >= 200 && status < 300) {
+      return res;
+    } else if (status === 429) {
+      const isGlobal = res.headers.has("X-RateLimit-Global");
+      await onRateLimit(this.manager, {
+        timeToReset: retryAfter,
+        limit: Number.POSITIVE_INFINITY,
+        method,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      });
+      this.debug(
+        [
+          "Encountered unexpected 429 rate limit",
+          `  Global         : ${isGlobal}`,
+          `  Method         : ${method}`,
+          `  URL            : ${url}`,
+          `  Bucket         : ${routeId.bucketRoute}`,
+          `  Major parameter: ${routeId.majorParameter}`,
+          `  Hash           : ${this.hash}`,
+          `  Limit          : ${Number.POSITIVE_INFINITY}`,
+          `  Retry After    : ${retryAfter}ms`,
+          `  Sublimit       : None`
+        ].join("\n")
+      );
+      await sleep(retryAfter);
+      return this.runRequest(routeId, url, options, requestData, retries);
+    } else {
+      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
+      if (handled === null) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      return handled;
+    }
+  }
+};
+
+// src/lib/handlers/SequentialHandler.ts
+var import_async_queue = require("@sapphire/async-queue");
+var SequentialHandler = class {
+  /**
+   * @param manager - The request manager
+   * @param hash - The hash that this RequestHandler handles
+   * @param majorParameter - The major parameter for this handler
+   */
+  constructor(manager, hash, majorParameter) {
+    this.manager = manager;
+    this.hash = hash;
+    this.majorParameter = majorParameter;
+    this.id = `${hash}:${majorParameter}`;
+  }
+  static {
+    __name(this, "SequentialHandler");
+  }
+  /**
+   * {@inheritDoc IHandler.id}
+   */
+  id;
+  /**
+   * The time this rate limit bucket will reset
+   */
+  reset = -1;
+  /**
+   * The remaining requests that can be made before we are rate limited
+   */
+  remaining = 1;
+  /**
+   * The total number of requests that can be made before we are rate limited
+   */
+  limit = Number.POSITIVE_INFINITY;
+  /**
+   * The interface used to sequence async requests sequentially
+   */
+  #asyncQueue = new import_async_queue.AsyncQueue();
+  /**
+   * The interface used to sequence sublimited async requests sequentially
+   */
+  #sublimitedQueue = null;
+  /**
+   * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed
+   */
+  #sublimitPromise = null;
+  /**
+   * Whether the sublimit queue needs to be shifted in the finally block
+   */
+  #shiftSublimit = false;
+  /**
+   * {@inheritDoc IHandler.inactive}
+   */
+  get inactive() {
+    return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
+  }
+  /**
+   * If the rate limit bucket is currently limited by the global limit
+   */
+  get globalLimited() {
+    return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
+  }
+  /**
+   * If the rate limit bucket is currently limited by its limit
+   */
+  get localLimited() {
+    return this.remaining <= 0 && Date.now() < this.reset;
+  }
+  /**
+   * If the rate limit bucket is currently limited
+   */
+  get limited() {
+    return this.globalLimited || this.localLimited;
+  }
+  /**
+   * The time until queued requests can continue
+   */
+  get timeToReset() {
+    return this.reset + this.manager.options.offset - Date.now();
+  }
+  /**
+   * Emits a debug message
+   *
+   * @param message - The message to debug
+   */
+  debug(message) {
+    this.manager.emit("restDebug" /* Debug */, `[REST ${this.id}] ${message}`);
+  }
+  /**
+   * Delay all requests for the specified amount of time, handling global rate limits
+   *
+   * @param time - The amount of time to delay all requests for
+   */
+  async globalDelayFor(time) {
+    await sleep(time);
+    this.manager.globalDelay = null;
+  }
+  /**
+   * {@inheritDoc IHandler.queueRequest}
+   */
+  async queueRequest(routeId, url, options, requestData) {
+    let queue = this.#asyncQueue;
+    let queueType = 0 /* Standard */;
+    if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
+      queue = this.#sublimitedQueue;
+      queueType = 1 /* Sublimit */;
+    }
+    await queue.wait({ signal: requestData.signal });
+    if (queueType === 0 /* Standard */) {
+      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
+        queue = this.#sublimitedQueue;
+        const wait = queue.wait();
+        this.#asyncQueue.shift();
+        await wait;
+      } else if (this.#sublimitPromise) {
+        await this.#sublimitPromise.promise;
+      }
+    }
+    try {
+      return await this.runRequest(routeId, url, options, requestData);
+    } finally {
+      queue.shift();
+      if (this.#shiftSublimit) {
+        this.#shiftSublimit = false;
+        this.#sublimitedQueue?.shift();
+      }
+      if (this.#sublimitedQueue?.remaining === 0) {
+        this.#sublimitPromise?.resolve();
+        this.#sublimitedQueue = null;
+      }
+    }
+  }
+  /**
+   * The method that actually makes the request to the api, and updates info about the bucket accordingly
+   *
+   * @param routeId - The generalized api route with literal ids for major parameters
+   * @param url - The fully resolved url to make the request to
+   * @param options - The fetch options needed to make the request
+   * @param requestData - Extra data from the user's request needed for errors and additional processing
+   * @param retries - The number of retries this request has already attempted (recursion)
+   */
+  async runRequest(routeId, url, options, requestData, retries = 0) {
+    while (this.limited) {
+      const isGlobal = this.globalLimited;
+      let limit2;
+      let timeout;
+      let delay;
+      if (isGlobal) {
+        limit2 = this.manager.options.globalRequestsPerSecond;
+        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
+        if (!this.manager.globalDelay) {
+          this.manager.globalDelay = this.globalDelayFor(timeout);
+        }
+        delay = this.manager.globalDelay;
+      } else {
+        limit2 = this.limit;
+        timeout = this.timeToReset;
+        delay = sleep(timeout);
+      }
+      const rateLimitData = {
+        timeToReset: timeout,
+        limit: limit2,
+        method: options.method ?? "GET" /* Get */,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      };
+      this.manager.emit("rateLimited" /* RateLimited */, rateLimitData);
+      await onRateLimit(this.manager, rateLimitData);
+      if (isGlobal) {
+        this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
+      } else {
+        this.debug(`Waiting ${timeout}ms for rate limit to pass`);
+      }
+      await delay;
+    }
+    if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
+      this.manager.globalReset = Date.now() + 1e3;
+      this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
+    }
+    this.manager.globalRemaining--;
+    const method = options.method ?? "GET" /* Get */;
+    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
+    if (res === null) {
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
+    }
+    const status = res.status;
+    let retryAfter = 0;
+    const limit = res.headers.get("X-RateLimit-Limit");
+    const remaining = res.headers.get("X-RateLimit-Remaining");
+    const reset = res.headers.get("X-RateLimit-Reset-After");
+    const hash = res.headers.get("X-RateLimit-Bucket");
+    const retry = res.headers.get("Retry-After");
+    this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
+    this.remaining = remaining ? Number(remaining) : 1;
+    this.reset = reset ? Number(reset) * 1e3 + Date.now() + this.manager.options.offset : Date.now();
+    if (retry)
+      retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
+    if (hash && hash !== this.hash) {
+      this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join("\n"));
+      this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
+    } else if (hash) {
+      const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
+      if (hashData) {
+        hashData.lastAccess = Date.now();
+      }
+    }
+    let sublimitTimeout = null;
+    if (retryAfter > 0) {
+      if (res.headers.has("X-RateLimit-Global")) {
+        this.manager.globalRemaining = 0;
+        this.manager.globalReset = Date.now() + retryAfter;
+      } else if (!this.localLimited) {
+        sublimitTimeout = retryAfter;
+      }
+    }
+    if (status === 401 || status === 403 || status === 429) {
+      incrementInvalidCount(this.manager);
+    }
+    if (res.ok) {
+      return res;
+    } else if (status === 429) {
+      const isGlobal = this.globalLimited;
+      let limit2;
+      let timeout;
+      if (isGlobal) {
+        limit2 = this.manager.options.globalRequestsPerSecond;
+        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
+      } else {
+        limit2 = this.limit;
+        timeout = this.timeToReset;
+      }
+      await onRateLimit(this.manager, {
+        timeToReset: timeout,
+        limit: limit2,
+        method,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      });
+      this.debug(
+        [
+          "Encountered unexpected 429 rate limit",
+          `  Global         : ${isGlobal.toString()}`,
+          `  Method         : ${method}`,
+          `  URL            : ${url}`,
+          `  Bucket         : ${routeId.bucketRoute}`,
+          `  Major parameter: ${routeId.majorParameter}`,
+          `  Hash           : ${this.hash}`,
+          `  Limit          : ${limit2}`,
+          `  Retry After    : ${retryAfter}ms`,
+          `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`
+        ].join("\n")
+      );
+      if (sublimitTimeout) {
+        const firstSublimit = !this.#sublimitedQueue;
+        if (firstSublimit) {
+          this.#sublimitedQueue = new import_async_queue.AsyncQueue();
+          void this.#sublimitedQueue.wait();
+          this.#asyncQueue.shift();
+        }
+        this.#sublimitPromise?.resolve();
+        this.#sublimitPromise = null;
+        await sleep(sublimitTimeout);
+        let resolve;
+        const promise = new Promise((res2) => resolve = res2);
+        this.#sublimitPromise = { promise, resolve };
+        if (firstSublimit) {
+          await this.#asyncQueue.wait();
+          this.#shiftSublimit = true;
+        }
+      }
+      return this.runRequest(routeId, url, options, requestData, retries);
+    } else {
+      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
+      if (handled === null) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      return handled;
+    }
+  }
+};
+
+// src/lib/RequestManager.ts
+var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
+  RequestMethod2["Delete"] = "DELETE";
+  RequestMethod2["Get"] = "GET";
+  RequestMethod2["Patch"] = "PATCH";
+  RequestMethod2["Post"] = "POST";
+  RequestMethod2["Put"] = "PUT";
+  return RequestMethod2;
+})(RequestMethod || {});
+var RequestManager = class _RequestManager extends import_async_event_emitter.AsyncEventEmitter {
+  static {
+    __name(this, "RequestManager");
+  }
+  /**
+   * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
+   * performed by this manager.
+   */
+  agent = null;
+  /**
+   * The number of requests remaining in the global bucket
+   */
+  globalRemaining;
+  /**
+   * The promise used to wait out the global rate limit
+   */
+  globalDelay = null;
+  /**
+   * The timestamp at which the global bucket resets
+   */
+  globalReset = -1;
+  /**
+   * API bucket hashes that are cached from provided routes
+   */
+  hashes = new import_collection.Collection();
+  /**
+   * Request handlers created from the bucket hash and the major parameters
+   */
+  handlers = new import_collection.Collection();
+  #token = null;
+  hashTimer;
+  handlerTimer;
+  options;
+  constructor(options) {
+    super();
+    this.options = { ...DefaultRestOptions, ...options };
+    this.options.offset = Math.max(0, this.options.offset);
+    this.globalRemaining = this.options.globalRequestsPerSecond;
+    this.agent = options.agent ?? null;
+    this.setupSweepers();
+  }
+  setupSweepers() {
+    const validateMaxInterval = /* @__PURE__ */ __name((interval) => {
+      if (interval > 144e5) {
+        throw new Error("Cannot set an interval greater than 4 hours");
+      }
+    }, "validateMaxInterval");
+    if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
+      validateMaxInterval(this.options.hashSweepInterval);
+      this.hashTimer = setInterval(() => {
+        const sweptHashes = new import_collection.Collection();
+        const currentDate = Date.now();
+        this.hashes.sweep((val, key) => {
+          if (val.lastAccess === -1)
+            return false;
+          const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
+          if (shouldSweep) {
+            sweptHashes.set(key, val);
+          }
+          this.emit("restDebug" /* Debug */, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
+          return shouldSweep;
+        });
+        this.emit("hashSweep" /* HashSweep */, sweptHashes);
+      }, this.options.hashSweepInterval);
+    }
+    if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
+      validateMaxInterval(this.options.handlerSweepInterval);
+      this.handlerTimer = setInterval(() => {
+        const sweptHandlers = new import_collection.Collection();
+        this.handlers.sweep((val, key) => {
+          const { inactive } = val;
+          if (inactive) {
+            sweptHandlers.set(key, val);
+          }
+          this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
+          return inactive;
+        });
+        this.emit("handlerSweep" /* HandlerSweep */, sweptHandlers);
+      }, this.options.handlerSweepInterval);
+    }
+  }
+  /**
+   * Sets the default agent to use for requests performed by this manager
+   *
+   * @param agent - The agent to use
+   */
+  setAgent(agent) {
+    this.agent = agent;
+    return this;
+  }
+  /**
+   * Sets the authorization token that should be used for requests
+   *
+   * @param token - The authorization token to use
+   */
+  setToken(token) {
+    this.#token = token;
+    return this;
+  }
+  /**
+   * Queues a request to be sent
+   *
+   * @param request - All the information needed to make a request
+   * @returns The response from the api request
+   */
+  async queueRequest(request) {
+    const routeId = _RequestManager.generateRouteData(request.fullRoute, request.method);
+    const hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {
+      value: `Global(${request.method}:${routeId.bucketRoute})`,
+      lastAccess: -1
+    };
+    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
+    const { url, fetchOptions } = await this.resolveRequest(request);
+    return handler.queueRequest(routeId, url, fetchOptions, {
+      body: request.body,
+      files: request.files,
+      auth: request.auth !== false,
+      signal: request.signal
+    });
+  }
+  /**
+   * Creates a new rate limit handler from a hash, based on the hash and the major parameter
+   *
+   * @param hash - The hash for the route
+   * @param majorParameter - The major parameter for this handler
+   * @internal
+   */
+  createHandler(hash, majorParameter) {
+    const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
+    this.handlers.set(queue.id, queue);
+    return queue;
+  }
+  /**
+   * Formats the request data to a usable format for fetch
+   *
+   * @param request - The request data
+   */
+  async resolveRequest(request) {
+    const { options } = this;
+    let query = "";
+    if (request.query) {
+      const resolvedQuery = request.query.toString();
+      if (resolvedQuery !== "") {
+        query = `?${resolvedQuery}`;
+      }
+    }
+    const headers = {
+      ...this.options.headers,
+      "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
+    };
+    if (request.auth !== false) {
+      if (!this.#token) {
+        throw new Error("Expected token to be set for this request, but none was present");
+      }
+      headers.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${this.#token}`;
+    }
+    if (request.reason?.length) {
+      headers["X-Audit-Log-Reason"] = encodeURIComponent(request.reason);
+    }
+    const url = `${options.api}${request.versioned === false ? "" : `/v${options.version}`}${request.fullRoute}${query}`;
+    let finalBody;
+    let additionalHeaders = {};
+    if (request.files?.length) {
+      const formData = new FormData();
+      for (const [index, file] of request.files.entries()) {
+        const fileKey = file.key ?? `files[${index}]`;
+        if (isBufferLike(file.data)) {
+          let contentType = file.contentType;
+          if (!contentType) {
+            const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);
+            if (parsedType) {
+              contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
+            }
+          }
+          formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
+        } else {
+          formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
+        }
+      }
+      if (request.body != null) {
+        if (request.appendToFormData) {
+          for (const [key, value] of Object.entries(request.body)) {
+            formData.append(key, value);
+          }
+        } else {
+          formData.append("payload_json", JSON.stringify(request.body));
+        }
+      }
+      finalBody = formData;
+    } else if (request.body != null) {
+      if (request.passThroughBody) {
+        finalBody = request.body;
+      } else {
+        finalBody = JSON.stringify(request.body);
+        additionalHeaders = { "Content-Type": "application/json" };
+      }
+    }
+    const method = request.method.toUpperCase();
+    const fetchOptions = {
+      // Set body to null on get / head requests. This does not follow fetch spec (likely because it causes subtle bugs) but is aligned with what request was doing
+      body: ["GET", "HEAD"].includes(method) ? null : finalBody,
+      headers: { ...request.headers, ...additionalHeaders, ...headers },
+      method,
+      // Prioritize setting an agent per request, use the agent for this instance otherwise.
+      dispatcher: request.dispatcher ?? this.agent ?? void 0
+    };
+    return { url, fetchOptions };
+  }
+  /**
+   * Stops the hash sweeping interval
+   */
+  clearHashSweeper() {
+    clearInterval(this.hashTimer);
+  }
+  /**
+   * Stops the request handler sweeping interval
+   */
+  clearHandlerSweeper() {
+    clearInterval(this.handlerTimer);
+  }
+  /**
+   * Generates route data for an endpoint:method
+   *
+   * @param endpoint - The raw endpoint to generalize
+   * @param method - The HTTP method this endpoint is called without
+   * @internal
+   */
+  static generateRouteData(endpoint, method) {
+    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
+      return {
+        majorParameter: BurstHandlerMajorIdKey,
+        bucketRoute: "/interactions/:id/:token/callback",
+        original: endpoint
+      };
+    }
+    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
+    const majorId = majorIdMatch?.[1] ?? "global";
+    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
+    let exceptions = "";
+    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
+      const id = /\d{17,19}$/.exec(endpoint)[0];
+      const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
+      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
+        exceptions += "/Delete Old Message";
+      }
+    }
+    return {
+      majorParameter: majorId,
+      bucketRoute: baseRoute + exceptions,
+      original: endpoint
+    };
+  }
+};
+
+// src/lib/REST.ts
+var import_async_event_emitter2 = require("@vladfrangu/async_event_emitter");
+var REST = class extends import_async_event_emitter2.AsyncEventEmitter {
+  static {
+    __name(this, "REST");
+  }
+  cdn;
+  requestManager;
+  constructor(options = {}) {
+    super();
+    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
+    this.requestManager = new RequestManager(options).on("restDebug" /* Debug */, this.emit.bind(this, "restDebug" /* Debug */)).on("rateLimited" /* RateLimited */, this.emit.bind(this, "rateLimited" /* RateLimited */)).on("invalidRequestWarning" /* InvalidRequestWarning */, this.emit.bind(this, "invalidRequestWarning" /* InvalidRequestWarning */)).on("hashSweep" /* HashSweep */, this.emit.bind(this, "hashSweep" /* HashSweep */));
+    this.on("newListener", (name, listener) => {
+      if (name === "response" /* Response */)
+        this.requestManager.on(name, listener);
+    });
+    this.on("removeListener", (name, listener) => {
+      if (name === "response" /* Response */)
+        this.requestManager.off(name, listener);
+    });
+  }
+  /**
+   * Gets the agent set for this instance
+   */
+  getAgent() {
+    return this.requestManager.agent;
+  }
+  /**
+   * Sets the default agent to use for requests performed by this instance
+   *
+   * @param agent - Sets the agent to use
+   */
+  setAgent(agent) {
+    this.requestManager.setAgent(agent);
+    return this;
+  }
+  /**
+   * Sets the authorization token that should be used for requests
+   *
+   * @param token - The authorization token to use
+   */
+  setToken(token) {
+    this.requestManager.setToken(token);
+    return this;
+  }
+  /**
+   * Runs a get request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async get(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "GET" /* Get */ });
+  }
+  /**
+   * Runs a delete request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async delete(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "DELETE" /* Delete */ });
+  }
+  /**
+   * Runs a post request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async post(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "POST" /* Post */ });
+  }
+  /**
+   * Runs a put request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async put(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "PUT" /* Put */ });
+  }
+  /**
+   * Runs a patch request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async patch(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "PATCH" /* Patch */ });
+  }
+  /**
+   * Runs a request from the api
+   *
+   * @param options - Request options
+   */
+  async request(options) {
+    const response = await this.raw(options);
+    return parseResponse(response);
+  }
+  /**
+   * Runs a request from the API, yielding the raw Response object
+   *
+   * @param options - Request options
+   */
+  async raw(options) {
+    return this.requestManager.queueRequest(options);
+  }
+};
+
+// src/shared.ts
+var version = "1.8.0-dev.1689552764-351a18b.0";
+
+// src/web.ts
+setDefaultStrategy(fetch);
+// Annotate the CommonJS export names for ESM import in node:
+0 && (module.exports = {
+  ALLOWED_EXTENSIONS,
+  ALLOWED_SIZES,
+  ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey,
+  CDN,
+  DefaultRestOptions,
+  DefaultUserAgent,
+  DefaultUserAgentAppendix,
+  DiscordAPIError,
+  HTTPError,
+  OverwrittenMimeTypes,
+  REST,
+  RESTEvents,
+  RateLimitError,
+  RequestManager,
+  RequestMethod,
+  calculateUserDefaultAvatarIndex,
+  makeURLSearchParams,
+  parseResponse,
+  version
+});
+//# sourceMappingURL=web.js.map
\ No newline at end of file
diff --git a/dist/web.mjs b/dist/web.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..478920326d7f51bafb8edcf9854f931c3022082b
--- /dev/null
+++ b/dist/web.mjs
@@ -0,0 +1,1363 @@
+var __defProp = Object.defineProperty;
+var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
+
+// src/environment.ts
+var defaultStrategy;
+function setDefaultStrategy(newStrategy) {
+  defaultStrategy = newStrategy;
+}
+__name(setDefaultStrategy, "setDefaultStrategy");
+function getDefaultStrategy() {
+  return defaultStrategy;
+}
+__name(getDefaultStrategy, "getDefaultStrategy");
+
+// src/lib/utils/constants.ts
+import { getUserAgentAppendix } from "@discordjs/util";
+import { APIVersion } from "discord-api-types/v10";
+var DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.8.0-dev.1689552764-351a18b.0)`;
+var DefaultUserAgentAppendix = getUserAgentAppendix();
+var DefaultRestOptions = {
+  agent: null,
+  api: "https://discord.com/api",
+  authPrefix: "Bot",
+  cdn: "https://cdn.discordapp.com",
+  headers: {},
+  invalidRequestWarningInterval: 0,
+  globalRequestsPerSecond: 50,
+  offset: 50,
+  rejectOnRateLimit: null,
+  retries: 3,
+  timeout: 15e3,
+  userAgentAppendix: DefaultUserAgentAppendix,
+  version: APIVersion,
+  hashSweepInterval: 144e5,
+  // 4 Hours
+  hashLifetime: 864e5,
+  // 24 Hours
+  handlerSweepInterval: 36e5,
+  // 1 Hour
+  async makeRequest(...args) {
+    return getDefaultStrategy()(...args);
+  }
+};
+var RESTEvents = /* @__PURE__ */ ((RESTEvents2) => {
+  RESTEvents2["Debug"] = "restDebug";
+  RESTEvents2["HandlerSweep"] = "handlerSweep";
+  RESTEvents2["HashSweep"] = "hashSweep";
+  RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
+  RESTEvents2["RateLimited"] = "rateLimited";
+  RESTEvents2["Response"] = "response";
+  return RESTEvents2;
+})(RESTEvents || {});
+var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
+var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
+var ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
+var OverwrittenMimeTypes = {
+  // https://github.com/discordjs/discord.js/issues/8557
+  "image/apng": "image/png"
+};
+var BurstHandlerMajorIdKey = "burst";
+
+// src/lib/CDN.ts
+var CDN = class {
+  constructor(base = DefaultRestOptions.cdn) {
+    this.base = base;
+  }
+  static {
+    __name(this, "CDN");
+  }
+  /**
+   * Generates an app asset URL for a client's asset.
+   *
+   * @param clientId - The client id that has the asset
+   * @param assetHash - The hash provided by Discord for this asset
+   * @param options - Optional options for the asset
+   */
+  appAsset(clientId, assetHash, options) {
+    return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
+  }
+  /**
+   * Generates an app icon URL for a client's icon.
+   *
+   * @param clientId - The client id that has the icon
+   * @param iconHash - The hash provided by Discord for this icon
+   * @param options - Optional options for the icon
+   */
+  appIcon(clientId, iconHash, options) {
+    return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
+  }
+  /**
+   * Generates an avatar URL, e.g. for a user or a webhook.
+   *
+   * @param id - The id that has the icon
+   * @param avatarHash - The hash provided by Discord for this avatar
+   * @param options - Optional options for the avatar
+   */
+  avatar(id, avatarHash, options) {
+    return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
+  }
+  /**
+   * Generates a user avatar decoration URL.
+   *
+   * @param userId - The id of the user
+   * @param userAvatarDecoration - The hash provided by Discord for this avatar decoration
+   * @param options - Optional options for the avatar decoration
+   */
+  avatarDecoration(userId, userAvatarDecoration, options) {
+    return this.makeURL(`/avatar-decorations/${userId}/${userAvatarDecoration}`, options);
+  }
+  /**
+   * Generates a banner URL, e.g. for a user or a guild.
+   *
+   * @param id - The id that has the banner splash
+   * @param bannerHash - The hash provided by Discord for this banner
+   * @param options - Optional options for the banner
+   */
+  banner(id, bannerHash, options) {
+    return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
+  }
+  /**
+   * Generates an icon URL for a channel, e.g. a group DM.
+   *
+   * @param channelId - The channel id that has the icon
+   * @param iconHash - The hash provided by Discord for this channel
+   * @param options - Optional options for the icon
+   */
+  channelIcon(channelId, iconHash, options) {
+    return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
+  }
+  /**
+   * Generates a default avatar URL
+   *
+   * @param index - The default avatar index
+   * @remarks
+   * To calculate the index for a user do `(userId >> 22) % 6`,
+   * or `discriminator % 5` if they're using the legacy username system.
+   */
+  defaultAvatar(index) {
+    return this.makeURL(`/embed/avatars/${index}`, { extension: "png" });
+  }
+  /**
+   * Generates a discovery splash URL for a guild's discovery splash.
+   *
+   * @param guildId - The guild id that has the discovery splash
+   * @param splashHash - The hash provided by Discord for this splash
+   * @param options - Optional options for the splash
+   */
+  discoverySplash(guildId, splashHash, options) {
+    return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
+  }
+  /**
+   * Generates an emoji's URL for an emoji.
+   *
+   * @param emojiId - The emoji id
+   * @param extension - The extension of the emoji
+   */
+  emoji(emojiId, extension) {
+    return this.makeURL(`/emojis/${emojiId}`, { extension });
+  }
+  /**
+   * Generates a guild member avatar URL.
+   *
+   * @param guildId - The id of the guild
+   * @param userId - The id of the user
+   * @param avatarHash - The hash provided by Discord for this avatar
+   * @param options - Optional options for the avatar
+   */
+  guildMemberAvatar(guildId, userId, avatarHash, options) {
+    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
+  }
+  /**
+   * Generates a guild member banner URL.
+   *
+   * @param guildId - The id of the guild
+   * @param userId - The id of the user
+   * @param bannerHash - The hash provided by Discord for this banner
+   * @param options - Optional options for the banner
+   */
+  guildMemberBanner(guildId, userId, bannerHash, options) {
+    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);
+  }
+  /**
+   * Generates an icon URL, e.g. for a guild.
+   *
+   * @param id - The id that has the icon splash
+   * @param iconHash - The hash provided by Discord for this icon
+   * @param options - Optional options for the icon
+   */
+  icon(id, iconHash, options) {
+    return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
+  }
+  /**
+   * Generates a URL for the icon of a role
+   *
+   * @param roleId - The id of the role that has the icon
+   * @param roleIconHash - The hash provided by Discord for this role icon
+   * @param options - Optional options for the role icon
+   */
+  roleIcon(roleId, roleIconHash, options) {
+    return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
+  }
+  /**
+   * Generates a guild invite splash URL for a guild's invite splash.
+   *
+   * @param guildId - The guild id that has the invite splash
+   * @param splashHash - The hash provided by Discord for this splash
+   * @param options - Optional options for the splash
+   */
+  splash(guildId, splashHash, options) {
+    return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
+  }
+  /**
+   * Generates a sticker URL.
+   *
+   * @param stickerId - The sticker id
+   * @param extension - The extension of the sticker
+   * @privateRemarks
+   * Stickers cannot have a `.webp` extension, so we default to a `.png`
+   */
+  sticker(stickerId, extension = "png") {
+    return this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });
+  }
+  /**
+   * Generates a sticker pack banner URL.
+   *
+   * @param bannerId - The banner id
+   * @param options - Optional options for the banner
+   */
+  stickerPackBanner(bannerId, options) {
+    return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
+  }
+  /**
+   * Generates a team icon URL for a team's icon.
+   *
+   * @param teamId - The team id that has the icon
+   * @param iconHash - The hash provided by Discord for this icon
+   * @param options - Optional options for the icon
+   */
+  teamIcon(teamId, iconHash, options) {
+    return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
+  }
+  /**
+   * Generates a cover image for a guild scheduled event.
+   *
+   * @param scheduledEventId - The scheduled event id
+   * @param coverHash - The hash provided by discord for this cover image
+   * @param options - Optional options for the cover image
+   */
+  guildScheduledEventCover(scheduledEventId, coverHash, options) {
+    return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
+  }
+  /**
+   * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.
+   *
+   * @param route - The base cdn route
+   * @param hash - The hash provided by Discord for this icon
+   * @param options - Optional options for the link
+   */
+  dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
+    return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
+  }
+  /**
+   * Constructs the URL for the resource
+   *
+   * @param route - The base cdn route
+   * @param options - The extension/size options for the link
+   */
+  makeURL(route, { allowedExtensions = ALLOWED_EXTENSIONS, extension = "webp", size } = {}) {
+    extension = String(extension).toLowerCase();
+    if (!allowedExtensions.includes(extension)) {
+      throw new RangeError(`Invalid extension provided: ${extension}
+Must be one of: ${allowedExtensions.join(", ")}`);
+    }
+    if (size && !ALLOWED_SIZES.includes(size)) {
+      throw new RangeError(`Invalid size provided: ${size}
+Must be one of: ${ALLOWED_SIZES.join(", ")}`);
+    }
+    const url = new URL(`${this.base}${route}.${extension}`);
+    if (size) {
+      url.searchParams.set("size", String(size));
+    }
+    return url.toString();
+  }
+};
+
+// src/lib/errors/DiscordAPIError.ts
+function isErrorGroupWrapper(error) {
+  return Reflect.has(error, "_errors");
+}
+__name(isErrorGroupWrapper, "isErrorGroupWrapper");
+function isErrorResponse(error) {
+  return typeof Reflect.get(error, "message") === "string";
+}
+__name(isErrorResponse, "isErrorResponse");
+var DiscordAPIError = class _DiscordAPIError extends Error {
+  /**
+   * @param rawError - The error reported by Discord
+   * @param code - The error code reported by Discord
+   * @param status - The status code of the response
+   * @param method - The method of the request that erred
+   * @param url - The url of the request that erred
+   * @param bodyData - The unparsed data for the request that errored
+   */
+  constructor(rawError, code, status, method, url, bodyData) {
+    super(_DiscordAPIError.getMessage(rawError));
+    this.rawError = rawError;
+    this.code = code;
+    this.status = status;
+    this.method = method;
+    this.url = url;
+    this.requestBody = { files: bodyData.files, json: bodyData.body };
+  }
+  static {
+    __name(this, "DiscordAPIError");
+  }
+  requestBody;
+  /**
+   * The name of the error
+   */
+  get name() {
+    return `${_DiscordAPIError.name}[${this.code}]`;
+  }
+  static getMessage(error) {
+    let flattened = "";
+    if ("code" in error) {
+      if (error.errors) {
+        flattened = [...this.flattenDiscordError(error.errors)].join("\n");
+      }
+      return error.message && flattened ? `${error.message}
+${flattened}` : error.message || flattened || "Unknown Error";
+    }
+    return error.error_description ?? "No Description";
+  }
+  static *flattenDiscordError(obj, key = "") {
+    if (isErrorResponse(obj)) {
+      return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
+    }
+    for (const [otherKey, val] of Object.entries(obj)) {
+      const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
+      if (typeof val === "string") {
+        yield val;
+      } else if (isErrorGroupWrapper(val)) {
+        for (const error of val._errors) {
+          yield* this.flattenDiscordError(error, nextKey);
+        }
+      } else {
+        yield* this.flattenDiscordError(val, nextKey);
+      }
+    }
+  }
+};
+
+// src/lib/errors/HTTPError.ts
+var HTTPError = class _HTTPError extends Error {
+  /**
+   * @param status - The status code of the response
+   * @param statusText - The status text of the response
+   * @param method - The method of the request that erred
+   * @param url - The url of the request that erred
+   * @param bodyData - The unparsed data for the request that errored
+   */
+  constructor(status, statusText, method, url, bodyData) {
+    super(statusText);
+    this.status = status;
+    this.method = method;
+    this.url = url;
+    this.requestBody = { files: bodyData.files, json: bodyData.body };
+  }
+  static {
+    __name(this, "HTTPError");
+  }
+  requestBody;
+  name = _HTTPError.name;
+};
+
+// src/lib/errors/RateLimitError.ts
+var RateLimitError = class _RateLimitError extends Error {
+  static {
+    __name(this, "RateLimitError");
+  }
+  timeToReset;
+  limit;
+  method;
+  hash;
+  url;
+  route;
+  majorParameter;
+  global;
+  constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global }) {
+    super();
+    this.timeToReset = timeToReset;
+    this.limit = limit;
+    this.method = method;
+    this.hash = hash;
+    this.url = url;
+    this.route = route;
+    this.majorParameter = majorParameter;
+    this.global = global;
+  }
+  /**
+   * The name of the error
+   */
+  get name() {
+    return `${_RateLimitError.name}[${this.route}]`;
+  }
+};
+
+// src/lib/RequestManager.ts
+import { Collection } from "@discordjs/collection";
+import { DiscordSnowflake } from "@sapphire/snowflake";
+import { AsyncEventEmitter } from "@vladfrangu/async_event_emitter";
+import { filetypeinfo } from "magic-bytes.js";
+
+// src/lib/utils/utils.ts
+function serializeSearchParam(value) {
+  switch (typeof value) {
+    case "string":
+      return value;
+    case "number":
+    case "bigint":
+    case "boolean":
+      return value.toString();
+    case "object":
+      if (value === null)
+        return null;
+      if (value instanceof Date) {
+        return Number.isNaN(value.getTime()) ? null : value.toISOString();
+      }
+      if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
+        return value.toString();
+      return null;
+    default:
+      return null;
+  }
+}
+__name(serializeSearchParam, "serializeSearchParam");
+function makeURLSearchParams(options) {
+  const params = new URLSearchParams();
+  if (!options)
+    return params;
+  for (const [key, value] of Object.entries(options)) {
+    const serialized = serializeSearchParam(value);
+    if (serialized !== null)
+      params.append(key, serialized);
+  }
+  return params;
+}
+__name(makeURLSearchParams, "makeURLSearchParams");
+async function parseResponse(res) {
+  if (res.headers.get("Content-Type")?.startsWith("application/json")) {
+    return res.json();
+  }
+  return res.arrayBuffer();
+}
+__name(parseResponse, "parseResponse");
+function hasSublimit(bucketRoute, body, method) {
+  if (bucketRoute === "/channels/:id") {
+    if (typeof body !== "object" || body === null)
+      return false;
+    if (method !== "PATCH" /* Patch */)
+      return false;
+    const castedBody = body;
+    return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
+  }
+  return true;
+}
+__name(hasSublimit, "hasSublimit");
+function shouldRetry(error) {
+  if (error.name === "AbortError")
+    return true;
+  return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
+}
+__name(shouldRetry, "shouldRetry");
+async function onRateLimit(manager, rateLimitData) {
+  const { options } = manager;
+  if (!options.rejectOnRateLimit)
+    return;
+  const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
+  if (shouldThrow) {
+    throw new RateLimitError(rateLimitData);
+  }
+}
+__name(onRateLimit, "onRateLimit");
+function calculateUserDefaultAvatarIndex(userId) {
+  return Number(BigInt(userId) >> 22n) % 6;
+}
+__name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
+async function sleep(ms) {
+  return new Promise((resolve) => {
+    setTimeout(() => resolve(), ms);
+  });
+}
+__name(sleep, "sleep");
+function isBufferLike(value) {
+  return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
+}
+__name(isBufferLike, "isBufferLike");
+
+// src/lib/handlers/Shared.ts
+import { Response } from "undici";
+var invalidCount = 0;
+var invalidCountResetTime = null;
+function incrementInvalidCount(manager) {
+  if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
+    invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
+    invalidCount = 0;
+  }
+  invalidCount++;
+  const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
+  if (emitInvalid) {
+    manager.emit("invalidRequestWarning" /* InvalidRequestWarning */, {
+      count: invalidCount,
+      remainingTime: invalidCountResetTime - Date.now()
+    });
+  }
+}
+__name(incrementInvalidCount, "incrementInvalidCount");
+async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
+  const controller = new AbortController();
+  const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
+  if (requestData.signal) {
+    if (requestData.signal.aborted)
+      controller.abort();
+    else
+      requestData.signal.addEventListener("abort", () => controller.abort());
+  }
+  let res;
+  try {
+    res = await manager.options.makeRequest(url, { ...options, signal: controller.signal });
+  } catch (error) {
+    if (!(error instanceof Error))
+      throw error;
+    if (shouldRetry(error) && retries !== manager.options.retries) {
+      return null;
+    }
+    throw error;
+  } finally {
+    clearTimeout(timeout);
+  }
+  if (manager.listenerCount("response" /* Response */)) {
+    manager.emit(
+      "response" /* Response */,
+      {
+        method: options.method ?? "GET" /* Get */,
+        path: routeId.original,
+        route: routeId.bucketRoute,
+        options,
+        data: requestData,
+        retries
+      },
+      res instanceof Response ? res.clone() : { ...res }
+    );
+  }
+  return res;
+}
+__name(makeNetworkRequest, "makeNetworkRequest");
+async function handleErrors(manager, res, method, url, requestData, retries) {
+  const status = res.status;
+  if (status >= 500 && status < 600) {
+    if (retries !== manager.options.retries) {
+      return null;
+    }
+    throw new HTTPError(status, res.statusText, method, url, requestData);
+  } else {
+    if (status >= 400 && status < 500) {
+      if (status === 401 && requestData.auth) {
+        manager.setToken(null);
+      }
+      const data = await parseResponse(res);
+      throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
+    }
+    return res;
+  }
+}
+__name(handleErrors, "handleErrors");
+
+// src/lib/handlers/BurstHandler.ts
+var BurstHandler = class {
+  /**
+   * @param manager - The request manager
+   * @param hash - The hash that this RequestHandler handles
+   * @param majorParameter - The major parameter for this handler
+   */
+  constructor(manager, hash, majorParameter) {
+    this.manager = manager;
+    this.hash = hash;
+    this.majorParameter = majorParameter;
+    this.id = `${hash}:${majorParameter}`;
+  }
+  static {
+    __name(this, "BurstHandler");
+  }
+  /**
+   * {@inheritdoc IHandler.id}
+   */
+  id;
+  /**
+   * {@inheritDoc IHandler.inactive}
+   */
+  inactive = false;
+  /**
+   * Emits a debug message
+   *
+   * @param message - The message to debug
+   */
+  debug(message) {
+    this.manager.emit("restDebug" /* Debug */, `[REST ${this.id}] ${message}`);
+  }
+  /**
+   * {@inheritDoc IHandler.queueRequest}
+   */
+  async queueRequest(routeId, url, options, requestData) {
+    return this.runRequest(routeId, url, options, requestData);
+  }
+  /**
+   * The method that actually makes the request to the API, and updates info about the bucket accordingly
+   *
+   * @param routeId - The generalized API route with literal ids for major parameters
+   * @param url - The fully resolved URL to make the request to
+   * @param options - The fetch options needed to make the request
+   * @param requestData - Extra data from the user's request needed for errors and additional processing
+   * @param retries - The number of retries this request has already attempted (recursion)
+   */
+  async runRequest(routeId, url, options, requestData, retries = 0) {
+    const method = options.method ?? "GET" /* Get */;
+    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
+    if (res === null) {
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
+    }
+    const status = res.status;
+    let retryAfter = 0;
+    const retry = res.headers.get("Retry-After");
+    if (retry)
+      retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
+    if (status === 401 || status === 403 || status === 429) {
+      incrementInvalidCount(this.manager);
+    }
+    if (status >= 200 && status < 300) {
+      return res;
+    } else if (status === 429) {
+      const isGlobal = res.headers.has("X-RateLimit-Global");
+      await onRateLimit(this.manager, {
+        timeToReset: retryAfter,
+        limit: Number.POSITIVE_INFINITY,
+        method,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      });
+      this.debug(
+        [
+          "Encountered unexpected 429 rate limit",
+          `  Global         : ${isGlobal}`,
+          `  Method         : ${method}`,
+          `  URL            : ${url}`,
+          `  Bucket         : ${routeId.bucketRoute}`,
+          `  Major parameter: ${routeId.majorParameter}`,
+          `  Hash           : ${this.hash}`,
+          `  Limit          : ${Number.POSITIVE_INFINITY}`,
+          `  Retry After    : ${retryAfter}ms`,
+          `  Sublimit       : None`
+        ].join("\n")
+      );
+      await sleep(retryAfter);
+      return this.runRequest(routeId, url, options, requestData, retries);
+    } else {
+      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
+      if (handled === null) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      return handled;
+    }
+  }
+};
+
+// src/lib/handlers/SequentialHandler.ts
+import { AsyncQueue } from "@sapphire/async-queue";
+var SequentialHandler = class {
+  /**
+   * @param manager - The request manager
+   * @param hash - The hash that this RequestHandler handles
+   * @param majorParameter - The major parameter for this handler
+   */
+  constructor(manager, hash, majorParameter) {
+    this.manager = manager;
+    this.hash = hash;
+    this.majorParameter = majorParameter;
+    this.id = `${hash}:${majorParameter}`;
+  }
+  static {
+    __name(this, "SequentialHandler");
+  }
+  /**
+   * {@inheritDoc IHandler.id}
+   */
+  id;
+  /**
+   * The time this rate limit bucket will reset
+   */
+  reset = -1;
+  /**
+   * The remaining requests that can be made before we are rate limited
+   */
+  remaining = 1;
+  /**
+   * The total number of requests that can be made before we are rate limited
+   */
+  limit = Number.POSITIVE_INFINITY;
+  /**
+   * The interface used to sequence async requests sequentially
+   */
+  #asyncQueue = new AsyncQueue();
+  /**
+   * The interface used to sequence sublimited async requests sequentially
+   */
+  #sublimitedQueue = null;
+  /**
+   * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed
+   */
+  #sublimitPromise = null;
+  /**
+   * Whether the sublimit queue needs to be shifted in the finally block
+   */
+  #shiftSublimit = false;
+  /**
+   * {@inheritDoc IHandler.inactive}
+   */
+  get inactive() {
+    return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
+  }
+  /**
+   * If the rate limit bucket is currently limited by the global limit
+   */
+  get globalLimited() {
+    return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
+  }
+  /**
+   * If the rate limit bucket is currently limited by its limit
+   */
+  get localLimited() {
+    return this.remaining <= 0 && Date.now() < this.reset;
+  }
+  /**
+   * If the rate limit bucket is currently limited
+   */
+  get limited() {
+    return this.globalLimited || this.localLimited;
+  }
+  /**
+   * The time until queued requests can continue
+   */
+  get timeToReset() {
+    return this.reset + this.manager.options.offset - Date.now();
+  }
+  /**
+   * Emits a debug message
+   *
+   * @param message - The message to debug
+   */
+  debug(message) {
+    this.manager.emit("restDebug" /* Debug */, `[REST ${this.id}] ${message}`);
+  }
+  /**
+   * Delay all requests for the specified amount of time, handling global rate limits
+   *
+   * @param time - The amount of time to delay all requests for
+   */
+  async globalDelayFor(time) {
+    await sleep(time);
+    this.manager.globalDelay = null;
+  }
+  /**
+   * {@inheritDoc IHandler.queueRequest}
+   */
+  async queueRequest(routeId, url, options, requestData) {
+    let queue = this.#asyncQueue;
+    let queueType = 0 /* Standard */;
+    if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
+      queue = this.#sublimitedQueue;
+      queueType = 1 /* Sublimit */;
+    }
+    await queue.wait({ signal: requestData.signal });
+    if (queueType === 0 /* Standard */) {
+      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
+        queue = this.#sublimitedQueue;
+        const wait = queue.wait();
+        this.#asyncQueue.shift();
+        await wait;
+      } else if (this.#sublimitPromise) {
+        await this.#sublimitPromise.promise;
+      }
+    }
+    try {
+      return await this.runRequest(routeId, url, options, requestData);
+    } finally {
+      queue.shift();
+      if (this.#shiftSublimit) {
+        this.#shiftSublimit = false;
+        this.#sublimitedQueue?.shift();
+      }
+      if (this.#sublimitedQueue?.remaining === 0) {
+        this.#sublimitPromise?.resolve();
+        this.#sublimitedQueue = null;
+      }
+    }
+  }
+  /**
+   * The method that actually makes the request to the api, and updates info about the bucket accordingly
+   *
+   * @param routeId - The generalized api route with literal ids for major parameters
+   * @param url - The fully resolved url to make the request to
+   * @param options - The fetch options needed to make the request
+   * @param requestData - Extra data from the user's request needed for errors and additional processing
+   * @param retries - The number of retries this request has already attempted (recursion)
+   */
+  async runRequest(routeId, url, options, requestData, retries = 0) {
+    while (this.limited) {
+      const isGlobal = this.globalLimited;
+      let limit2;
+      let timeout;
+      let delay;
+      if (isGlobal) {
+        limit2 = this.manager.options.globalRequestsPerSecond;
+        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
+        if (!this.manager.globalDelay) {
+          this.manager.globalDelay = this.globalDelayFor(timeout);
+        }
+        delay = this.manager.globalDelay;
+      } else {
+        limit2 = this.limit;
+        timeout = this.timeToReset;
+        delay = sleep(timeout);
+      }
+      const rateLimitData = {
+        timeToReset: timeout,
+        limit: limit2,
+        method: options.method ?? "GET" /* Get */,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      };
+      this.manager.emit("rateLimited" /* RateLimited */, rateLimitData);
+      await onRateLimit(this.manager, rateLimitData);
+      if (isGlobal) {
+        this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
+      } else {
+        this.debug(`Waiting ${timeout}ms for rate limit to pass`);
+      }
+      await delay;
+    }
+    if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
+      this.manager.globalReset = Date.now() + 1e3;
+      this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
+    }
+    this.manager.globalRemaining--;
+    const method = options.method ?? "GET" /* Get */;
+    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
+    if (res === null) {
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
+    }
+    const status = res.status;
+    let retryAfter = 0;
+    const limit = res.headers.get("X-RateLimit-Limit");
+    const remaining = res.headers.get("X-RateLimit-Remaining");
+    const reset = res.headers.get("X-RateLimit-Reset-After");
+    const hash = res.headers.get("X-RateLimit-Bucket");
+    const retry = res.headers.get("Retry-After");
+    this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
+    this.remaining = remaining ? Number(remaining) : 1;
+    this.reset = reset ? Number(reset) * 1e3 + Date.now() + this.manager.options.offset : Date.now();
+    if (retry)
+      retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
+    if (hash && hash !== this.hash) {
+      this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join("\n"));
+      this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
+    } else if (hash) {
+      const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
+      if (hashData) {
+        hashData.lastAccess = Date.now();
+      }
+    }
+    let sublimitTimeout = null;
+    if (retryAfter > 0) {
+      if (res.headers.has("X-RateLimit-Global")) {
+        this.manager.globalRemaining = 0;
+        this.manager.globalReset = Date.now() + retryAfter;
+      } else if (!this.localLimited) {
+        sublimitTimeout = retryAfter;
+      }
+    }
+    if (status === 401 || status === 403 || status === 429) {
+      incrementInvalidCount(this.manager);
+    }
+    if (res.ok) {
+      return res;
+    } else if (status === 429) {
+      const isGlobal = this.globalLimited;
+      let limit2;
+      let timeout;
+      if (isGlobal) {
+        limit2 = this.manager.options.globalRequestsPerSecond;
+        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
+      } else {
+        limit2 = this.limit;
+        timeout = this.timeToReset;
+      }
+      await onRateLimit(this.manager, {
+        timeToReset: timeout,
+        limit: limit2,
+        method,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      });
+      this.debug(
+        [
+          "Encountered unexpected 429 rate limit",
+          `  Global         : ${isGlobal.toString()}`,
+          `  Method         : ${method}`,
+          `  URL            : ${url}`,
+          `  Bucket         : ${routeId.bucketRoute}`,
+          `  Major parameter: ${routeId.majorParameter}`,
+          `  Hash           : ${this.hash}`,
+          `  Limit          : ${limit2}`,
+          `  Retry After    : ${retryAfter}ms`,
+          `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`
+        ].join("\n")
+      );
+      if (sublimitTimeout) {
+        const firstSublimit = !this.#sublimitedQueue;
+        if (firstSublimit) {
+          this.#sublimitedQueue = new AsyncQueue();
+          void this.#sublimitedQueue.wait();
+          this.#asyncQueue.shift();
+        }
+        this.#sublimitPromise?.resolve();
+        this.#sublimitPromise = null;
+        await sleep(sublimitTimeout);
+        let resolve;
+        const promise = new Promise((res2) => resolve = res2);
+        this.#sublimitPromise = { promise, resolve };
+        if (firstSublimit) {
+          await this.#asyncQueue.wait();
+          this.#shiftSublimit = true;
+        }
+      }
+      return this.runRequest(routeId, url, options, requestData, retries);
+    } else {
+      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
+      if (handled === null) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      return handled;
+    }
+  }
+};
+
+// src/lib/RequestManager.ts
+var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
+  RequestMethod2["Delete"] = "DELETE";
+  RequestMethod2["Get"] = "GET";
+  RequestMethod2["Patch"] = "PATCH";
+  RequestMethod2["Post"] = "POST";
+  RequestMethod2["Put"] = "PUT";
+  return RequestMethod2;
+})(RequestMethod || {});
+var RequestManager = class _RequestManager extends AsyncEventEmitter {
+  static {
+    __name(this, "RequestManager");
+  }
+  /**
+   * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
+   * performed by this manager.
+   */
+  agent = null;
+  /**
+   * The number of requests remaining in the global bucket
+   */
+  globalRemaining;
+  /**
+   * The promise used to wait out the global rate limit
+   */
+  globalDelay = null;
+  /**
+   * The timestamp at which the global bucket resets
+   */
+  globalReset = -1;
+  /**
+   * API bucket hashes that are cached from provided routes
+   */
+  hashes = new Collection();
+  /**
+   * Request handlers created from the bucket hash and the major parameters
+   */
+  handlers = new Collection();
+  #token = null;
+  hashTimer;
+  handlerTimer;
+  options;
+  constructor(options) {
+    super();
+    this.options = { ...DefaultRestOptions, ...options };
+    this.options.offset = Math.max(0, this.options.offset);
+    this.globalRemaining = this.options.globalRequestsPerSecond;
+    this.agent = options.agent ?? null;
+    this.setupSweepers();
+  }
+  setupSweepers() {
+    const validateMaxInterval = /* @__PURE__ */ __name((interval) => {
+      if (interval > 144e5) {
+        throw new Error("Cannot set an interval greater than 4 hours");
+      }
+    }, "validateMaxInterval");
+    if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
+      validateMaxInterval(this.options.hashSweepInterval);
+      this.hashTimer = setInterval(() => {
+        const sweptHashes = new Collection();
+        const currentDate = Date.now();
+        this.hashes.sweep((val, key) => {
+          if (val.lastAccess === -1)
+            return false;
+          const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
+          if (shouldSweep) {
+            sweptHashes.set(key, val);
+          }
+          this.emit("restDebug" /* Debug */, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
+          return shouldSweep;
+        });
+        this.emit("hashSweep" /* HashSweep */, sweptHashes);
+      }, this.options.hashSweepInterval);
+    }
+    if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
+      validateMaxInterval(this.options.handlerSweepInterval);
+      this.handlerTimer = setInterval(() => {
+        const sweptHandlers = new Collection();
+        this.handlers.sweep((val, key) => {
+          const { inactive } = val;
+          if (inactive) {
+            sweptHandlers.set(key, val);
+          }
+          this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
+          return inactive;
+        });
+        this.emit("handlerSweep" /* HandlerSweep */, sweptHandlers);
+      }, this.options.handlerSweepInterval);
+    }
+  }
+  /**
+   * Sets the default agent to use for requests performed by this manager
+   *
+   * @param agent - The agent to use
+   */
+  setAgent(agent) {
+    this.agent = agent;
+    return this;
+  }
+  /**
+   * Sets the authorization token that should be used for requests
+   *
+   * @param token - The authorization token to use
+   */
+  setToken(token) {
+    this.#token = token;
+    return this;
+  }
+  /**
+   * Queues a request to be sent
+   *
+   * @param request - All the information needed to make a request
+   * @returns The response from the api request
+   */
+  async queueRequest(request) {
+    const routeId = _RequestManager.generateRouteData(request.fullRoute, request.method);
+    const hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {
+      value: `Global(${request.method}:${routeId.bucketRoute})`,
+      lastAccess: -1
+    };
+    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
+    const { url, fetchOptions } = await this.resolveRequest(request);
+    return handler.queueRequest(routeId, url, fetchOptions, {
+      body: request.body,
+      files: request.files,
+      auth: request.auth !== false,
+      signal: request.signal
+    });
+  }
+  /**
+   * Creates a new rate limit handler from a hash, based on the hash and the major parameter
+   *
+   * @param hash - The hash for the route
+   * @param majorParameter - The major parameter for this handler
+   * @internal
+   */
+  createHandler(hash, majorParameter) {
+    const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
+    this.handlers.set(queue.id, queue);
+    return queue;
+  }
+  /**
+   * Formats the request data to a usable format for fetch
+   *
+   * @param request - The request data
+   */
+  async resolveRequest(request) {
+    const { options } = this;
+    let query = "";
+    if (request.query) {
+      const resolvedQuery = request.query.toString();
+      if (resolvedQuery !== "") {
+        query = `?${resolvedQuery}`;
+      }
+    }
+    const headers = {
+      ...this.options.headers,
+      "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
+    };
+    if (request.auth !== false) {
+      if (!this.#token) {
+        throw new Error("Expected token to be set for this request, but none was present");
+      }
+      headers.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${this.#token}`;
+    }
+    if (request.reason?.length) {
+      headers["X-Audit-Log-Reason"] = encodeURIComponent(request.reason);
+    }
+    const url = `${options.api}${request.versioned === false ? "" : `/v${options.version}`}${request.fullRoute}${query}`;
+    let finalBody;
+    let additionalHeaders = {};
+    if (request.files?.length) {
+      const formData = new FormData();
+      for (const [index, file] of request.files.entries()) {
+        const fileKey = file.key ?? `files[${index}]`;
+        if (isBufferLike(file.data)) {
+          let contentType = file.contentType;
+          if (!contentType) {
+            const [parsedType] = filetypeinfo(file.data);
+            if (parsedType) {
+              contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
+            }
+          }
+          formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
+        } else {
+          formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
+        }
+      }
+      if (request.body != null) {
+        if (request.appendToFormData) {
+          for (const [key, value] of Object.entries(request.body)) {
+            formData.append(key, value);
+          }
+        } else {
+          formData.append("payload_json", JSON.stringify(request.body));
+        }
+      }
+      finalBody = formData;
+    } else if (request.body != null) {
+      if (request.passThroughBody) {
+        finalBody = request.body;
+      } else {
+        finalBody = JSON.stringify(request.body);
+        additionalHeaders = { "Content-Type": "application/json" };
+      }
+    }
+    const method = request.method.toUpperCase();
+    const fetchOptions = {
+      // Set body to null on get / head requests. This does not follow fetch spec (likely because it causes subtle bugs) but is aligned with what request was doing
+      body: ["GET", "HEAD"].includes(method) ? null : finalBody,
+      headers: { ...request.headers, ...additionalHeaders, ...headers },
+      method,
+      // Prioritize setting an agent per request, use the agent for this instance otherwise.
+      dispatcher: request.dispatcher ?? this.agent ?? void 0
+    };
+    return { url, fetchOptions };
+  }
+  /**
+   * Stops the hash sweeping interval
+   */
+  clearHashSweeper() {
+    clearInterval(this.hashTimer);
+  }
+  /**
+   * Stops the request handler sweeping interval
+   */
+  clearHandlerSweeper() {
+    clearInterval(this.handlerTimer);
+  }
+  /**
+   * Generates route data for an endpoint:method
+   *
+   * @param endpoint - The raw endpoint to generalize
+   * @param method - The HTTP method this endpoint is called without
+   * @internal
+   */
+  static generateRouteData(endpoint, method) {
+    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
+      return {
+        majorParameter: BurstHandlerMajorIdKey,
+        bucketRoute: "/interactions/:id/:token/callback",
+        original: endpoint
+      };
+    }
+    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
+    const majorId = majorIdMatch?.[1] ?? "global";
+    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
+    let exceptions = "";
+    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
+      const id = /\d{17,19}$/.exec(endpoint)[0];
+      const timestamp = DiscordSnowflake.timestampFrom(id);
+      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
+        exceptions += "/Delete Old Message";
+      }
+    }
+    return {
+      majorParameter: majorId,
+      bucketRoute: baseRoute + exceptions,
+      original: endpoint
+    };
+  }
+};
+
+// src/lib/REST.ts
+import { AsyncEventEmitter as AsyncEventEmitter2 } from "@vladfrangu/async_event_emitter";
+var REST = class extends AsyncEventEmitter2 {
+  static {
+    __name(this, "REST");
+  }
+  cdn;
+  requestManager;
+  constructor(options = {}) {
+    super();
+    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
+    this.requestManager = new RequestManager(options).on("restDebug" /* Debug */, this.emit.bind(this, "restDebug" /* Debug */)).on("rateLimited" /* RateLimited */, this.emit.bind(this, "rateLimited" /* RateLimited */)).on("invalidRequestWarning" /* InvalidRequestWarning */, this.emit.bind(this, "invalidRequestWarning" /* InvalidRequestWarning */)).on("hashSweep" /* HashSweep */, this.emit.bind(this, "hashSweep" /* HashSweep */));
+    this.on("newListener", (name, listener) => {
+      if (name === "response" /* Response */)
+        this.requestManager.on(name, listener);
+    });
+    this.on("removeListener", (name, listener) => {
+      if (name === "response" /* Response */)
+        this.requestManager.off(name, listener);
+    });
+  }
+  /**
+   * Gets the agent set for this instance
+   */
+  getAgent() {
+    return this.requestManager.agent;
+  }
+  /**
+   * Sets the default agent to use for requests performed by this instance
+   *
+   * @param agent - Sets the agent to use
+   */
+  setAgent(agent) {
+    this.requestManager.setAgent(agent);
+    return this;
+  }
+  /**
+   * Sets the authorization token that should be used for requests
+   *
+   * @param token - The authorization token to use
+   */
+  setToken(token) {
+    this.requestManager.setToken(token);
+    return this;
+  }
+  /**
+   * Runs a get request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async get(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "GET" /* Get */ });
+  }
+  /**
+   * Runs a delete request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async delete(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "DELETE" /* Delete */ });
+  }
+  /**
+   * Runs a post request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async post(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "POST" /* Post */ });
+  }
+  /**
+   * Runs a put request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async put(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "PUT" /* Put */ });
+  }
+  /**
+   * Runs a patch request from the api
+   *
+   * @param fullRoute - The full route to query
+   * @param options - Optional request options
+   */
+  async patch(fullRoute, options) {
+    return this.request({ ...options, fullRoute, method: "PATCH" /* Patch */ });
+  }
+  /**
+   * Runs a request from the api
+   *
+   * @param options - Request options
+   */
+  async request(options) {
+    const response = await this.raw(options);
+    return parseResponse(response);
+  }
+  /**
+   * Runs a request from the API, yielding the raw Response object
+   *
+   * @param options - Request options
+   */
+  async raw(options) {
+    return this.requestManager.queueRequest(options);
+  }
+};
+
+// src/shared.ts
+var version = "1.8.0-dev.1689552764-351a18b.0";
+
+// src/web.ts
+setDefaultStrategy(fetch);
+export {
+  ALLOWED_EXTENSIONS,
+  ALLOWED_SIZES,
+  ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey,
+  CDN,
+  DefaultRestOptions,
+  DefaultUserAgent,
+  DefaultUserAgentAppendix,
+  DiscordAPIError,
+  HTTPError,
+  OverwrittenMimeTypes,
+  REST,
+  RESTEvents,
+  RateLimitError,
+  RequestManager,
+  RequestMethod,
+  calculateUserDefaultAvatarIndex,
+  makeURLSearchParams,
+  parseResponse,
+  version
+};
+//# sourceMappingURL=web.mjs.map
\ No newline at end of file
