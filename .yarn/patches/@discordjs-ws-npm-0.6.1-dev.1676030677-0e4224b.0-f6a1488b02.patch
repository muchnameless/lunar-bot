diff --git a/dist/defaultWorker.js b/dist/defaultWorker.js
index adf1facc54244bd760b03a2eb950ceb2d6ba662e..af228f655a87e2f487cb2fed029b251a703b7d70 100644
--- a/dist/defaultWorker.js
+++ b/dist/defaultWorker.js
@@ -159,6 +159,7 @@ var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
   WebSocketShardEvents2["Closed"] = "closed";
   WebSocketShardEvents2["Debug"] = "debug";
   WebSocketShardEvents2["Dispatch"] = "dispatch";
+  WebSocketShardEvents2["Error"] = "error";
   WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
   WebSocketShardEvents2["Hello"] = "hello";
   WebSocketShardEvents2["Ready"] = "ready";
@@ -181,6 +182,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
+  initialConnectResolved = false;
   sendQueue = new import_async_queue2.AsyncQueue();
   timeouts = new import_collection4.Collection();
   strategy;
@@ -223,13 +225,16 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
+    if (await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout) !== null) {
+      return;
+    }
     if (session?.shardCount === this.strategy.options.shardCount) {
       this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
+    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -278,16 +283,33 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
   }
   async waitForEvent(event, timeoutDuration) {
-    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
+    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
-    await (0, import_node_events2.once)(this, event, { signal: controller.signal });
-    if (timeout) {
-      (0, import_node_timers.clearTimeout)(timeout);
-      this.timeouts.delete(event);
+    try {
+      await (0, import_node_events2.once)(this, event, { signal: controller.signal });
+      return null;
+    } catch ({ error }) {
+      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
+        throw error;
+      }
+      if (error instanceof Error && error.name === "AbortError") {
+        this.emit("error" /* Error */, { error });
+      }
+      await this.destroy({
+        code: 1e3 /* Normal */,
+        reason: "Something timed out",
+        recover: 0 /* Reconnect */
+      });
+      return error;
+    } finally {
+      if (timeout) {
+        (0, import_node_timers.clearTimeout)(timeout);
+        this.timeouts.delete(event);
+      }
     }
   }
   async send(payload) {
@@ -296,7 +318,11 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
     if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
       this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
-      await (0, import_node_events2.once)(this, "ready" /* Ready */);
+      try {
+        await (0, import_node_events2.once)(this, "ready" /* Ready */);
+      } catch {
+        return this.send(payload);
+      }
     }
     await this.sendQueue.wait();
     if (--this.sendRateLimitState.remaining <= 0) {
@@ -347,7 +373,9 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       op: import_v102.GatewayOpcodes.Identify,
       d
     });
-    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
+    if (await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout) !== null) {
+      return;
+    }
     this.#status = 3 /* Ready */;
   }
   async resume(session) {
@@ -396,7 +424,9 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       const zlib = await getZlibSync();
       this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
       if (this.inflate.err) {
-        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
+        this.emit("error" /* Error */, {
+          error: `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`
+        });
       }
       if (!flush) {
         return null;
@@ -484,6 +514,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       case import_v102.GatewayOpcodes.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
@@ -499,8 +530,8 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       }
     }
   }
-  onError(err) {
-    this.emit("error", err);
+  onError(error) {
+    this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
     this.emit("closed" /* Closed */, { code });
@@ -516,7 +547,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         break;
       }
       case import_v102.GatewayCloseCodes.UnknownError: {
-        this.debug([`An unknown error occured: ${code}`]);
+        this.debug([`An unknown error occurred: ${code}`]);
         return this.destroy({ code, recover: 1 /* Resume */ });
       }
       case import_v102.GatewayCloseCodes.UnknownOpcode: {
diff --git a/dist/defaultWorker.mjs b/dist/defaultWorker.mjs
index ea5332108a1a1c6439f3bc394b7b5c24b97364a1..6613c05fafd13671f0180cdb63beba3e5dfb7213 100644
--- a/dist/defaultWorker.mjs
+++ b/dist/defaultWorker.mjs
@@ -145,6 +145,7 @@ var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
   WebSocketShardEvents2["Closed"] = "closed";
   WebSocketShardEvents2["Debug"] = "debug";
   WebSocketShardEvents2["Dispatch"] = "dispatch";
+  WebSocketShardEvents2["Error"] = "error";
   WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
   WebSocketShardEvents2["Hello"] = "hello";
   WebSocketShardEvents2["Ready"] = "ready";
@@ -167,6 +168,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
+  initialConnectResolved = false;
   sendQueue = new AsyncQueue2();
   timeouts = new Collection4();
   strategy;
@@ -209,13 +211,16 @@ var WebSocketShard = class extends AsyncEventEmitter {
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
+    if (await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout) !== null) {
+      return;
+    }
     if (session?.shardCount === this.strategy.options.shardCount) {
       this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
+    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -264,16 +269,33 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
   }
   async waitForEvent(event, timeoutDuration) {
-    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
+    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
-    await once2(this, event, { signal: controller.signal });
-    if (timeout) {
-      clearTimeout(timeout);
-      this.timeouts.delete(event);
+    try {
+      await once2(this, event, { signal: controller.signal });
+      return null;
+    } catch ({ error }) {
+      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
+        throw error;
+      }
+      if (error instanceof Error && error.name === "AbortError") {
+        this.emit("error" /* Error */, { error });
+      }
+      await this.destroy({
+        code: 1e3 /* Normal */,
+        reason: "Something timed out",
+        recover: 0 /* Reconnect */
+      });
+      return error;
+    } finally {
+      if (timeout) {
+        clearTimeout(timeout);
+        this.timeouts.delete(event);
+      }
     }
   }
   async send(payload) {
@@ -282,7 +304,11 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
     if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
       this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
-      await once2(this, "ready" /* Ready */);
+      try {
+        await once2(this, "ready" /* Ready */);
+      } catch {
+        return this.send(payload);
+      }
     }
     await this.sendQueue.wait();
     if (--this.sendRateLimitState.remaining <= 0) {
@@ -333,7 +359,9 @@ var WebSocketShard = class extends AsyncEventEmitter {
       op: GatewayOpcodes2.Identify,
       d
     });
-    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
+    if (await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout) !== null) {
+      return;
+    }
     this.#status = 3 /* Ready */;
   }
   async resume(session) {
@@ -382,7 +410,9 @@ var WebSocketShard = class extends AsyncEventEmitter {
       const zlib = await getZlibSync();
       this.inflate.push(Buffer2.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
       if (this.inflate.err) {
-        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
+        this.emit("error" /* Error */, {
+          error: `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`
+        });
       }
       if (!flush) {
         return null;
@@ -470,6 +500,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
       case GatewayOpcodes2.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
@@ -485,8 +516,8 @@ var WebSocketShard = class extends AsyncEventEmitter {
       }
     }
   }
-  onError(err) {
-    this.emit("error", err);
+  onError(error) {
+    this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
     this.emit("closed" /* Closed */, { code });
@@ -502,7 +533,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
         break;
       }
       case GatewayCloseCodes.UnknownError: {
-        this.debug([`An unknown error occured: ${code}`]);
+        this.debug([`An unknown error occurred: ${code}`]);
         return this.destroy({ code, recover: 1 /* Resume */ });
       }
       case GatewayCloseCodes.UnknownOpcode: {
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 9b5fda0d436efd4120357c2859690b1242bcc1ef..ada38883a9b4614ad384b810f7570f8861682def 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -10,6 +10,7 @@ declare enum WebSocketShardEvents {
     Closed = "closed",
     Debug = "debug",
     Dispatch = "dispatch",
+    Error = "error",
     HeartbeatComplete = "heartbeat",
     Hello = "hello",
     Ready = "ready",
@@ -35,6 +36,9 @@ type WebSocketShardEventsMap = {
     [WebSocketShardEvents.Dispatch]: [payload: {
         data: GatewayDispatchPayload;
     }];
+    [WebSocketShardEvents.Error]: [payload: {
+        error: unknown;
+    }];
     [WebSocketShardEvents.Hello]: [];
     [WebSocketShardEvents.Ready]: [payload: {
         data: GatewayReadyDispatchData;
@@ -71,6 +75,7 @@ declare class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap>
     private heartbeatInterval;
     private lastHeartbeatAt;
     private session;
+    private initialConnectResolved;
     private readonly sendQueue;
     private readonly timeouts;
     private readonly strategy;
@@ -567,7 +572,7 @@ interface BootstrapOptions {
     shardCallback?(shard: WebSocketShard): Awaitable<void>;
 }
 /**
- * Utility class for bootstraping a worker thread to be used for sharding
+ * Utility class for bootstrapping a worker thread to be used for sharding
  */
 declare class WorkerBootstrapper {
     /**
diff --git a/dist/index.js b/dist/index.js
index 65343ec427fb98d66055c8cbf9a4bd755f60c000..7ccd1a2a1e3a965dc45a4e9c58a040e9962d1909 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -477,6 +477,7 @@ var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
   WebSocketShardEvents2["Closed"] = "closed";
   WebSocketShardEvents2["Debug"] = "debug";
   WebSocketShardEvents2["Dispatch"] = "dispatch";
+  WebSocketShardEvents2["Error"] = "error";
   WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
   WebSocketShardEvents2["Hello"] = "hello";
   WebSocketShardEvents2["Ready"] = "ready";
@@ -511,6 +512,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
+  initialConnectResolved = false;
   sendQueue = new import_async_queue2.AsyncQueue();
   timeouts = new import_collection4.Collection();
   strategy;
@@ -553,13 +555,16 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
+    if (await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout) !== null) {
+      return;
+    }
     if (session?.shardCount === this.strategy.options.shardCount) {
       this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
+    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -608,16 +613,33 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
   }
   async waitForEvent(event, timeoutDuration) {
-    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
+    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
-    await (0, import_node_events2.once)(this, event, { signal: controller.signal });
-    if (timeout) {
-      (0, import_node_timers.clearTimeout)(timeout);
-      this.timeouts.delete(event);
+    try {
+      await (0, import_node_events2.once)(this, event, { signal: controller.signal });
+      return null;
+    } catch ({ error }) {
+      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
+        throw error;
+      }
+      if (error instanceof Error && error.name === "AbortError") {
+        this.emit("error" /* Error */, { error });
+      }
+      await this.destroy({
+        code: 1e3 /* Normal */,
+        reason: "Something timed out",
+        recover: 0 /* Reconnect */
+      });
+      return error;
+    } finally {
+      if (timeout) {
+        (0, import_node_timers.clearTimeout)(timeout);
+        this.timeouts.delete(event);
+      }
     }
   }
   async send(payload) {
@@ -626,7 +648,11 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
     if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
       this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
-      await (0, import_node_events2.once)(this, "ready" /* Ready */);
+      try {
+        await (0, import_node_events2.once)(this, "ready" /* Ready */);
+      } catch {
+        return this.send(payload);
+      }
     }
     await this.sendQueue.wait();
     if (--this.sendRateLimitState.remaining <= 0) {
@@ -677,7 +703,9 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       op: import_v102.GatewayOpcodes.Identify,
       d
     });
-    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
+    if (await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout) !== null) {
+      return;
+    }
     this.#status = 3 /* Ready */;
   }
   async resume(session) {
@@ -726,7 +754,9 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       const zlib = await getZlibSync();
       this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
       if (this.inflate.err) {
-        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
+        this.emit("error" /* Error */, {
+          error: `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`
+        });
       }
       if (!flush) {
         return null;
@@ -814,6 +844,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       case import_v102.GatewayOpcodes.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
@@ -829,8 +860,8 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       }
     }
   }
-  onError(err) {
-    this.emit("error", err);
+  onError(error) {
+    this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
     this.emit("closed" /* Closed */, { code });
@@ -846,7 +877,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
         break;
       }
       case import_v102.GatewayCloseCodes.UnknownError: {
-        this.debug([`An unknown error occured: ${code}`]);
+        this.debug([`An unknown error occurred: ${code}`]);
         return this.destroy({ code, recover: 1 /* Resume */ });
       }
       case import_v102.GatewayCloseCodes.UnknownOpcode: {
diff --git a/dist/index.mjs b/dist/index.mjs
index c5595d18155c1a74f85faeb2057e11aaead5e0a8..5a6b8695db682afa1d7e97eb0df3879ea6987af6 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -444,6 +444,7 @@ var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
   WebSocketShardEvents2["Closed"] = "closed";
   WebSocketShardEvents2["Debug"] = "debug";
   WebSocketShardEvents2["Dispatch"] = "dispatch";
+  WebSocketShardEvents2["Error"] = "error";
   WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
   WebSocketShardEvents2["Hello"] = "hello";
   WebSocketShardEvents2["Ready"] = "ready";
@@ -478,6 +479,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
+  initialConnectResolved = false;
   sendQueue = new AsyncQueue2();
   timeouts = new Collection4();
   strategy;
@@ -520,13 +522,16 @@ var WebSocketShard = class extends AsyncEventEmitter {
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
+    if (await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout) !== null) {
+      return;
+    }
     if (session?.shardCount === this.strategy.options.shardCount) {
       this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
+    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -575,16 +580,33 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
   }
   async waitForEvent(event, timeoutDuration) {
-    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
+    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
-    await once2(this, event, { signal: controller.signal });
-    if (timeout) {
-      clearTimeout(timeout);
-      this.timeouts.delete(event);
+    try {
+      await once2(this, event, { signal: controller.signal });
+      return null;
+    } catch ({ error }) {
+      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
+        throw error;
+      }
+      if (error instanceof Error && error.name === "AbortError") {
+        this.emit("error" /* Error */, { error });
+      }
+      await this.destroy({
+        code: 1e3 /* Normal */,
+        reason: "Something timed out",
+        recover: 0 /* Reconnect */
+      });
+      return error;
+    } finally {
+      if (timeout) {
+        clearTimeout(timeout);
+        this.timeouts.delete(event);
+      }
     }
   }
   async send(payload) {
@@ -593,7 +615,11 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
     if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
       this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
-      await once2(this, "ready" /* Ready */);
+      try {
+        await once2(this, "ready" /* Ready */);
+      } catch {
+        return this.send(payload);
+      }
     }
     await this.sendQueue.wait();
     if (--this.sendRateLimitState.remaining <= 0) {
@@ -644,7 +670,9 @@ var WebSocketShard = class extends AsyncEventEmitter {
       op: GatewayOpcodes2.Identify,
       d
     });
-    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
+    if (await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout) !== null) {
+      return;
+    }
     this.#status = 3 /* Ready */;
   }
   async resume(session) {
@@ -693,7 +721,9 @@ var WebSocketShard = class extends AsyncEventEmitter {
       const zlib = await getZlibSync();
       this.inflate.push(Buffer2.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
       if (this.inflate.err) {
-        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
+        this.emit("error" /* Error */, {
+          error: `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`
+        });
       }
       if (!flush) {
         return null;
@@ -781,6 +811,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
       case GatewayOpcodes2.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
@@ -796,8 +827,8 @@ var WebSocketShard = class extends AsyncEventEmitter {
       }
     }
   }
-  onError(err) {
-    this.emit("error", err);
+  onError(error) {
+    this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
     this.emit("closed" /* Closed */, { code });
@@ -813,7 +844,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
         break;
       }
       case GatewayCloseCodes.UnknownError: {
-        this.debug([`An unknown error occured: ${code}`]);
+        this.debug([`An unknown error occurred: ${code}`]);
         return this.destroy({ code, recover: 1 /* Resume */ });
       }
       case GatewayCloseCodes.UnknownOpcode: {
