diff --git a/dist/defaultWorker.js b/dist/defaultWorker.js
index 3ae567680368df0c7c82452ab783f71062b597ff..ac1c0cd8c3f96676388b87b0ff39ffcc1b63c5a3 100644
--- a/dist/defaultWorker.js
+++ b/dist/defaultWorker.js
@@ -159,6 +159,7 @@ var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
   WebSocketShardEvents2["Closed"] = "closed";
   WebSocketShardEvents2["Debug"] = "debug";
   WebSocketShardEvents2["Dispatch"] = "dispatch";
+  WebSocketShardEvents2["Error"] = "error";
   WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
   WebSocketShardEvents2["Hello"] = "hello";
   WebSocketShardEvents2["Ready"] = "ready";
@@ -181,6 +182,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
+  initialConnectResolved = false;
   sendQueue = new import_async_queue2.AsyncQueue();
   timeouts = new import_collection4.Collection();
   strategy;
@@ -223,13 +225,19 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
+    const { ok } = await this.bubbleWaitForEventError(
+      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
+    );
+    if (!ok) {
+      return;
+    }
     if (session?.shardCount === this.strategy.options.shardCount) {
       this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
+    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -278,16 +286,37 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
   }
   async waitForEvent(event, timeoutDuration) {
-    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
+    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
-    await (0, import_node_events2.once)(this, event, { signal: controller.signal });
-    if (timeout) {
-      (0, import_node_timers.clearTimeout)(timeout);
-      this.timeouts.delete(event);
+    await (0, import_node_events2.once)(this, event, { signal: controller.signal }).finally(() => {
+      if (timeout) {
+        (0, import_node_timers.clearTimeout)(timeout);
+        this.timeouts.delete(event);
+      }
+    });
+  }
+  async bubbleWaitForEventError(promise) {
+    try {
+      await promise;
+      return { ok: true };
+    } catch (error) {
+      if (error instanceof Error && error.name === "AbortError") {
+        this.emit("error" /* Error */, { error });
+      }
+      error = error.error;
+      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
+        throw error;
+      }
+      await this.destroy({
+        code: 1e3 /* Normal */,
+        reason: "Something timed out",
+        recover: 0 /* Reconnect */
+      });
+      return { ok: false, error };
     }
   }
   async send(payload) {
@@ -296,7 +325,11 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
     if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
       this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
-      await (0, import_node_events2.once)(this, "ready" /* Ready */);
+      try {
+        await (0, import_node_events2.once)(this, "ready" /* Ready */);
+      } catch {
+        return this.send(payload);
+      }
     }
     await this.sendQueue.wait();
     if (--this.sendRateLimitState.remaining <= 0) {
@@ -347,7 +380,12 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       op: import_v102.GatewayOpcodes.Identify,
       d
     });
-    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
+    const { ok } = await this.bubbleWaitForEventError(
+      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
+    );
+    if (!ok) {
+      return;
+    }
     this.#status = 3 /* Ready */;
   }
   async resume(session) {
@@ -396,7 +434,9 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       const zlib = await getZlibSync();
       this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
       if (this.inflate.err) {
-        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
+        this.emit("error" /* Error */, {
+          error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
+        });
       }
       if (!flush) {
         return null;
@@ -484,6 +524,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       case import_v102.GatewayOpcodes.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
@@ -499,8 +540,8 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       }
     }
   }
-  onError(err) {
-    this.emit("error", err);
+  onError(error) {
+    this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
     this.emit("closed" /* Closed */, { code });
diff --git a/dist/defaultWorker.mjs b/dist/defaultWorker.mjs
index e02b3d6712cbe07af943fd2d66c6bb3a649632a1..d317b1af1de5b23bcbc474362d046de5a286c5c7 100644
--- a/dist/defaultWorker.mjs
+++ b/dist/defaultWorker.mjs
@@ -145,6 +145,7 @@ var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
   WebSocketShardEvents2["Closed"] = "closed";
   WebSocketShardEvents2["Debug"] = "debug";
   WebSocketShardEvents2["Dispatch"] = "dispatch";
+  WebSocketShardEvents2["Error"] = "error";
   WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
   WebSocketShardEvents2["Hello"] = "hello";
   WebSocketShardEvents2["Ready"] = "ready";
@@ -167,6 +168,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
+  initialConnectResolved = false;
   sendQueue = new AsyncQueue2();
   timeouts = new Collection4();
   strategy;
@@ -209,13 +211,19 @@ var WebSocketShard = class extends AsyncEventEmitter {
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
+    const { ok } = await this.bubbleWaitForEventError(
+      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
+    );
+    if (!ok) {
+      return;
+    }
     if (session?.shardCount === this.strategy.options.shardCount) {
       this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
+    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -264,16 +272,37 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
   }
   async waitForEvent(event, timeoutDuration) {
-    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
+    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
-    await once2(this, event, { signal: controller.signal });
-    if (timeout) {
-      clearTimeout(timeout);
-      this.timeouts.delete(event);
+    await once2(this, event, { signal: controller.signal }).finally(() => {
+      if (timeout) {
+        clearTimeout(timeout);
+        this.timeouts.delete(event);
+      }
+    });
+  }
+  async bubbleWaitForEventError(promise) {
+    try {
+      await promise;
+      return { ok: true };
+    } catch (error) {
+      if (error instanceof Error && error.name === "AbortError") {
+        this.emit("error" /* Error */, { error });
+      }
+      error = error.error;
+      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
+        throw error;
+      }
+      await this.destroy({
+        code: 1e3 /* Normal */,
+        reason: "Something timed out",
+        recover: 0 /* Reconnect */
+      });
+      return { ok: false, error };
     }
   }
   async send(payload) {
@@ -282,7 +311,11 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
     if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
       this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
-      await once2(this, "ready" /* Ready */);
+      try {
+        await once2(this, "ready" /* Ready */);
+      } catch {
+        return this.send(payload);
+      }
     }
     await this.sendQueue.wait();
     if (--this.sendRateLimitState.remaining <= 0) {
@@ -333,7 +366,12 @@ var WebSocketShard = class extends AsyncEventEmitter {
       op: GatewayOpcodes2.Identify,
       d
     });
-    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
+    const { ok } = await this.bubbleWaitForEventError(
+      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
+    );
+    if (!ok) {
+      return;
+    }
     this.#status = 3 /* Ready */;
   }
   async resume(session) {
@@ -382,7 +420,9 @@ var WebSocketShard = class extends AsyncEventEmitter {
       const zlib = await getZlibSync();
       this.inflate.push(Buffer2.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
       if (this.inflate.err) {
-        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
+        this.emit("error" /* Error */, {
+          error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
+        });
       }
       if (!flush) {
         return null;
@@ -470,6 +510,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
       case GatewayOpcodes2.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
@@ -485,8 +526,8 @@ var WebSocketShard = class extends AsyncEventEmitter {
       }
     }
   }
-  onError(err) {
-    this.emit("error", err);
+  onError(error) {
+    this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
     this.emit("closed" /* Closed */, { code });
diff --git a/dist/index.d.ts b/dist/index.d.ts
index cbf86e2adcc5513f28bee898fa495690e45b7993..eb2a5e9305d25eee89fbcb8513508e058a608e08 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -10,6 +10,7 @@ declare enum WebSocketShardEvents {
     Closed = "closed",
     Debug = "debug",
     Dispatch = "dispatch",
+    Error = "error",
     HeartbeatComplete = "heartbeat",
     Hello = "hello",
     Ready = "ready",
@@ -35,6 +36,9 @@ type WebSocketShardEventsMap = {
     [WebSocketShardEvents.Dispatch]: [payload: {
         data: GatewayDispatchPayload;
     }];
+    [WebSocketShardEvents.Error]: [payload: {
+        error: Error;
+    }];
     [WebSocketShardEvents.Hello]: [];
     [WebSocketShardEvents.Ready]: [payload: {
         data: GatewayReadyDispatchData;
@@ -71,6 +75,7 @@ declare class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap>
     private heartbeatInterval;
     private lastHeartbeatAt;
     private session;
+    private initialConnectResolved;
     private readonly sendQueue;
     private readonly timeouts;
     private readonly strategy;
@@ -80,6 +85,11 @@ declare class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap>
     connect(): Promise<void>;
     destroy(options?: WebSocketShardDestroyOptions): Promise<void>;
     private waitForEvent;
+    /**
+     * Does special error handling for waitForEvent calls, depending on the current state of the connection lifecycle
+     * (i.e. whether or not the original connect() call has resolved or if the user has an error listener)
+     */
+    private bubbleWaitForEventError;
     send(payload: GatewaySendPayload): Promise<void>;
     private identify;
     private resume;
diff --git a/dist/index.js b/dist/index.js
index 581a4255aeb953dc17bb68dbb469b9a6e629cd55..85a5ad6ab15445288f7d00f93307269e83b2bf05 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -477,6 +477,7 @@ var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
   WebSocketShardEvents2["Closed"] = "closed";
   WebSocketShardEvents2["Debug"] = "debug";
   WebSocketShardEvents2["Dispatch"] = "dispatch";
+  WebSocketShardEvents2["Error"] = "error";
   WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
   WebSocketShardEvents2["Hello"] = "hello";
   WebSocketShardEvents2["Ready"] = "ready";
@@ -511,6 +512,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
+  initialConnectResolved = false;
   sendQueue = new import_async_queue2.AsyncQueue();
   timeouts = new import_collection4.Collection();
   strategy;
@@ -553,13 +555,19 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
+    const { ok } = await this.bubbleWaitForEventError(
+      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
+    );
+    if (!ok) {
+      return;
+    }
     if (session?.shardCount === this.strategy.options.shardCount) {
       this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
+    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -608,16 +616,37 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
   }
   async waitForEvent(event, timeoutDuration) {
-    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
+    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
-    await (0, import_node_events2.once)(this, event, { signal: controller.signal });
-    if (timeout) {
-      (0, import_node_timers.clearTimeout)(timeout);
-      this.timeouts.delete(event);
+    await (0, import_node_events2.once)(this, event, { signal: controller.signal }).finally(() => {
+      if (timeout) {
+        (0, import_node_timers.clearTimeout)(timeout);
+        this.timeouts.delete(event);
+      }
+    });
+  }
+  async bubbleWaitForEventError(promise) {
+    try {
+      await promise;
+      return { ok: true };
+    } catch (error) {
+      if (error instanceof Error && error.name === "AbortError") {
+        this.emit("error" /* Error */, { error });
+      }
+      error = error.error;
+      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
+        throw error;
+      }
+      await this.destroy({
+        code: 1e3 /* Normal */,
+        reason: "Something timed out",
+        recover: 0 /* Reconnect */
+      });
+      return { ok: false, error };
     }
   }
   async send(payload) {
@@ -626,7 +655,11 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
     }
     if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
       this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
-      await (0, import_node_events2.once)(this, "ready" /* Ready */);
+      try {
+        await (0, import_node_events2.once)(this, "ready" /* Ready */);
+      } catch {
+        return this.send(payload);
+      }
     }
     await this.sendQueue.wait();
     if (--this.sendRateLimitState.remaining <= 0) {
@@ -677,7 +710,12 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       op: import_v102.GatewayOpcodes.Identify,
       d
     });
-    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
+    const { ok } = await this.bubbleWaitForEventError(
+      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
+    );
+    if (!ok) {
+      return;
+    }
     this.#status = 3 /* Ready */;
   }
   async resume(session) {
@@ -726,7 +764,9 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       const zlib = await getZlibSync();
       this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
       if (this.inflate.err) {
-        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
+        this.emit("error" /* Error */, {
+          error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
+        });
       }
       if (!flush) {
         return null;
@@ -814,6 +854,7 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       case import_v102.GatewayOpcodes.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
@@ -829,8 +870,8 @@ var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter
       }
     }
   }
-  onError(err) {
-    this.emit("error", err);
+  onError(error) {
+    this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
     this.emit("closed" /* Closed */, { code });
diff --git a/dist/index.mjs b/dist/index.mjs
index f94104ad075b62fdb7e35d5620941e7e0500139d..2305eb6a3ff8b8a25b81ecf92621d14c262d6d82 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -444,6 +444,7 @@ var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
   WebSocketShardEvents2["Closed"] = "closed";
   WebSocketShardEvents2["Debug"] = "debug";
   WebSocketShardEvents2["Dispatch"] = "dispatch";
+  WebSocketShardEvents2["Error"] = "error";
   WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
   WebSocketShardEvents2["Hello"] = "hello";
   WebSocketShardEvents2["Ready"] = "ready";
@@ -478,6 +479,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
   heartbeatInterval = null;
   lastHeartbeatAt = -1;
   session = null;
+  initialConnectResolved = false;
   sendQueue = new AsyncQueue2();
   timeouts = new Collection4();
   strategy;
@@ -520,13 +522,19 @@ var WebSocketShard = class extends AsyncEventEmitter {
     this.connection = connection;
     this.#status = 1 /* Connecting */;
     this.sendRateLimitState = getInitialSendRateLimitState();
-    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
+    const { ok } = await this.bubbleWaitForEventError(
+      this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout)
+    );
+    if (!ok) {
+      return;
+    }
     if (session?.shardCount === this.strategy.options.shardCount) {
       this.session = session;
       await this.resume(session);
     } else {
       await this.identify();
     }
+    this.initialConnectResolved = true;
   }
   async destroy(options = {}) {
     if (this.#status === 0 /* Idle */) {
@@ -575,16 +583,37 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
   }
   async waitForEvent(event, timeoutDuration) {
-    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
+    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
     const controller = new AbortController();
-    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;
+    const timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration) : null;
     if (timeout) {
       this.timeouts.set(event, timeout);
     }
-    await once2(this, event, { signal: controller.signal });
-    if (timeout) {
-      clearTimeout(timeout);
-      this.timeouts.delete(event);
+    await once2(this, event, { signal: controller.signal }).finally(() => {
+      if (timeout) {
+        clearTimeout(timeout);
+        this.timeouts.delete(event);
+      }
+    });
+  }
+  async bubbleWaitForEventError(promise) {
+    try {
+      await promise;
+      return { ok: true };
+    } catch (error) {
+      if (error instanceof Error && error.name === "AbortError") {
+        this.emit("error" /* Error */, { error });
+      }
+      error = error.error;
+      if (this.listenerCount("error" /* Error */) === 0 || !this.initialConnectResolved) {
+        throw error;
+      }
+      await this.destroy({
+        code: 1e3 /* Normal */,
+        reason: "Something timed out",
+        recover: 0 /* Reconnect */
+      });
+      return { ok: false, error };
     }
   }
   async send(payload) {
@@ -593,7 +622,11 @@ var WebSocketShard = class extends AsyncEventEmitter {
     }
     if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
       this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
-      await once2(this, "ready" /* Ready */);
+      try {
+        await once2(this, "ready" /* Ready */);
+      } catch {
+        return this.send(payload);
+      }
     }
     await this.sendQueue.wait();
     if (--this.sendRateLimitState.remaining <= 0) {
@@ -644,7 +677,12 @@ var WebSocketShard = class extends AsyncEventEmitter {
       op: GatewayOpcodes2.Identify,
       d
     });
-    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
+    const { ok } = await this.bubbleWaitForEventError(
+      this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout)
+    );
+    if (!ok) {
+      return;
+    }
     this.#status = 3 /* Ready */;
   }
   async resume(session) {
@@ -693,7 +731,9 @@ var WebSocketShard = class extends AsyncEventEmitter {
       const zlib = await getZlibSync();
       this.inflate.push(Buffer2.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
       if (this.inflate.err) {
-        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
+        this.emit("error" /* Error */, {
+          error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
+        });
       }
       if (!flush) {
         return null;
@@ -781,6 +821,7 @@ var WebSocketShard = class extends AsyncEventEmitter {
       case GatewayOpcodes2.Hello: {
         this.emit("hello" /* Hello */);
         this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
+        await this.heartbeat(true);
         this.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);
         break;
       }
@@ -796,8 +837,8 @@ var WebSocketShard = class extends AsyncEventEmitter {
       }
     }
   }
-  onError(err) {
-    this.emit("error", err);
+  onError(error) {
+    this.emit("error" /* Error */, { error });
   }
   async onClose(code) {
     this.emit("closed" /* Closed */, { code });
