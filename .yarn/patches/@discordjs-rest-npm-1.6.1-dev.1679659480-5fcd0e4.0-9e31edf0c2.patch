diff --git a/dist/index.d.ts b/dist/index.d.ts
index 5b25f414148a792e1dba153947c2cd4a24ec866d..d627f646147dc32fa4c8d239f7da486bdbb646ee 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -43,6 +43,7 @@ type ImageSize = (typeof ALLOWED_SIZES)[number];
 declare const OverwrittenMimeTypes: {
     readonly 'image/apng': "image/png";
 };
+declare const BurstHandlerMajorIdKey = "burst";
 
 /**
  * The options used for image URLs
@@ -461,82 +462,6 @@ interface RestEvents {
     restDebug: [info: string];
 }
 type RequestOptions = Exclude<Parameters<typeof request>[1], undefined>;
-interface REST {
-    emit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);
-    off: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);
-    on: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);
-    once: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);
-    removeAllListeners: (<K extends keyof RestEvents>(event?: K) => this) & (<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);
-}
-declare class REST extends EventEmitter {
-    readonly cdn: CDN;
-    readonly requestManager: RequestManager;
-    constructor(options?: Partial<RESTOptions>);
-    /**
-     * Gets the agent set for this instance
-     */
-    getAgent(): Dispatcher | null;
-    /**
-     * Sets the default agent to use for requests performed by this instance
-     *
-     * @param agent - Sets the agent to use
-     */
-    setAgent(agent: Dispatcher): this;
-    /**
-     * Sets the authorization token that should be used for requests
-     *
-     * @param token - The authorization token to use
-     */
-    setToken(token: string): this;
-    /**
-     * Runs a get request from the api
-     *
-     * @param fullRoute - The full route to query
-     * @param options - Optional request options
-     */
-    get(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
-    /**
-     * Runs a delete request from the api
-     *
-     * @param fullRoute - The full route to query
-     * @param options - Optional request options
-     */
-    delete(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
-    /**
-     * Runs a post request from the api
-     *
-     * @param fullRoute - The full route to query
-     * @param options - Optional request options
-     */
-    post(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
-    /**
-     * Runs a put request from the api
-     *
-     * @param fullRoute - The full route to query
-     * @param options - Optional request options
-     */
-    put(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
-    /**
-     * Runs a patch request from the api
-     *
-     * @param fullRoute - The full route to query
-     * @param options - Optional request options
-     */
-    patch(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
-    /**
-     * Runs a request from the api
-     *
-     * @param options - Request options
-     */
-    request(options: InternalRequest): Promise<unknown>;
-    /**
-     * Runs a request from the API, yielding the raw Response object
-     *
-     * @param options - Request options
-     */
-    raw(options: InternalRequest): Promise<Dispatcher.ResponseData>;
-}
-
 /**
  * Represents a file to be added to the request
  */
@@ -669,7 +594,7 @@ interface HashData {
     lastAccess: number;
     value: string;
 }
-interface RequestManager {
+interface REST {
     emit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);
     off: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);
     on: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);
@@ -679,7 +604,7 @@ interface RequestManager {
 /**
  * Represents the class that manages handlers for endpoints
  */
-declare class RequestManager extends EventEmitter {
+declare class REST extends EventEmitter {
     #private;
     /**
      * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
@@ -709,7 +634,9 @@ declare class RequestManager extends EventEmitter {
     private hashTimer;
     private handlerTimer;
     readonly options: RESTOptions;
-    constructor(options: Partial<RESTOptions>);
+    readonly cdn: CDN;
+    readonly userAgent: string;
+    constructor(options?: Partial<RESTOptions>);
     private setupSweepers;
     /**
      * Sets the default agent to use for requests performed by this manager
@@ -723,13 +650,6 @@ declare class RequestManager extends EventEmitter {
      * @param token - The authorization token to use
      */
     setToken(token: string): this;
-    /**
-     * Queues a request to be sent
-     *
-     * @param request - All the information needed to make a request
-     * @returns The response from the api request
-     */
-    queueRequest(request: InternalRequest): Promise<Dispatcher.ResponseData>;
     /**
      * Creates a new rate limit handler from a hash, based on the hash and the major parameter
      *
@@ -752,6 +672,53 @@ declare class RequestManager extends EventEmitter {
      * Stops the request handler sweeping interval
      */
     clearHandlerSweeper(): void;
+    /**
+     * Runs a get request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    get(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a delete request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    delete(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a post request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    post(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a put request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    put(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a patch request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    patch(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a request from the api
+     *
+     * @param options - Request options
+     */
+    request(options: InternalRequest): Promise<unknown>;
+    /**
+     * Runs a request from the API, yielding the raw Response object
+     *
+     * @param options - Request options
+     */
+    raw(options: InternalRequest): Promise<Dispatcher.ResponseData>;
     /**
      * Generates route data for an endpoint:method
      *
@@ -867,4 +834,4 @@ declare function parseResponse(res: Dispatcher.ResponseData): Promise<unknown>;
  */
 declare const version: string;
 
-export { ALLOWED_EXTENSIONS, ALLOWED_SIZES, ALLOWED_STICKER_EXTENSIONS, APIRequest, BaseImageURLOptions, CDN, DefaultRestOptions, DefaultUserAgent, DiscordAPIError, DiscordErrorData, HTTPError, HandlerRequestData, HashData, ImageExtension, ImageSize, ImageURLOptions, InternalRequest, InvalidRequestWarningData, MakeURLOptions, OAuthErrorData, OverwrittenMimeTypes, REST, RESTEvents, RESTOptions, RateLimitData, RateLimitError, RateLimitQueueFilter, RawFile, RequestBody, RequestData, RequestHeaders, RequestManager, RequestMethod, RequestOptions, RestEvents, RouteData, RouteLike, StickerExtension, makeURLSearchParams, parseResponse, version };
+export { ALLOWED_EXTENSIONS, ALLOWED_SIZES, ALLOWED_STICKER_EXTENSIONS, APIRequest, BaseImageURLOptions, BurstHandlerMajorIdKey, CDN, DefaultRestOptions, DefaultUserAgent, DiscordAPIError, DiscordErrorData, HTTPError, HandlerRequestData, HashData, ImageExtension, ImageSize, ImageURLOptions, InternalRequest, InvalidRequestWarningData, MakeURLOptions, OAuthErrorData, OverwrittenMimeTypes, REST, RESTEvents, RESTOptions, RateLimitData, RateLimitError, RateLimitQueueFilter, RawFile, RequestBody, RequestData, RequestHeaders, RequestMethod, RequestOptions, RestEvents, RouteData, RouteLike, StickerExtension, makeURLSearchParams, parseResponse, version };
diff --git a/dist/index.js b/dist/index.js
index 636001cf3ce775be69cb2d52ad20e04cfa3189b6..701d76193c446210457969094b1e5d81b5a7cf64 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -34,6 +34,7 @@ __export(src_exports, {
   ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
   ALLOWED_SIZES: () => ALLOWED_SIZES,
   ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
   CDN: () => CDN,
   DefaultRestOptions: () => DefaultRestOptions,
   DefaultUserAgent: () => DefaultUserAgent,
@@ -43,7 +44,6 @@ __export(src_exports, {
   REST: () => REST,
   RESTEvents: () => RESTEvents,
   RateLimitError: () => RateLimitError,
-  RequestManager: () => RequestManager,
   RequestMethod: () => RequestMethod,
   makeURLSearchParams: () => makeURLSearchParams,
   parseResponse: () => parseResponse,
@@ -102,6 +102,7 @@ var OverwrittenMimeTypes = {
   // https://github.com/discordjs/discord.js/issues/8557
   "image/apng": "image/png"
 };
+var BurstHandlerMajorIdKey = "burst";
 
 // src/lib/CDN.ts
 var CDN = class {
@@ -428,7 +429,7 @@ var RateLimitError = class extends Error {
 };
 __name(RateLimitError, "RateLimitError");
 
-// src/lib/RequestManager.ts
+// src/lib/REST.ts
 var import_node_buffer2 = require("buffer");
 var import_node_events = require("events");
 var import_node_timers2 = require("timers");
@@ -437,11 +438,8 @@ var import_util = require("@discordjs/util");
 var import_snowflake = require("@sapphire/snowflake");
 var import_undici4 = require("undici");
 
-// src/lib/handlers/SequentialHandler.ts
-var import_node_timers = require("timers");
+// src/lib/handlers/BurstHandler.ts
 var import_promises = require("timers/promises");
-var import_async_queue = require("@sapphire/async-queue");
-var import_undici3 = require("undici");
 
 // src/lib/utils/utils.ts
 var import_node_buffer = require("buffer");
@@ -552,10 +550,199 @@ function shouldRetry(error) {
   return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
 }
 __name(shouldRetry, "shouldRetry");
+async function onRateLimit(manager, rateLimitData) {
+  const { options } = manager;
+  if (!options.rejectOnRateLimit)
+    return;
+  const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
+  if (shouldThrow) {
+    throw new RateLimitError(rateLimitData);
+  }
+}
+__name(onRateLimit, "onRateLimit");
 
-// src/lib/handlers/SequentialHandler.ts
+// src/lib/handlers/Shared.ts
+var import_node_timers = require("timers");
+var import_undici3 = require("undici");
 var invalidCount = 0;
 var invalidCountResetTime = null;
+function incrementInvalidCount(manager) {
+  if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
+    invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
+    invalidCount = 0;
+  }
+  invalidCount++;
+  const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
+  if (emitInvalid) {
+    manager.emit("invalidRequestWarning" /* InvalidRequestWarning */, {
+      count: invalidCount,
+      remainingTime: invalidCountResetTime - Date.now()
+    });
+  }
+}
+__name(incrementInvalidCount, "incrementInvalidCount");
+async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
+  const controller = new AbortController();
+  const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), manager.options.timeout);
+  if (requestData.signal) {
+    const signal = requestData.signal;
+    if (signal.aborted)
+      controller.abort();
+    else
+      signal.addEventListener("abort", () => controller.abort());
+  }
+  let res;
+  try {
+    res = await (0, import_undici3.request)(url, { ...options, signal: controller.signal });
+  } catch (error) {
+    if (!(error instanceof Error))
+      throw error;
+    if (shouldRetry(error) && retries !== manager.options.retries) {
+      return null;
+    }
+    throw error;
+  } finally {
+    (0, import_node_timers.clearTimeout)(timeout);
+  }
+  if (manager.listenerCount("response" /* Response */)) {
+    manager.emit(
+      "response" /* Response */,
+      {
+        method: options.method ?? "GET" /* Get */,
+        path: routeId.original,
+        route: routeId.bucketRoute,
+        options,
+        data: requestData,
+        retries
+      },
+      { ...res }
+    );
+  }
+  return res;
+}
+__name(makeNetworkRequest, "makeNetworkRequest");
+async function handleErrors(manager, res, method, url, requestData, retries) {
+  const status = res.statusCode;
+  if (status >= 500 && status < 600) {
+    if (retries !== manager.options.retries) {
+      return null;
+    }
+    throw new HTTPError(status, method, url, requestData);
+  } else {
+    if (status >= 400 && status < 500) {
+      if (status === 401 && requestData.auth) {
+        manager.setToken(null);
+      }
+      const data = await parseResponse(res);
+      throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
+    }
+    return res;
+  }
+}
+__name(handleErrors, "handleErrors");
+
+// src/lib/handlers/BurstHandler.ts
+var BurstHandler = class {
+  /**
+   * @param manager - The request manager
+   * @param hash - The hash that this RequestHandler handles
+   * @param majorParameter - The major parameter for this handler
+   */
+  constructor(manager, hash, majorParameter) {
+    this.manager = manager;
+    this.hash = hash;
+    this.majorParameter = majorParameter;
+    this.id = `${hash}:${majorParameter}`;
+  }
+  /**
+   * {@inheritdoc IHandler.id}
+   */
+  id;
+  /**
+   * {@inheritDoc IHandler.inactive}
+   */
+  inactive = false;
+  /**
+   * Emits a debug message
+   *
+   * @param message - The message to debug
+   */
+  debug(message) {
+    this.manager.emit("restDebug" /* Debug */, `[REST ${this.id}] ${message}`);
+  }
+  /**
+   * {@inheritDoc IHandler.queueRequest}
+   */
+  async queueRequest(routeId, url, options, requestData) {
+    return this.runRequest(routeId, url, options, requestData);
+  }
+  /**
+   * The method that actually makes the request to the API, and updates info about the bucket accordingly
+   *
+   * @param routeId - The generalized API route with literal ids for major parameters
+   * @param url - The fully resolved URL to make the request to
+   * @param options - The fetch options needed to make the request
+   * @param requestData - Extra data from the user's request needed for errors and additional processing
+   * @param retries - The number of retries this request has already attempted (recursion)
+   */
+  async runRequest(routeId, url, options, requestData, retries = 0) {
+    const method = options.method ?? "GET" /* Get */;
+    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
+    if (res === null) {
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
+    }
+    const status = res.statusCode;
+    let retryAfter = 0;
+    const retry = parseHeader(res.headers["retry-after"]);
+    if (retry)
+      retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
+    if (status === 401 || status === 403 || status === 429) {
+      incrementInvalidCount(this.manager);
+    }
+    if (status >= 200 && status < 300) {
+      return res;
+    } else if (status === 429) {
+      const isGlobal = res.headers["x-ratelimit-global"] !== void 0;
+      await onRateLimit(this.manager, {
+        timeToReset: retryAfter,
+        limit: Number.POSITIVE_INFINITY,
+        method,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      });
+      this.debug(
+        [
+          "Encountered unexpected 429 rate limit",
+          `  Global         : ${isGlobal}`,
+          `  Method         : ${method}`,
+          `  URL            : ${url}`,
+          `  Bucket         : ${routeId.bucketRoute}`,
+          `  Major parameter: ${routeId.majorParameter}`,
+          `  Hash           : ${this.hash}`,
+          `  Limit          : ${Number.POSITIVE_INFINITY}`,
+          `  Retry After    : ${retryAfter}ms`,
+          `  Sublimit       : None`
+        ].join("\n")
+      );
+      await (0, import_promises.setTimeout)(retryAfter);
+      return this.runRequest(routeId, url, options, requestData, retries);
+    } else {
+      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
+      if (handled === null) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      return handled;
+    }
+  }
+};
+__name(BurstHandler, "BurstHandler");
+
+// src/lib/handlers/SequentialHandler.ts
+var import_promises2 = require("timers/promises");
+var import_async_queue = require("@sapphire/async-queue");
 var SequentialHandler = class {
   /**
    * @param manager - The request manager
@@ -644,21 +831,9 @@ var SequentialHandler = class {
    * @param time - The amount of time to delay all requests for
    */
   async globalDelayFor(time) {
-    await (0, import_promises.setTimeout)(time);
+    await (0, import_promises2.setTimeout)(time);
     this.manager.globalDelay = null;
   }
-  /*
-   * Determines whether the request should be queued or whether a RateLimitError should be thrown
-   */
-  async onRateLimit(rateLimitData) {
-    const { options } = this.manager;
-    if (!options.rejectOnRateLimit)
-      return;
-    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
-    if (shouldThrow) {
-      throw new RateLimitError(rateLimitData);
-    }
-  }
   /**
    * {@inheritDoc IHandler.queueRequest}
    */
@@ -707,24 +882,24 @@ var SequentialHandler = class {
     while (this.limited) {
       const isGlobal = this.globalLimited;
       let limit2;
-      let timeout2;
+      let timeout;
       let delay;
       if (isGlobal) {
         limit2 = this.manager.options.globalRequestsPerSecond;
-        timeout2 = this.manager.globalReset + this.manager.options.offset - Date.now();
+        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
         if (!this.manager.globalDelay) {
-          this.manager.globalDelay = this.globalDelayFor(timeout2);
+          this.manager.globalDelay = this.globalDelayFor(timeout);
         }
         delay = this.manager.globalDelay;
       } else {
         limit2 = this.limit;
-        timeout2 = this.timeToReset;
-        delay = (0, import_promises.setTimeout)(timeout2);
+        timeout = this.timeToReset;
+        delay = (0, import_promises2.setTimeout)(timeout);
       }
       const rateLimitData = {
-        timeToReset: timeout2,
+        timeToReset: timeout,
         limit: limit2,
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         hash: this.hash,
         url,
         route: routeId.bucketRoute,
@@ -732,11 +907,11 @@ var SequentialHandler = class {
         global: isGlobal
       };
       this.manager.emit("rateLimited" /* RateLimited */, rateLimitData);
-      await this.onRateLimit(rateLimitData);
+      await onRateLimit(this.manager, rateLimitData);
       if (isGlobal) {
-        this.debug(`Global rate limit hit, blocking all requests for ${timeout2}ms`);
+        this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
       } else {
-        this.debug(`Waiting ${timeout2}ms for rate limit to pass`);
+        this.debug(`Waiting ${timeout}ms for rate limit to pass`);
       }
       await delay;
     }
@@ -745,42 +920,10 @@ var SequentialHandler = class {
       this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
     }
     this.manager.globalRemaining--;
-    const method = options.method ?? "get";
-    const controller = new AbortController();
-    const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), this.manager.options.timeout).unref();
-    if (requestData.signal) {
-      const signal = requestData.signal;
-      if (signal.aborted)
-        controller.abort();
-      else
-        signal.addEventListener("abort", () => controller.abort());
-    }
-    let res;
-    try {
-      res = await (0, import_undici3.request)(url, { ...options, signal: controller.signal });
-    } catch (error) {
-      if (!(error instanceof Error))
-        throw error;
-      if (shouldRetry(error) && retries !== this.manager.options.retries) {
-        return await this.runRequest(routeId, url, options, requestData, ++retries);
-      }
-      throw error;
-    } finally {
-      (0, import_node_timers.clearTimeout)(timeout);
-    }
-    if (this.manager.listenerCount("response" /* Response */)) {
-      this.manager.emit(
-        "response" /* Response */,
-        {
-          method,
-          path: routeId.original,
-          route: routeId.bucketRoute,
-          options,
-          data: requestData,
-          retries
-        },
-        { ...res }
-      );
+    const method = options.method ?? "GET" /* Get */;
+    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
+    if (res === null) {
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.statusCode;
     let retryAfter = 0;
@@ -813,34 +956,23 @@ var SequentialHandler = class {
       }
     }
     if (status === 401 || status === 403 || status === 429) {
-      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
-        invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
-        invalidCount = 0;
-      }
-      invalidCount++;
-      const emitInvalid = this.manager.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.options.invalidRequestWarningInterval === 0;
-      if (emitInvalid) {
-        this.manager.emit("invalidRequestWarning" /* InvalidRequestWarning */, {
-          count: invalidCount,
-          remainingTime: invalidCountResetTime - Date.now()
-        });
-      }
+      incrementInvalidCount(this.manager);
     }
     if (status >= 200 && status < 300) {
       return res;
     } else if (status === 429) {
       const isGlobal = this.globalLimited;
       let limit2;
-      let timeout2;
+      let timeout;
       if (isGlobal) {
         limit2 = this.manager.options.globalRequestsPerSecond;
-        timeout2 = this.manager.globalReset + this.manager.options.offset - Date.now();
+        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
       } else {
         limit2 = this.limit;
-        timeout2 = this.timeToReset;
+        timeout = this.timeToReset;
       }
-      await this.onRateLimit({
-        timeToReset: timeout2,
+      await onRateLimit(this.manager, {
+        timeToReset: timeout,
         limit: limit2,
         method,
         hash: this.hash,
@@ -872,7 +1004,7 @@ var SequentialHandler = class {
         }
         this.#sublimitPromise?.resolve();
         this.#sublimitPromise = null;
-        await (0, import_promises.setTimeout)(sublimitTimeout);
+        await (0, import_promises2.setTimeout)(sublimitTimeout);
         let resolve;
         const promise = new Promise((res2) => resolve = res2);
         this.#sublimitPromise = { promise, resolve };
@@ -882,26 +1014,18 @@ var SequentialHandler = class {
         }
       }
       return this.runRequest(routeId, url, options, requestData, retries);
-    } else if (status >= 500 && status < 600) {
-      if (retries !== this.manager.options.retries) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
-      }
-      throw new HTTPError(status, method, url, requestData);
     } else {
-      if (status >= 400 && status < 500) {
-        if (status === 401 && requestData.auth) {
-          this.manager.setToken(null);
-        }
-        const data = await parseResponse(res);
-        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
+      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
+      if (handled === null) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
-      return res;
+      return handled;
     }
   }
 };
 __name(SequentialHandler, "SequentialHandler");
 
-// src/lib/RequestManager.ts
+// src/lib/REST.ts
 var getFileType = (0, import_util.lazy)(async () => import("file-type"));
 var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Delete"] = "DELETE";
@@ -911,7 +1035,7 @@ var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Put"] = "PUT";
   return RequestMethod2;
 })(RequestMethod || {});
-var RequestManager = class extends import_node_events.EventEmitter {
+var REST = class extends import_node_events.EventEmitter {
   /**
    * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
    * performed by this manager.
@@ -941,12 +1065,16 @@ var RequestManager = class extends import_node_events.EventEmitter {
   hashTimer;
   handlerTimer;
   options;
+  cdn;
+  userAgent;
   constructor(options) {
     super();
     this.options = { ...DefaultRestOptions, ...options };
     this.options.offset = Math.max(0, this.options.offset);
+    this.userAgent = `${DefaultUserAgent} ${this.options.userAgentAppendix}`.trimEnd();
+    this.cdn = new CDN(this.options.cdn);
     this.globalRemaining = this.options.globalRequestsPerSecond;
-    this.agent = options.agent ?? null;
+    this.agent = options?.agent ?? null;
     this.setupSweepers();
   }
   setupSweepers() {
@@ -971,7 +1099,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
           return shouldSweep;
         });
         this.emit("hashSweep" /* HashSweep */, sweptHashes);
-      }, this.options.hashSweepInterval).unref();
+      }, this.options.hashSweepInterval);
     }
     if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.handlerSweepInterval);
@@ -981,12 +1109,12 @@ var RequestManager = class extends import_node_events.EventEmitter {
           const { inactive } = val;
           if (inactive) {
             sweptHandlers.set(key, val);
+            this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
           }
-          this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
           return inactive;
         });
         this.emit("handlerSweep" /* HandlerSweep */, sweptHandlers);
-      }, this.options.handlerSweepInterval).unref();
+      }, this.options.handlerSweepInterval);
     }
   }
   /**
@@ -1007,27 +1135,6 @@ var RequestManager = class extends import_node_events.EventEmitter {
     this.#token = token;
     return this;
   }
-  /**
-   * Queues a request to be sent
-   *
-   * @param request - All the information needed to make a request
-   * @returns The response from the api request
-   */
-  async queueRequest(request2) {
-    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
-    const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
-      value: `Global(${request2.method}:${routeId.bucketRoute})`,
-      lastAccess: -1
-    };
-    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
-    const { url, fetchOptions } = await this.resolveRequest(request2);
-    return handler.queueRequest(routeId, url, fetchOptions, {
-      body: request2.body,
-      files: request2.files,
-      auth: request2.auth !== false,
-      signal: request2.signal
-    });
-  }
   /**
    * Creates a new rate limit handler from a hash, based on the hash and the major parameter
    *
@@ -1036,7 +1143,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
    * @internal
    */
   createHandler(hash, majorParameter) {
-    const queue = new SequentialHandler(this, hash, majorParameter);
+    const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
     this.handlers.set(queue.id, queue);
     return queue;
   }
@@ -1056,7 +1163,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
     }
     const headers = {
       ...this.options.headers,
-      "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
+      "User-Agent": this.userAgent
     };
     if (request2.auth !== false) {
       if (!this.#token) {
@@ -1129,83 +1236,13 @@ var RequestManager = class extends import_node_events.EventEmitter {
   clearHandlerSweeper() {
     (0, import_node_timers2.clearInterval)(this.handlerTimer);
   }
-  /**
-   * Generates route data for an endpoint:method
-   *
-   * @param endpoint - The raw endpoint to generalize
-   * @param method - The HTTP method this endpoint is called without
-   * @internal
-   */
-  static generateRouteData(endpoint, method) {
-    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
-    const majorId = majorIdMatch?.[1] ?? "global";
-    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
-    let exceptions = "";
-    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
-      const id = /\d{17,19}$/.exec(endpoint)[0];
-      const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
-      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
-        exceptions += "/Delete Old Message";
-      }
-    }
-    return {
-      majorParameter: majorId,
-      bucketRoute: baseRoute + exceptions,
-      original: endpoint
-    };
-  }
-};
-__name(RequestManager, "RequestManager");
-
-// src/lib/REST.ts
-var import_node_events2 = require("events");
-var REST = class extends import_node_events2.EventEmitter {
-  cdn;
-  requestManager;
-  constructor(options = {}) {
-    super();
-    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
-    this.requestManager = new RequestManager(options).on("restDebug" /* Debug */, this.emit.bind(this, "restDebug" /* Debug */)).on("rateLimited" /* RateLimited */, this.emit.bind(this, "rateLimited" /* RateLimited */)).on("invalidRequestWarning" /* InvalidRequestWarning */, this.emit.bind(this, "invalidRequestWarning" /* InvalidRequestWarning */)).on("hashSweep" /* HashSweep */, this.emit.bind(this, "hashSweep" /* HashSweep */));
-    this.on("newListener", (name, listener) => {
-      if (name === "response" /* Response */)
-        this.requestManager.on(name, listener);
-    });
-    this.on("removeListener", (name, listener) => {
-      if (name === "response" /* Response */)
-        this.requestManager.off(name, listener);
-    });
-  }
-  /**
-   * Gets the agent set for this instance
-   */
-  getAgent() {
-    return this.requestManager.agent;
-  }
-  /**
-   * Sets the default agent to use for requests performed by this instance
-   *
-   * @param agent - Sets the agent to use
-   */
-  setAgent(agent) {
-    this.requestManager.setAgent(agent);
-    return this;
-  }
-  /**
-   * Sets the authorization token that should be used for requests
-   *
-   * @param token - The authorization token to use
-   */
-  setToken(token) {
-    this.requestManager.setToken(token);
-    return this;
-  }
   /**
    * Runs a get request from the api
    *
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async get(fullRoute, options = {}) {
+  async get(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "GET" /* Get */ });
   }
   /**
@@ -1214,7 +1251,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async delete(fullRoute, options = {}) {
+  async delete(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "DELETE" /* Delete */ });
   }
   /**
@@ -1223,7 +1260,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async post(fullRoute, options = {}) {
+  async post(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "POST" /* Post */ });
   }
   /**
@@ -1232,7 +1269,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async put(fullRoute, options = {}) {
+  async put(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PUT" /* Put */ });
   }
   /**
@@ -1241,7 +1278,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async patch(fullRoute, options = {}) {
+  async patch(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PATCH" /* Patch */ });
   }
   /**
@@ -1259,7 +1296,51 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param options - Request options
    */
   async raw(options) {
-    return this.requestManager.queueRequest(options);
+    const routeId = REST.generateRouteData(options.fullRoute, options.method);
+    const hash = this.hashes.get(`${options.method}:${routeId.bucketRoute}`) ?? {
+      value: `Global(${options.method}:${routeId.bucketRoute})`,
+      lastAccess: -1
+    };
+    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
+    const { url, fetchOptions } = await this.resolveRequest(options);
+    return handler.queueRequest(routeId, url, fetchOptions, {
+      body: options.body,
+      files: options.files,
+      auth: options.auth !== false,
+      signal: options.signal
+    });
+  }
+  /**
+   * Generates route data for an endpoint:method
+   *
+   * @param endpoint - The raw endpoint to generalize
+   * @param method - The HTTP method this endpoint is called without
+   * @internal
+   */
+  static generateRouteData(endpoint, method) {
+    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
+      return {
+        majorParameter: BurstHandlerMajorIdKey,
+        bucketRoute: "/interactions/:id/:token/callback",
+        original: endpoint
+      };
+    }
+    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
+    const majorId = majorIdMatch?.[1] ?? "global";
+    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
+    let exceptions = "";
+    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
+      const id = /\d{17,19}$/.exec(endpoint)[0];
+      const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
+      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
+        exceptions += "/Delete Old Message";
+      }
+    }
+    return {
+      majorParameter: majorId,
+      bucketRoute: baseRoute + exceptions,
+      original: endpoint
+    };
   }
 };
 __name(REST, "REST");
@@ -1271,6 +1352,7 @@ var version = "1.6.1-dev.1679659480-5fcd0e4.0";
   ALLOWED_EXTENSIONS,
   ALLOWED_SIZES,
   ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey,
   CDN,
   DefaultRestOptions,
   DefaultUserAgent,
@@ -1280,7 +1362,6 @@ var version = "1.6.1-dev.1679659480-5fcd0e4.0";
   REST,
   RESTEvents,
   RateLimitError,
-  RequestManager,
   RequestMethod,
   makeURLSearchParams,
   parseResponse,
diff --git a/dist/index.mjs b/dist/index.mjs
index a28a1b2e5825b55ff84808f9145560695477d022..766af669080b015751e9a226c2507f78e30604cb 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -52,6 +52,7 @@ var OverwrittenMimeTypes = {
   // https://github.com/discordjs/discord.js/issues/8557
   "image/apng": "image/png"
 };
+var BurstHandlerMajorIdKey = "burst";
 
 // src/lib/CDN.ts
 var CDN = class {
@@ -378,7 +379,7 @@ var RateLimitError = class extends Error {
 };
 __name(RateLimitError, "RateLimitError");
 
-// src/lib/RequestManager.ts
+// src/lib/REST.ts
 import { Blob as Blob2, Buffer as Buffer3 } from "node:buffer";
 import { EventEmitter } from "node:events";
 import { setInterval, clearInterval } from "node:timers";
@@ -387,11 +388,8 @@ import { lazy } from "@discordjs/util";
 import { DiscordSnowflake } from "@sapphire/snowflake";
 import { FormData as FormData2 } from "undici";
 
-// src/lib/handlers/SequentialHandler.ts
-import { setTimeout, clearTimeout } from "node:timers";
+// src/lib/handlers/BurstHandler.ts
 import { setTimeout as sleep } from "node:timers/promises";
-import { AsyncQueue } from "@sapphire/async-queue";
-import { request } from "undici";
 
 // src/lib/utils/utils.ts
 import { Blob, Buffer as Buffer2 } from "node:buffer";
@@ -502,10 +500,199 @@ function shouldRetry(error) {
   return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
 }
 __name(shouldRetry, "shouldRetry");
+async function onRateLimit(manager, rateLimitData) {
+  const { options } = manager;
+  if (!options.rejectOnRateLimit)
+    return;
+  const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
+  if (shouldThrow) {
+    throw new RateLimitError(rateLimitData);
+  }
+}
+__name(onRateLimit, "onRateLimit");
 
-// src/lib/handlers/SequentialHandler.ts
+// src/lib/handlers/Shared.ts
+import { setTimeout, clearTimeout } from "node:timers";
+import { request } from "undici";
 var invalidCount = 0;
 var invalidCountResetTime = null;
+function incrementInvalidCount(manager) {
+  if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
+    invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
+    invalidCount = 0;
+  }
+  invalidCount++;
+  const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
+  if (emitInvalid) {
+    manager.emit("invalidRequestWarning" /* InvalidRequestWarning */, {
+      count: invalidCount,
+      remainingTime: invalidCountResetTime - Date.now()
+    });
+  }
+}
+__name(incrementInvalidCount, "incrementInvalidCount");
+async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
+  const controller = new AbortController();
+  const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
+  if (requestData.signal) {
+    const signal = requestData.signal;
+    if (signal.aborted)
+      controller.abort();
+    else
+      signal.addEventListener("abort", () => controller.abort());
+  }
+  let res;
+  try {
+    res = await request(url, { ...options, signal: controller.signal });
+  } catch (error) {
+    if (!(error instanceof Error))
+      throw error;
+    if (shouldRetry(error) && retries !== manager.options.retries) {
+      return null;
+    }
+    throw error;
+  } finally {
+    clearTimeout(timeout);
+  }
+  if (manager.listenerCount("response" /* Response */)) {
+    manager.emit(
+      "response" /* Response */,
+      {
+        method: options.method ?? "GET" /* Get */,
+        path: routeId.original,
+        route: routeId.bucketRoute,
+        options,
+        data: requestData,
+        retries
+      },
+      { ...res }
+    );
+  }
+  return res;
+}
+__name(makeNetworkRequest, "makeNetworkRequest");
+async function handleErrors(manager, res, method, url, requestData, retries) {
+  const status = res.statusCode;
+  if (status >= 500 && status < 600) {
+    if (retries !== manager.options.retries) {
+      return null;
+    }
+    throw new HTTPError(status, method, url, requestData);
+  } else {
+    if (status >= 400 && status < 500) {
+      if (status === 401 && requestData.auth) {
+        manager.setToken(null);
+      }
+      const data = await parseResponse(res);
+      throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
+    }
+    return res;
+  }
+}
+__name(handleErrors, "handleErrors");
+
+// src/lib/handlers/BurstHandler.ts
+var BurstHandler = class {
+  /**
+   * @param manager - The request manager
+   * @param hash - The hash that this RequestHandler handles
+   * @param majorParameter - The major parameter for this handler
+   */
+  constructor(manager, hash, majorParameter) {
+    this.manager = manager;
+    this.hash = hash;
+    this.majorParameter = majorParameter;
+    this.id = `${hash}:${majorParameter}`;
+  }
+  /**
+   * {@inheritdoc IHandler.id}
+   */
+  id;
+  /**
+   * {@inheritDoc IHandler.inactive}
+   */
+  inactive = false;
+  /**
+   * Emits a debug message
+   *
+   * @param message - The message to debug
+   */
+  debug(message) {
+    this.manager.emit("restDebug" /* Debug */, `[REST ${this.id}] ${message}`);
+  }
+  /**
+   * {@inheritDoc IHandler.queueRequest}
+   */
+  async queueRequest(routeId, url, options, requestData) {
+    return this.runRequest(routeId, url, options, requestData);
+  }
+  /**
+   * The method that actually makes the request to the API, and updates info about the bucket accordingly
+   *
+   * @param routeId - The generalized API route with literal ids for major parameters
+   * @param url - The fully resolved URL to make the request to
+   * @param options - The fetch options needed to make the request
+   * @param requestData - Extra data from the user's request needed for errors and additional processing
+   * @param retries - The number of retries this request has already attempted (recursion)
+   */
+  async runRequest(routeId, url, options, requestData, retries = 0) {
+    const method = options.method ?? "GET" /* Get */;
+    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
+    if (res === null) {
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
+    }
+    const status = res.statusCode;
+    let retryAfter = 0;
+    const retry = parseHeader(res.headers["retry-after"]);
+    if (retry)
+      retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
+    if (status === 401 || status === 403 || status === 429) {
+      incrementInvalidCount(this.manager);
+    }
+    if (status >= 200 && status < 300) {
+      return res;
+    } else if (status === 429) {
+      const isGlobal = res.headers["x-ratelimit-global"] !== void 0;
+      await onRateLimit(this.manager, {
+        timeToReset: retryAfter,
+        limit: Number.POSITIVE_INFINITY,
+        method,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      });
+      this.debug(
+        [
+          "Encountered unexpected 429 rate limit",
+          `  Global         : ${isGlobal}`,
+          `  Method         : ${method}`,
+          `  URL            : ${url}`,
+          `  Bucket         : ${routeId.bucketRoute}`,
+          `  Major parameter: ${routeId.majorParameter}`,
+          `  Hash           : ${this.hash}`,
+          `  Limit          : ${Number.POSITIVE_INFINITY}`,
+          `  Retry After    : ${retryAfter}ms`,
+          `  Sublimit       : None`
+        ].join("\n")
+      );
+      await sleep(retryAfter);
+      return this.runRequest(routeId, url, options, requestData, retries);
+    } else {
+      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
+      if (handled === null) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      return handled;
+    }
+  }
+};
+__name(BurstHandler, "BurstHandler");
+
+// src/lib/handlers/SequentialHandler.ts
+import { setTimeout as sleep2 } from "node:timers/promises";
+import { AsyncQueue } from "@sapphire/async-queue";
 var SequentialHandler = class {
   /**
    * @param manager - The request manager
@@ -594,21 +781,9 @@ var SequentialHandler = class {
    * @param time - The amount of time to delay all requests for
    */
   async globalDelayFor(time) {
-    await sleep(time);
+    await sleep2(time);
     this.manager.globalDelay = null;
   }
-  /*
-   * Determines whether the request should be queued or whether a RateLimitError should be thrown
-   */
-  async onRateLimit(rateLimitData) {
-    const { options } = this.manager;
-    if (!options.rejectOnRateLimit)
-      return;
-    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
-    if (shouldThrow) {
-      throw new RateLimitError(rateLimitData);
-    }
-  }
   /**
    * {@inheritDoc IHandler.queueRequest}
    */
@@ -657,24 +832,24 @@ var SequentialHandler = class {
     while (this.limited) {
       const isGlobal = this.globalLimited;
       let limit2;
-      let timeout2;
+      let timeout;
       let delay;
       if (isGlobal) {
         limit2 = this.manager.options.globalRequestsPerSecond;
-        timeout2 = this.manager.globalReset + this.manager.options.offset - Date.now();
+        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
         if (!this.manager.globalDelay) {
-          this.manager.globalDelay = this.globalDelayFor(timeout2);
+          this.manager.globalDelay = this.globalDelayFor(timeout);
         }
         delay = this.manager.globalDelay;
       } else {
         limit2 = this.limit;
-        timeout2 = this.timeToReset;
-        delay = sleep(timeout2);
+        timeout = this.timeToReset;
+        delay = sleep2(timeout);
       }
       const rateLimitData = {
-        timeToReset: timeout2,
+        timeToReset: timeout,
         limit: limit2,
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         hash: this.hash,
         url,
         route: routeId.bucketRoute,
@@ -682,11 +857,11 @@ var SequentialHandler = class {
         global: isGlobal
       };
       this.manager.emit("rateLimited" /* RateLimited */, rateLimitData);
-      await this.onRateLimit(rateLimitData);
+      await onRateLimit(this.manager, rateLimitData);
       if (isGlobal) {
-        this.debug(`Global rate limit hit, blocking all requests for ${timeout2}ms`);
+        this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
       } else {
-        this.debug(`Waiting ${timeout2}ms for rate limit to pass`);
+        this.debug(`Waiting ${timeout}ms for rate limit to pass`);
       }
       await delay;
     }
@@ -695,42 +870,10 @@ var SequentialHandler = class {
       this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
     }
     this.manager.globalRemaining--;
-    const method = options.method ?? "get";
-    const controller = new AbortController();
-    const timeout = setTimeout(() => controller.abort(), this.manager.options.timeout).unref();
-    if (requestData.signal) {
-      const signal = requestData.signal;
-      if (signal.aborted)
-        controller.abort();
-      else
-        signal.addEventListener("abort", () => controller.abort());
-    }
-    let res;
-    try {
-      res = await request(url, { ...options, signal: controller.signal });
-    } catch (error) {
-      if (!(error instanceof Error))
-        throw error;
-      if (shouldRetry(error) && retries !== this.manager.options.retries) {
-        return await this.runRequest(routeId, url, options, requestData, ++retries);
-      }
-      throw error;
-    } finally {
-      clearTimeout(timeout);
-    }
-    if (this.manager.listenerCount("response" /* Response */)) {
-      this.manager.emit(
-        "response" /* Response */,
-        {
-          method,
-          path: routeId.original,
-          route: routeId.bucketRoute,
-          options,
-          data: requestData,
-          retries
-        },
-        { ...res }
-      );
+    const method = options.method ?? "GET" /* Get */;
+    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
+    if (res === null) {
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.statusCode;
     let retryAfter = 0;
@@ -763,34 +906,23 @@ var SequentialHandler = class {
       }
     }
     if (status === 401 || status === 403 || status === 429) {
-      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
-        invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
-        invalidCount = 0;
-      }
-      invalidCount++;
-      const emitInvalid = this.manager.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.options.invalidRequestWarningInterval === 0;
-      if (emitInvalid) {
-        this.manager.emit("invalidRequestWarning" /* InvalidRequestWarning */, {
-          count: invalidCount,
-          remainingTime: invalidCountResetTime - Date.now()
-        });
-      }
+      incrementInvalidCount(this.manager);
     }
     if (status >= 200 && status < 300) {
       return res;
     } else if (status === 429) {
       const isGlobal = this.globalLimited;
       let limit2;
-      let timeout2;
+      let timeout;
       if (isGlobal) {
         limit2 = this.manager.options.globalRequestsPerSecond;
-        timeout2 = this.manager.globalReset + this.manager.options.offset - Date.now();
+        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
       } else {
         limit2 = this.limit;
-        timeout2 = this.timeToReset;
+        timeout = this.timeToReset;
       }
-      await this.onRateLimit({
-        timeToReset: timeout2,
+      await onRateLimit(this.manager, {
+        timeToReset: timeout,
         limit: limit2,
         method,
         hash: this.hash,
@@ -822,7 +954,7 @@ var SequentialHandler = class {
         }
         this.#sublimitPromise?.resolve();
         this.#sublimitPromise = null;
-        await sleep(sublimitTimeout);
+        await sleep2(sublimitTimeout);
         let resolve;
         const promise = new Promise((res2) => resolve = res2);
         this.#sublimitPromise = { promise, resolve };
@@ -832,26 +964,18 @@ var SequentialHandler = class {
         }
       }
       return this.runRequest(routeId, url, options, requestData, retries);
-    } else if (status >= 500 && status < 600) {
-      if (retries !== this.manager.options.retries) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
-      }
-      throw new HTTPError(status, method, url, requestData);
     } else {
-      if (status >= 400 && status < 500) {
-        if (status === 401 && requestData.auth) {
-          this.manager.setToken(null);
-        }
-        const data = await parseResponse(res);
-        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
+      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
+      if (handled === null) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
-      return res;
+      return handled;
     }
   }
 };
 __name(SequentialHandler, "SequentialHandler");
 
-// src/lib/RequestManager.ts
+// src/lib/REST.ts
 var getFileType = lazy(async () => import("file-type"));
 var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Delete"] = "DELETE";
@@ -861,7 +985,7 @@ var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Put"] = "PUT";
   return RequestMethod2;
 })(RequestMethod || {});
-var RequestManager = class extends EventEmitter {
+var REST = class extends EventEmitter {
   /**
    * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
    * performed by this manager.
@@ -891,12 +1015,16 @@ var RequestManager = class extends EventEmitter {
   hashTimer;
   handlerTimer;
   options;
+  cdn;
+  userAgent;
   constructor(options) {
     super();
     this.options = { ...DefaultRestOptions, ...options };
     this.options.offset = Math.max(0, this.options.offset);
+    this.userAgent = `${DefaultUserAgent} ${this.options.userAgentAppendix}`.trimEnd();
+    this.cdn = new CDN(this.options.cdn);
     this.globalRemaining = this.options.globalRequestsPerSecond;
-    this.agent = options.agent ?? null;
+    this.agent = options?.agent ?? null;
     this.setupSweepers();
   }
   setupSweepers() {
@@ -921,7 +1049,7 @@ var RequestManager = class extends EventEmitter {
           return shouldSweep;
         });
         this.emit("hashSweep" /* HashSweep */, sweptHashes);
-      }, this.options.hashSweepInterval).unref();
+      }, this.options.hashSweepInterval);
     }
     if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.handlerSweepInterval);
@@ -931,12 +1059,12 @@ var RequestManager = class extends EventEmitter {
           const { inactive } = val;
           if (inactive) {
             sweptHandlers.set(key, val);
+            this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
           }
-          this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
           return inactive;
         });
         this.emit("handlerSweep" /* HandlerSweep */, sweptHandlers);
-      }, this.options.handlerSweepInterval).unref();
+      }, this.options.handlerSweepInterval);
     }
   }
   /**
@@ -957,27 +1085,6 @@ var RequestManager = class extends EventEmitter {
     this.#token = token;
     return this;
   }
-  /**
-   * Queues a request to be sent
-   *
-   * @param request - All the information needed to make a request
-   * @returns The response from the api request
-   */
-  async queueRequest(request2) {
-    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
-    const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
-      value: `Global(${request2.method}:${routeId.bucketRoute})`,
-      lastAccess: -1
-    };
-    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
-    const { url, fetchOptions } = await this.resolveRequest(request2);
-    return handler.queueRequest(routeId, url, fetchOptions, {
-      body: request2.body,
-      files: request2.files,
-      auth: request2.auth !== false,
-      signal: request2.signal
-    });
-  }
   /**
    * Creates a new rate limit handler from a hash, based on the hash and the major parameter
    *
@@ -986,7 +1093,7 @@ var RequestManager = class extends EventEmitter {
    * @internal
    */
   createHandler(hash, majorParameter) {
-    const queue = new SequentialHandler(this, hash, majorParameter);
+    const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
     this.handlers.set(queue.id, queue);
     return queue;
   }
@@ -1006,7 +1113,7 @@ var RequestManager = class extends EventEmitter {
     }
     const headers = {
       ...this.options.headers,
-      "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
+      "User-Agent": this.userAgent
     };
     if (request2.auth !== false) {
       if (!this.#token) {
@@ -1079,83 +1186,13 @@ var RequestManager = class extends EventEmitter {
   clearHandlerSweeper() {
     clearInterval(this.handlerTimer);
   }
-  /**
-   * Generates route data for an endpoint:method
-   *
-   * @param endpoint - The raw endpoint to generalize
-   * @param method - The HTTP method this endpoint is called without
-   * @internal
-   */
-  static generateRouteData(endpoint, method) {
-    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
-    const majorId = majorIdMatch?.[1] ?? "global";
-    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
-    let exceptions = "";
-    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
-      const id = /\d{17,19}$/.exec(endpoint)[0];
-      const timestamp = DiscordSnowflake.timestampFrom(id);
-      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
-        exceptions += "/Delete Old Message";
-      }
-    }
-    return {
-      majorParameter: majorId,
-      bucketRoute: baseRoute + exceptions,
-      original: endpoint
-    };
-  }
-};
-__name(RequestManager, "RequestManager");
-
-// src/lib/REST.ts
-import { EventEmitter as EventEmitter2 } from "node:events";
-var REST = class extends EventEmitter2 {
-  cdn;
-  requestManager;
-  constructor(options = {}) {
-    super();
-    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
-    this.requestManager = new RequestManager(options).on("restDebug" /* Debug */, this.emit.bind(this, "restDebug" /* Debug */)).on("rateLimited" /* RateLimited */, this.emit.bind(this, "rateLimited" /* RateLimited */)).on("invalidRequestWarning" /* InvalidRequestWarning */, this.emit.bind(this, "invalidRequestWarning" /* InvalidRequestWarning */)).on("hashSweep" /* HashSweep */, this.emit.bind(this, "hashSweep" /* HashSweep */));
-    this.on("newListener", (name, listener) => {
-      if (name === "response" /* Response */)
-        this.requestManager.on(name, listener);
-    });
-    this.on("removeListener", (name, listener) => {
-      if (name === "response" /* Response */)
-        this.requestManager.off(name, listener);
-    });
-  }
-  /**
-   * Gets the agent set for this instance
-   */
-  getAgent() {
-    return this.requestManager.agent;
-  }
-  /**
-   * Sets the default agent to use for requests performed by this instance
-   *
-   * @param agent - Sets the agent to use
-   */
-  setAgent(agent) {
-    this.requestManager.setAgent(agent);
-    return this;
-  }
-  /**
-   * Sets the authorization token that should be used for requests
-   *
-   * @param token - The authorization token to use
-   */
-  setToken(token) {
-    this.requestManager.setToken(token);
-    return this;
-  }
   /**
    * Runs a get request from the api
    *
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async get(fullRoute, options = {}) {
+  async get(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "GET" /* Get */ });
   }
   /**
@@ -1164,7 +1201,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async delete(fullRoute, options = {}) {
+  async delete(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "DELETE" /* Delete */ });
   }
   /**
@@ -1173,7 +1210,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async post(fullRoute, options = {}) {
+  async post(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "POST" /* Post */ });
   }
   /**
@@ -1182,7 +1219,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async put(fullRoute, options = {}) {
+  async put(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PUT" /* Put */ });
   }
   /**
@@ -1191,7 +1228,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async patch(fullRoute, options = {}) {
+  async patch(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PATCH" /* Patch */ });
   }
   /**
@@ -1209,7 +1246,51 @@ var REST = class extends EventEmitter2 {
    * @param options - Request options
    */
   async raw(options) {
-    return this.requestManager.queueRequest(options);
+    const routeId = REST.generateRouteData(options.fullRoute, options.method);
+    const hash = this.hashes.get(`${options.method}:${routeId.bucketRoute}`) ?? {
+      value: `Global(${options.method}:${routeId.bucketRoute})`,
+      lastAccess: -1
+    };
+    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
+    const { url, fetchOptions } = await this.resolveRequest(options);
+    return handler.queueRequest(routeId, url, fetchOptions, {
+      body: options.body,
+      files: options.files,
+      auth: options.auth !== false,
+      signal: options.signal
+    });
+  }
+  /**
+   * Generates route data for an endpoint:method
+   *
+   * @param endpoint - The raw endpoint to generalize
+   * @param method - The HTTP method this endpoint is called without
+   * @internal
+   */
+  static generateRouteData(endpoint, method) {
+    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
+      return {
+        majorParameter: BurstHandlerMajorIdKey,
+        bucketRoute: "/interactions/:id/:token/callback",
+        original: endpoint
+      };
+    }
+    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
+    const majorId = majorIdMatch?.[1] ?? "global";
+    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
+    let exceptions = "";
+    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
+      const id = /\d{17,19}$/.exec(endpoint)[0];
+      const timestamp = DiscordSnowflake.timestampFrom(id);
+      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
+        exceptions += "/Delete Old Message";
+      }
+    }
+    return {
+      majorParameter: majorId,
+      bucketRoute: baseRoute + exceptions,
+      original: endpoint
+    };
   }
 };
 __name(REST, "REST");
@@ -1220,6 +1301,7 @@ export {
   ALLOWED_EXTENSIONS,
   ALLOWED_SIZES,
   ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey,
   CDN,
   DefaultRestOptions,
   DefaultUserAgent,
@@ -1229,7 +1311,6 @@ export {
   REST,
   RESTEvents,
   RateLimitError,
-  RequestManager,
   RequestMethod,
   makeURLSearchParams,
   parseResponse,
