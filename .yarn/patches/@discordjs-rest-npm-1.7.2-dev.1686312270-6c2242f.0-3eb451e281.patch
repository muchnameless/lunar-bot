diff --git a/dist/CDN-71b60987.d.ts b/dist/CDN-71b60987.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4409db1b647d26d69b592ec7f79d6eb7f6513488
--- /dev/null
+++ b/dist/CDN-71b60987.d.ts
@@ -0,0 +1,750 @@
+import { Buffer } from 'node:buffer';
+import { EventEmitter } from 'node:events';
+import { Readable } from 'node:stream';
+import { ReadableStream } from 'node:stream/web';
+import { URLSearchParams } from 'node:url';
+import { Collection } from '@discordjs/collection';
+import * as undici from 'undici';
+import { RequestInit, BodyInit, Agent, Dispatcher, Response } from 'undici';
+
+interface IHandler {
+    /**
+     * The unique id of the handler
+     */
+    readonly id: string;
+    /**
+     * If the bucket is currently inactive (no pending requests)
+     */
+    get inactive(): boolean;
+    /**
+     * Queues a request to be sent
+     *
+     * @param routeId - The generalized api route with literal ids for major parameters
+     * @param url - The url to do the request on
+     * @param options - All the information needed to make a request
+     * @param requestData - Extra data from the user's request needed for errors and additional processing
+     */
+    queueRequest(routeId: RouteData, url: string, options: RequestInit, requestData: HandlerRequestData): Promise<ResponseLike>;
+}
+
+/**
+ * Represents a file to be added to the request
+ */
+interface RawFile {
+    /**
+     * Content-Type of the file
+     */
+    contentType?: string;
+    /**
+     * The actual data for the file
+     */
+    data: Buffer | boolean | number | string;
+    /**
+     * An explicit key to use for key of the formdata field for this file.
+     * When not provided, the index of the file in the files array is used in the form `files[${index}]`.
+     * If you wish to alter the placeholder snowflake, you must provide this property in the same form (`files[${placeholder}]`)
+     */
+    key?: string;
+    /**
+     * The name of the file
+     */
+    name: string;
+}
+/**
+ * Represents possible data to be given to an endpoint
+ */
+interface RequestData {
+    /**
+     * Whether to append JSON data to form data instead of `payload_json` when sending files
+     */
+    appendToFormData?: boolean;
+    /**
+     * If this request needs the `Authorization` header
+     *
+     * @defaultValue `true`
+     */
+    auth?: boolean;
+    /**
+     * The authorization prefix to use for this request, useful if you use this with bearer tokens
+     *
+     * @defaultValue `'Bot'`
+     */
+    authPrefix?: 'Bearer' | 'Bot';
+    /**
+     * The body to send to this request.
+     * If providing as BodyInit, set `passThroughBody: true`
+     */
+    body?: BodyInit | unknown;
+    /**
+     * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} to use for the request.
+     */
+    dispatcher?: Agent;
+    /**
+     * Files to be attached to this request
+     */
+    files?: RawFile[] | undefined;
+    /**
+     * Additional headers to add to this request
+     */
+    headers?: Record<string, string>;
+    /**
+     * Whether to pass-through the body property directly to `fetch()`.
+     * <warn>This only applies when files is NOT present</warn>
+     */
+    passThroughBody?: boolean;
+    /**
+     * Query string parameters to append to the called endpoint
+     */
+    query?: URLSearchParams;
+    /**
+     * Reason to show in the audit logs
+     */
+    reason?: string | undefined;
+    /**
+     * The signal to abort the queue entry or the REST call, where applicable
+     */
+    signal?: AbortSignal | undefined;
+    /**
+     * If this request should be versioned
+     *
+     * @defaultValue `true`
+     */
+    versioned?: boolean;
+}
+/**
+ * Possible headers for an API call
+ */
+interface RequestHeaders {
+    Authorization?: string;
+    'User-Agent': string;
+    'X-Audit-Log-Reason'?: string;
+}
+/**
+ * Possible API methods to be used when doing requests
+ */
+declare enum RequestMethod {
+    Delete = "DELETE",
+    Get = "GET",
+    Head = "HEAD",
+    Patch = "PATCH",
+    Post = "POST",
+    Put = "PUT"
+}
+type RouteLike = `/${string}`;
+/**
+ * Internal request options
+ *
+ * @internal
+ */
+interface InternalRequest extends RequestData {
+    fullRoute: RouteLike;
+    method: RequestMethod;
+}
+type HandlerRequestData = Pick<InternalRequest, 'auth' | 'body' | 'files' | 'signal'>;
+/**
+ * Parsed route data for an endpoint
+ *
+ * @internal
+ */
+interface RouteData {
+    bucketRoute: string;
+    majorParameter: string;
+    original: RouteLike;
+}
+/**
+ * Represents a hash and its associated fields
+ *
+ * @internal
+ */
+interface HashData {
+    lastAccess: number;
+    value: string;
+}
+/**
+ * Options to be passed when creating the REST instance
+ */
+interface RESTOptions {
+    /**
+     * The agent to set globally
+     */
+    agent: Dispatcher | null;
+    /**
+     * The base api path, without version
+     *
+     * @defaultValue `'https://discord.com/api'`
+     */
+    api: string;
+    /**
+     * The authorization prefix to use for requests, useful if you want to use
+     * bearer tokens
+     *
+     * @defaultValue `'Bot'`
+     */
+    authPrefix: 'Bearer' | 'Bot';
+    /**
+     * The cdn path
+     *
+     * @defaultValue `'https://cdn.discordapp.com'`
+     */
+    cdn: string;
+    /**
+     * How many requests to allow sending per second (Infinity for unlimited, 50 for the standard global limit used by Discord)
+     *
+     * @defaultValue `50`
+     */
+    globalRequestsPerSecond: number;
+    /**
+     * The amount of time in milliseconds that passes between each hash sweep. (defaults to 1h)
+     *
+     * @defaultValue `3_600_000`
+     */
+    handlerSweepInterval: number;
+    /**
+     * The maximum amount of time a hash can exist in milliseconds without being hit with a request (defaults to 24h)
+     *
+     * @defaultValue `86_400_000`
+     */
+    hashLifetime: number;
+    /**
+     * The amount of time in milliseconds that passes between each hash sweep. (defaults to 4h)
+     *
+     * @defaultValue `14_400_000`
+     */
+    hashSweepInterval: number;
+    /**
+     * Additional headers to send for all API requests
+     *
+     * @defaultValue `{}`
+     */
+    headers: Record<string, string>;
+    /**
+     * The number of invalid REST requests (those that return 401, 403, or 429) in a 10 minute window between emitted warnings (0 for no warnings).
+     * That is, if set to 500, warnings will be emitted at invalid request number 500, 1000, 1500, and so on.
+     *
+     * @defaultValue `0`
+     */
+    invalidRequestWarningInterval: number;
+    /**
+     * The method called to perform the actual HTTP request given a url and web `fetch` options
+     * For example, to use global fetch, simply provide `makeRequest: fetch`
+     *
+     * @defaultValue `undici.request`
+     */
+    makeRequest(url: string, init: RequestInit): Promise<ResponseLike>;
+    /**
+     * The extra offset to add to rate limits in milliseconds
+     *
+     * @defaultValue `50`
+     */
+    offset: number;
+    /**
+     * Determines how rate limiting and pre-emptive throttling should be handled.
+     * When an array of strings, each element is treated as a prefix for the request route
+     * (e.g. `/channels` to match any route starting with `/channels` such as `/channels/:id/messages`)
+     * for which to throw {@link RateLimitError}s. All other request routes will be queued normally
+     *
+     * @defaultValue `null`
+     */
+    rejectOnRateLimit: RateLimitQueueFilter | string[] | null;
+    /**
+     * The number of retries for errors with the 500 code, or errors
+     * that timeout
+     *
+     * @defaultValue `3`
+     */
+    retries: number;
+    /**
+     * The time to wait in milliseconds before a request is aborted
+     *
+     * @defaultValue `15_000`
+     */
+    timeout: number;
+    /**
+     * Extra information to add to the user agent
+     *
+     * @defaultValue DefaultUserAgentAppendix
+     */
+    userAgentAppendix: string;
+    /**
+     * The version of the API to use
+     *
+     * @defaultValue `'10'`
+     */
+    version: string;
+}
+/**
+ * Data emitted on `RESTEvents.RateLimited`
+ */
+interface RateLimitData {
+    /**
+     * Whether the rate limit that was reached was the global limit
+     */
+    global: boolean;
+    /**
+     * The bucket hash for this request
+     */
+    hash: string;
+    /**
+     * The amount of requests we can perform before locking requests
+     */
+    limit: number;
+    /**
+     * The major parameter of the route
+     *
+     * For example, in `/channels/x`, this will be `x`.
+     * If there is no major parameter (e.g: `/bot/gateway`) this will be `global`.
+     */
+    majorParameter: string;
+    /**
+     * The HTTP method being performed
+     */
+    method: string;
+    /**
+     * The route being hit in this request
+     */
+    route: string;
+    /**
+     * The time, in milliseconds, until the request-lock is reset
+     */
+    timeToReset: number;
+    /**
+     * The full URL for this request
+     */
+    url: string;
+}
+/**
+ * A function that determines whether the rate limit hit should throw an Error
+ */
+type RateLimitQueueFilter = (rateLimitData: RateLimitData) => Promise<boolean> | boolean;
+interface APIRequest {
+    /**
+     * The data that was used to form the body of this request
+     */
+    data: HandlerRequestData;
+    /**
+     * The HTTP method used in this request
+     */
+    method: string;
+    /**
+     * Additional HTTP options for this request
+     */
+    options: RequestInit;
+    /**
+     * The full path used to make the request
+     */
+    path: RouteLike;
+    /**
+     * The number of times this request has been attempted
+     */
+    retries: number;
+    /**
+     * The API route identifying the ratelimit for this request
+     */
+    route: string;
+}
+interface ResponseLike extends Pick<Response, 'arrayBuffer' | 'bodyUsed' | 'headers' | 'json' | 'ok' | 'status' | 'text'> {
+    body: Readable | ReadableStream | null;
+}
+interface InvalidRequestWarningData {
+    /**
+     * Number of invalid requests that have been made in the window
+     */
+    count: number;
+    /**
+     * Time in milliseconds remaining before the count resets
+     */
+    remainingTime: number;
+}
+interface RestEvents {
+    handlerSweep: [sweptHandlers: Collection<string, IHandler>];
+    hashSweep: [sweptHashes: Collection<string, HashData>];
+    invalidRequestWarning: [invalidRequestInfo: InvalidRequestWarningData];
+    newListener: [name: string, listener: (...args: any) => void];
+    rateLimited: [rateLimitInfo: RateLimitData];
+    removeListener: [name: string, listener: (...args: any) => void];
+    response: [request: APIRequest, response: ResponseLike];
+    restDebug: [info: string];
+}
+interface REST {
+    emit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);
+    off: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);
+    on: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);
+    once: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);
+    removeAllListeners: (<K extends keyof RestEvents>(event?: K) => this) & (<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);
+}
+declare class REST extends EventEmitter {
+    #private;
+    /**
+     * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
+     * performed by this manager.
+     */
+    agent: Dispatcher | null;
+    /**
+     * The number of requests remaining in the global bucket
+     */
+    globalRemaining: number;
+    /**
+     * The promise used to wait out the global rate limit
+     */
+    globalDelay: Promise<void> | null;
+    /**
+     * The timestamp at which the global bucket resets
+     */
+    globalReset: number;
+    /**
+     * API bucket hashes that are cached from provided routes
+     */
+    readonly hashes: Collection<string, HashData>;
+    /**
+     * Request handlers created from the bucket hash and the major parameters
+     */
+    readonly handlers: Collection<string, IHandler>;
+    private hashTimer;
+    private handlerTimer;
+    readonly options: RESTOptions;
+    readonly cdn: CDN;
+    readonly userAgent: string;
+    constructor(options?: Partial<RESTOptions>);
+    private setupSweepers;
+    /**
+     * Sets the default agent to use for requests performed by this manager
+     *
+     * @param agent - The agent to use
+     */
+    setAgent(agent: Dispatcher): this;
+    /**
+     * Sets the authorization token that should be used for requests
+     *
+     * @param token - The authorization token to use
+     */
+    setToken(token: string): this;
+    /**
+     * Creates a new rate limit handler from a hash, based on the hash and the major parameter
+     *
+     * @param hash - The hash for the route
+     * @param majorParameter - The major parameter for this handler
+     * @internal
+     */
+    private createHandler;
+    /**
+     * Formats the request data to a usable format for fetch
+     *
+     * @param request - The request data
+     */
+    private resolveRequest;
+    /**
+     * Stops the hash sweeping interval
+     */
+    clearHashSweeper(): void;
+    /**
+     * Stops the request handler sweeping interval
+     */
+    clearHandlerSweeper(): void;
+    /**
+     * Runs a get request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    get(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a delete request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    delete(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a post request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    post(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a put request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    put(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a patch request from the api
+     *
+     * @param fullRoute - The full route to query
+     * @param options - Optional request options
+     */
+    patch(fullRoute: RouteLike, options?: RequestData): Promise<unknown>;
+    /**
+     * Runs a request from the api
+     *
+     * @param options - Request options
+     */
+    request(options: InternalRequest): Promise<unknown>;
+    /**
+     * Runs a request from the API, yielding the raw Response object
+     *
+     * @param options - Request options
+     */
+    raw(options: InternalRequest): Promise<ResponseLike>;
+    /**
+     * Generates route data for an endpoint:method
+     *
+     * @param endpoint - The raw endpoint to generalize
+     * @param method - The HTTP method this endpoint is called without
+     * @internal
+     */
+    private static generateRouteData;
+}
+
+declare const DefaultUserAgent: `DiscordBot (https://discord.js.org, ${string})`;
+/**
+ * The default string to append onto the user agent.
+ */
+declare const DefaultUserAgentAppendix: string;
+declare const DefaultRestOptions: {
+    readonly agent: null;
+    readonly api: "https://discord.com/api";
+    readonly authPrefix: "Bot";
+    readonly cdn: "https://cdn.discordapp.com";
+    readonly headers: {};
+    readonly invalidRequestWarningInterval: 0;
+    readonly globalRequestsPerSecond: 50;
+    readonly offset: 50;
+    readonly rejectOnRateLimit: null;
+    readonly retries: 3;
+    readonly timeout: 15000;
+    readonly userAgentAppendix: string;
+    readonly version: "10";
+    readonly hashSweepInterval: 14400000;
+    readonly hashLifetime: 86400000;
+    readonly handlerSweepInterval: 3600000;
+    readonly makeRequest: (url: string, init: undici.RequestInit) => Promise<ResponseLike>;
+};
+/**
+ * The events that the REST manager emits
+ */
+declare enum RESTEvents {
+    Debug = "restDebug",
+    HandlerSweep = "handlerSweep",
+    HashSweep = "hashSweep",
+    InvalidRequestWarning = "invalidRequestWarning",
+    RateLimited = "rateLimited",
+    Response = "response"
+}
+declare const ALLOWED_EXTENSIONS: readonly ["webp", "png", "jpg", "jpeg", "gif"];
+declare const ALLOWED_STICKER_EXTENSIONS: readonly ["png", "json", "gif"];
+declare const ALLOWED_SIZES: readonly [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
+type ImageExtension = (typeof ALLOWED_EXTENSIONS)[number];
+type StickerExtension = (typeof ALLOWED_STICKER_EXTENSIONS)[number];
+type ImageSize = (typeof ALLOWED_SIZES)[number];
+declare const OverwrittenMimeTypes: {
+    readonly 'image/apng': "image/png";
+};
+declare const BurstHandlerMajorIdKey = "burst";
+
+/**
+ * The options used for image URLs
+ */
+interface BaseImageURLOptions {
+    /**
+     * The extension to use for the image URL
+     *
+     * @defaultValue `'webp'`
+     */
+    extension?: ImageExtension;
+    /**
+     * The size specified in the image URL
+     */
+    size?: ImageSize;
+}
+/**
+ * The options used for image URLs with animated content
+ */
+interface ImageURLOptions extends BaseImageURLOptions {
+    /**
+     * Whether or not to prefer the static version of an image asset.
+     */
+    forceStatic?: boolean;
+}
+/**
+ * The options to use when making a CDN URL
+ */
+interface MakeURLOptions {
+    /**
+     * The allowed extensions that can be used
+     */
+    allowedExtensions?: readonly string[];
+    /**
+     * The extension to use for the image URL
+     *
+     * @defaultValue `'webp'`
+     */
+    extension?: string | undefined;
+    /**
+     * The size specified in the image URL
+     */
+    size?: ImageSize;
+}
+/**
+ * The CDN link builder
+ */
+declare class CDN {
+    private readonly base;
+    constructor(base?: string);
+    /**
+     * Generates an app asset URL for a client's asset.
+     *
+     * @param clientId - The client id that has the asset
+     * @param assetHash - The hash provided by Discord for this asset
+     * @param options - Optional options for the asset
+     */
+    appAsset(clientId: string, assetHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates an app icon URL for a client's icon.
+     *
+     * @param clientId - The client id that has the icon
+     * @param iconHash - The hash provided by Discord for this icon
+     * @param options - Optional options for the icon
+     */
+    appIcon(clientId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates an avatar URL, e.g. for a user or a webhook.
+     *
+     * @param id - The id that has the icon
+     * @param avatarHash - The hash provided by Discord for this avatar
+     * @param options - Optional options for the avatar
+     */
+    avatar(id: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates a banner URL, e.g. for a user or a guild.
+     *
+     * @param id - The id that has the banner splash
+     * @param bannerHash - The hash provided by Discord for this banner
+     * @param options - Optional options for the banner
+     */
+    banner(id: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates an icon URL for a channel, e.g. a group DM.
+     *
+     * @param channelId - The channel id that has the icon
+     * @param iconHash - The hash provided by Discord for this channel
+     * @param options - Optional options for the icon
+     */
+    channelIcon(channelId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a default avatar URL
+     *
+     * @param index - The default avatar index
+     * @remarks
+     * To calculate the index for a user do `(userId >> 22) % 6`,
+     * or `discriminator % 5` if they're using the legacy username system.
+     */
+    defaultAvatar(index: number): string;
+    /**
+     * Generates a discovery splash URL for a guild's discovery splash.
+     *
+     * @param guildId - The guild id that has the discovery splash
+     * @param splashHash - The hash provided by Discord for this splash
+     * @param options - Optional options for the splash
+     */
+    discoverySplash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates an emoji's URL for an emoji.
+     *
+     * @param emojiId - The emoji id
+     * @param extension - The extension of the emoji
+     */
+    emoji(emojiId: string, extension?: ImageExtension): string;
+    /**
+     * Generates a guild member avatar URL.
+     *
+     * @param guildId - The id of the guild
+     * @param userId - The id of the user
+     * @param avatarHash - The hash provided by Discord for this avatar
+     * @param options - Optional options for the avatar
+     */
+    guildMemberAvatar(guildId: string, userId: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates a guild member banner URL.
+     *
+     * @param guildId - The id of the guild
+     * @param userId - The id of the user
+     * @param bannerHash - The hash provided by Discord for this banner
+     * @param options - Optional options for the banner
+     */
+    guildMemberBanner(guildId: string, userId: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates an icon URL, e.g. for a guild.
+     *
+     * @param id - The id that has the icon splash
+     * @param iconHash - The hash provided by Discord for this icon
+     * @param options - Optional options for the icon
+     */
+    icon(id: string, iconHash: string, options?: Readonly<ImageURLOptions>): string;
+    /**
+     * Generates a URL for the icon of a role
+     *
+     * @param roleId - The id of the role that has the icon
+     * @param roleIconHash - The hash provided by Discord for this role icon
+     * @param options - Optional options for the role icon
+     */
+    roleIcon(roleId: string, roleIconHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a guild invite splash URL for a guild's invite splash.
+     *
+     * @param guildId - The guild id that has the invite splash
+     * @param splashHash - The hash provided by Discord for this splash
+     * @param options - Optional options for the splash
+     */
+    splash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a sticker URL.
+     *
+     * @param stickerId - The sticker id
+     * @param extension - The extension of the sticker
+     * @privateRemarks
+     * Stickers cannot have a `.webp` extension, so we default to a `.png`
+     */
+    sticker(stickerId: string, extension?: StickerExtension): string;
+    /**
+     * Generates a sticker pack banner URL.
+     *
+     * @param bannerId - The banner id
+     * @param options - Optional options for the banner
+     */
+    stickerPackBanner(bannerId: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a team icon URL for a team's icon.
+     *
+     * @param teamId - The team id that has the icon
+     * @param iconHash - The hash provided by Discord for this icon
+     * @param options - Optional options for the icon
+     */
+    teamIcon(teamId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Generates a cover image for a guild scheduled event.
+     *
+     * @param scheduledEventId - The scheduled event id
+     * @param coverHash - The hash provided by discord for this cover image
+     * @param options - Optional options for the cover image
+     */
+    guildScheduledEventCover(scheduledEventId: string, coverHash: string, options?: Readonly<BaseImageURLOptions>): string;
+    /**
+     * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.
+     *
+     * @param route - The base cdn route
+     * @param hash - The hash provided by Discord for this icon
+     * @param options - Optional options for the link
+     */
+    private dynamicMakeURL;
+    /**
+     * Constructs the URL for the resource
+     *
+     * @param route - The base cdn route
+     * @param options - The extension/size options for the link
+     */
+    private makeURL;
+}
+
+export { APIRequest as A, BaseImageURLOptions as B, CDN as C, DefaultUserAgent as D, HandlerRequestData as H, InternalRequest as I, MakeURLOptions as M, OverwrittenMimeTypes as O, RawFile as R, StickerExtension as S, RateLimitData as a, ResponseLike as b, ImageURLOptions as c, RequestData as d, RequestHeaders as e, RequestMethod as f, RouteLike as g, RouteData as h, HashData as i, RESTOptions as j, RateLimitQueueFilter as k, InvalidRequestWarningData as l, RestEvents as m, REST as n, DefaultUserAgentAppendix as o, DefaultRestOptions as p, RESTEvents as q, ALLOWED_EXTENSIONS as r, ALLOWED_STICKER_EXTENSIONS as s, ALLOWED_SIZES as t, ImageExtension as u, ImageSize as v, BurstHandlerMajorIdKey as w };
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 1ec2dccdb3648d86c93b36a91f4d0e1dc9085166..48af4a317fcb20ec3ea902c1ba81e587aedab272 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,13 +1,13 @@
-import { R as RawFile, I as InternalRequest, a as RateLimitData, b as ResponseLike } from './CDN-5391fe24.js';
-export { s as ALLOWED_EXTENSIONS, u as ALLOWED_SIZES, t as ALLOWED_STICKER_EXTENSIONS, A as APIRequest, B as BaseImageURLOptions, x as BurstHandlerMajorIdKey, C as CDN, q as DefaultRestOptions, D as DefaultUserAgent, p as DefaultUserAgentAppendix, H as HandlerRequestData, i as HashData, v as ImageExtension, w as ImageSize, c as ImageURLOptions, m as InvalidRequestWarningData, M as MakeURLOptions, O as OverwrittenMimeTypes, o as REST, r as RESTEvents, k as RESTOptions, l as RateLimitQueueFilter, d as RequestData, e as RequestHeaders, j as RequestManager, f as RequestMethod, n as RestEvents, h as RouteData, g as RouteLike, S as StickerExtension } from './CDN-5391fe24.js';
+import { R as RawFile, I as InternalRequest, a as RateLimitData, b as ResponseLike } from './CDN-71b60987.js';
+export { r as ALLOWED_EXTENSIONS, t as ALLOWED_SIZES, s as ALLOWED_STICKER_EXTENSIONS, A as APIRequest, B as BaseImageURLOptions, w as BurstHandlerMajorIdKey, C as CDN, p as DefaultRestOptions, D as DefaultUserAgent, o as DefaultUserAgentAppendix, H as HandlerRequestData, i as HashData, u as ImageExtension, v as ImageSize, c as ImageURLOptions, l as InvalidRequestWarningData, M as MakeURLOptions, O as OverwrittenMimeTypes, n as REST, q as RESTEvents, j as RESTOptions, k as RateLimitQueueFilter, d as RequestData, e as RequestHeaders, f as RequestMethod, m as RestEvents, h as RouteData, g as RouteLike, S as StickerExtension } from './CDN-71b60987.js';
 import { URLSearchParams } from 'node:url';
 import { Snowflake } from 'discord-api-types/v10';
+import 'node:buffer';
 import 'node:events';
 import 'node:stream';
 import 'node:stream/web';
 import '@discordjs/collection';
 import 'undici';
-import 'node:buffer';
 
 interface DiscordErrorFieldInformation {
     code: string;
diff --git a/dist/index.js b/dist/index.js
index a9f1666c77ebf0c904ff869dc277882421f54345..5a45f61e89883842d6f9dc74b93de4cbf5a3b272 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -128,7 +128,6 @@ __export(src_exports, {
   REST: () => REST,
   RESTEvents: () => RESTEvents,
   RateLimitError: () => RateLimitError,
-  RequestManager: () => RequestManager,
   RequestMethod: () => RequestMethod,
   calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
   makeURLSearchParams: () => makeURLSearchParams,
@@ -526,7 +525,7 @@ var RateLimitError = class extends Error {
 };
 __name(RateLimitError, "RateLimitError");
 
-// src/lib/RequestManager.ts
+// src/lib/REST.ts
 init_cjs_shims();
 var import_node_buffer2 = require("buffer");
 var import_node_events = require("events");
@@ -639,7 +638,7 @@ function incrementInvalidCount(manager) {
 __name(incrementInvalidCount, "incrementInvalidCount");
 async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
   const controller = new AbortController();
-  const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), manager.options.timeout).unref();
+  const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), manager.options.timeout);
   if (requestData.signal) {
     if (requestData.signal.aborted)
       controller.abort();
@@ -663,7 +662,7 @@ async function makeNetworkRequest(manager, routeId, url, options, requestData, r
     manager.emit(
       "response" /* Response */,
       {
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         path: routeId.original,
         route: routeId.bucketRoute,
         options,
@@ -741,10 +740,10 @@ var BurstHandler = class {
    * @param retries - The number of retries this request has already attempted (recursion)
    */
   async runRequest(routeId, url, options, requestData, retries = 0) {
-    const method = options.method ?? "get";
+    const method = options.method ?? "GET" /* Get */;
     const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
     if (res === null) {
-      return this.runRequest(routeId, url, options, requestData, ++retries);
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.status;
     let retryAfter = 0;
@@ -787,7 +786,7 @@ var BurstHandler = class {
     } else {
       const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
       if (handled === null) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       return handled;
     }
@@ -955,7 +954,7 @@ var SequentialHandler = class {
       const rateLimitData = {
         timeToReset: timeout,
         limit: limit2,
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         hash: this.hash,
         url,
         route: routeId.bucketRoute,
@@ -976,10 +975,10 @@ var SequentialHandler = class {
       this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
     }
     this.manager.globalRemaining--;
-    const method = options.method ?? "get";
+    const method = options.method ?? "GET" /* Get */;
     const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
     if (res === null) {
-      return this.runRequest(routeId, url, options, requestData, ++retries);
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.status;
     let retryAfter = 0;
@@ -1073,7 +1072,7 @@ var SequentialHandler = class {
     } else {
       const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
       if (handled === null) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       return handled;
     }
@@ -1081,17 +1080,18 @@ var SequentialHandler = class {
 };
 __name(SequentialHandler, "SequentialHandler");
 
-// src/lib/RequestManager.ts
+// src/lib/REST.ts
 var getFileType = (0, import_util2.lazy)(async () => import("file-type"));
 var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Delete"] = "DELETE";
   RequestMethod2["Get"] = "GET";
+  RequestMethod2["Head"] = "HEAD";
   RequestMethod2["Patch"] = "PATCH";
   RequestMethod2["Post"] = "POST";
   RequestMethod2["Put"] = "PUT";
   return RequestMethod2;
 })(RequestMethod || {});
-var RequestManager = class extends import_node_events.EventEmitter {
+var REST = class extends import_node_events.EventEmitter {
   /**
    * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
    * performed by this manager.
@@ -1121,12 +1121,16 @@ var RequestManager = class extends import_node_events.EventEmitter {
   hashTimer;
   handlerTimer;
   options;
+  cdn;
+  userAgent;
   constructor(options) {
     super();
     this.options = { ...DefaultRestOptions, ...options };
     this.options.offset = Math.max(0, this.options.offset);
+    this.userAgent = `${DefaultUserAgent} ${this.options.userAgentAppendix}`.trimEnd();
+    this.cdn = new CDN(this.options.cdn);
     this.globalRemaining = this.options.globalRequestsPerSecond;
-    this.agent = options.agent ?? null;
+    this.agent = options?.agent ?? null;
     this.setupSweepers();
   }
   setupSweepers() {
@@ -1151,7 +1155,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
           return shouldSweep;
         });
         this.emit("hashSweep" /* HashSweep */, sweptHashes);
-      }, this.options.hashSweepInterval).unref();
+      }, this.options.hashSweepInterval);
     }
     if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.handlerSweepInterval);
@@ -1161,12 +1165,12 @@ var RequestManager = class extends import_node_events.EventEmitter {
           const { inactive } = val;
           if (inactive) {
             sweptHandlers.set(key, val);
+            this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
           }
-          this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
           return inactive;
         });
         this.emit("handlerSweep" /* HandlerSweep */, sweptHandlers);
-      }, this.options.handlerSweepInterval).unref();
+      }, this.options.handlerSweepInterval);
     }
   }
   /**
@@ -1187,27 +1191,6 @@ var RequestManager = class extends import_node_events.EventEmitter {
     this.#token = token;
     return this;
   }
-  /**
-   * Queues a request to be sent
-   *
-   * @param request - All the information needed to make a request
-   * @returns The response from the api request
-   */
-  async queueRequest(request2) {
-    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
-    const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
-      value: `Global(${request2.method}:${routeId.bucketRoute})`,
-      lastAccess: -1
-    };
-    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
-    const { url, fetchOptions } = await this.resolveRequest(request2);
-    return handler.queueRequest(routeId, url, fetchOptions, {
-      body: request2.body,
-      files: request2.files,
-      auth: request2.auth !== false,
-      signal: request2.signal
-    });
-  }
   /**
    * Creates a new rate limit handler from a hash, based on the hash and the major parameter
    *
@@ -1236,7 +1219,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
     }
     const headers = {
       ...this.options.headers,
-      "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
+      "User-Agent": this.userAgent
     };
     if (request2.auth !== false) {
       if (!this.#token) {
@@ -1249,7 +1232,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
     }
     const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
     let finalBody;
-    let additionalHeaders = {};
+    let additionalHeaders;
     if (request2.files?.length) {
       const formData = new FormData();
       for (const [index, file] of request2.files.entries()) {
@@ -1289,7 +1272,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
     const method = request2.method.toUpperCase();
     const fetchOptions = {
       // Set body to null on get / head requests. This does not follow fetch spec (likely because it causes subtle bugs) but is aligned with what request was doing
-      body: ["GET", "HEAD"].includes(method) ? null : finalBody,
+      body: ["GET" /* Get */, "HEAD" /* Head */].includes(method) ? null : finalBody,
       headers: { ...request2.headers, ...additionalHeaders, ...headers },
       method,
       // Prioritize setting an agent per request, use the agent for this instance otherwise.
@@ -1309,91 +1292,13 @@ var RequestManager = class extends import_node_events.EventEmitter {
   clearHandlerSweeper() {
     (0, import_node_timers2.clearInterval)(this.handlerTimer);
   }
-  /**
-   * Generates route data for an endpoint:method
-   *
-   * @param endpoint - The raw endpoint to generalize
-   * @param method - The HTTP method this endpoint is called without
-   * @internal
-   */
-  static generateRouteData(endpoint, method) {
-    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
-      return {
-        majorParameter: BurstHandlerMajorIdKey,
-        bucketRoute: "/interactions/:id/:token/callback",
-        original: endpoint
-      };
-    }
-    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
-    const majorId = majorIdMatch?.[1] ?? "global";
-    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
-    let exceptions = "";
-    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
-      const id = /\d{17,19}$/.exec(endpoint)[0];
-      const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
-      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
-        exceptions += "/Delete Old Message";
-      }
-    }
-    return {
-      majorParameter: majorId,
-      bucketRoute: baseRoute + exceptions,
-      original: endpoint
-    };
-  }
-};
-__name(RequestManager, "RequestManager");
-
-// src/lib/REST.ts
-init_cjs_shims();
-var import_node_events2 = require("events");
-var REST = class extends import_node_events2.EventEmitter {
-  cdn;
-  requestManager;
-  constructor(options = {}) {
-    super();
-    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
-    this.requestManager = new RequestManager(options).on("restDebug" /* Debug */, this.emit.bind(this, "restDebug" /* Debug */)).on("rateLimited" /* RateLimited */, this.emit.bind(this, "rateLimited" /* RateLimited */)).on("invalidRequestWarning" /* InvalidRequestWarning */, this.emit.bind(this, "invalidRequestWarning" /* InvalidRequestWarning */)).on("hashSweep" /* HashSweep */, this.emit.bind(this, "hashSweep" /* HashSweep */));
-    this.on("newListener", (name, listener) => {
-      if (name === "response" /* Response */)
-        this.requestManager.on(name, listener);
-    });
-    this.on("removeListener", (name, listener) => {
-      if (name === "response" /* Response */)
-        this.requestManager.off(name, listener);
-    });
-  }
-  /**
-   * Gets the agent set for this instance
-   */
-  getAgent() {
-    return this.requestManager.agent;
-  }
-  /**
-   * Sets the default agent to use for requests performed by this instance
-   *
-   * @param agent - Sets the agent to use
-   */
-  setAgent(agent) {
-    this.requestManager.setAgent(agent);
-    return this;
-  }
-  /**
-   * Sets the authorization token that should be used for requests
-   *
-   * @param token - The authorization token to use
-   */
-  setToken(token) {
-    this.requestManager.setToken(token);
-    return this;
-  }
   /**
    * Runs a get request from the api
    *
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async get(fullRoute, options = {}) {
+  async get(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "GET" /* Get */ });
   }
   /**
@@ -1402,7 +1307,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async delete(fullRoute, options = {}) {
+  async delete(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "DELETE" /* Delete */ });
   }
   /**
@@ -1411,7 +1316,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async post(fullRoute, options = {}) {
+  async post(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "POST" /* Post */ });
   }
   /**
@@ -1420,7 +1325,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async put(fullRoute, options = {}) {
+  async put(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PUT" /* Put */ });
   }
   /**
@@ -1429,7 +1334,7 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async patch(fullRoute, options = {}) {
+  async patch(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PATCH" /* Patch */ });
   }
   /**
@@ -1447,7 +1352,51 @@ var REST = class extends import_node_events2.EventEmitter {
    * @param options - Request options
    */
   async raw(options) {
-    return this.requestManager.queueRequest(options);
+    const routeId = REST.generateRouteData(options.fullRoute, options.method);
+    const hash = this.hashes.get(`${options.method}:${routeId.bucketRoute}`) ?? {
+      value: `Global(${options.method}:${routeId.bucketRoute})`,
+      lastAccess: -1
+    };
+    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
+    const { url, fetchOptions } = await this.resolveRequest(options);
+    return handler.queueRequest(routeId, url, fetchOptions, {
+      body: options.body,
+      files: options.files,
+      auth: options.auth !== false,
+      signal: options.signal
+    });
+  }
+  /**
+   * Generates route data for an endpoint:method
+   *
+   * @param endpoint - The raw endpoint to generalize
+   * @param method - The HTTP method this endpoint is called without
+   * @internal
+   */
+  static generateRouteData(endpoint, method) {
+    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
+      return {
+        majorParameter: BurstHandlerMajorIdKey,
+        bucketRoute: "/interactions/:id/:token/callback",
+        original: endpoint
+      };
+    }
+    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
+    const majorId = majorIdMatch?.[1] ?? "global";
+    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
+    let exceptions = "";
+    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
+      const id = /\d{17,19}$/.exec(endpoint)[0];
+      const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
+      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
+        exceptions += "/Delete Old Message";
+      }
+    }
+    return {
+      majorParameter: majorId,
+      bucketRoute: baseRoute + exceptions,
+      original: endpoint
+    };
   }
 };
 __name(REST, "REST");
@@ -1470,7 +1419,6 @@ var version = "1.7.2-dev.1686312270-6c2242f.0";
   REST,
   RESTEvents,
   RateLimitError,
-  RequestManager,
   RequestMethod,
   calculateUserDefaultAvatarIndex,
   makeURLSearchParams,
diff --git a/dist/index.mjs b/dist/index.mjs
index fe49e6414afef5e4f7afab0e6cc9ec90ad669676..773893cc25c0efe3adbcd84a8376b7598b594662 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -481,7 +481,7 @@ var RateLimitError = class extends Error {
 };
 __name(RateLimitError, "RateLimitError");
 
-// src/lib/RequestManager.ts
+// src/lib/REST.ts
 init_esm_shims();
 import { Blob as Blob2, Buffer as Buffer3 } from "node:buffer";
 import { EventEmitter } from "node:events";
@@ -594,7 +594,7 @@ function incrementInvalidCount(manager) {
 __name(incrementInvalidCount, "incrementInvalidCount");
 async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
   const controller = new AbortController();
-  const timeout = setTimeout(() => controller.abort(), manager.options.timeout).unref();
+  const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
   if (requestData.signal) {
     if (requestData.signal.aborted)
       controller.abort();
@@ -618,7 +618,7 @@ async function makeNetworkRequest(manager, routeId, url, options, requestData, r
     manager.emit(
       "response" /* Response */,
       {
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         path: routeId.original,
         route: routeId.bucketRoute,
         options,
@@ -696,10 +696,10 @@ var BurstHandler = class {
    * @param retries - The number of retries this request has already attempted (recursion)
    */
   async runRequest(routeId, url, options, requestData, retries = 0) {
-    const method = options.method ?? "get";
+    const method = options.method ?? "GET" /* Get */;
     const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
     if (res === null) {
-      return this.runRequest(routeId, url, options, requestData, ++retries);
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.status;
     let retryAfter = 0;
@@ -742,7 +742,7 @@ var BurstHandler = class {
     } else {
       const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
       if (handled === null) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       return handled;
     }
@@ -910,7 +910,7 @@ var SequentialHandler = class {
       const rateLimitData = {
         timeToReset: timeout,
         limit: limit2,
-        method: options.method ?? "get",
+        method: options.method ?? "GET" /* Get */,
         hash: this.hash,
         url,
         route: routeId.bucketRoute,
@@ -931,10 +931,10 @@ var SequentialHandler = class {
       this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
     }
     this.manager.globalRemaining--;
-    const method = options.method ?? "get";
+    const method = options.method ?? "GET" /* Get */;
     const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
     if (res === null) {
-      return this.runRequest(routeId, url, options, requestData, ++retries);
+      return this.runRequest(routeId, url, options, requestData, retries + 1);
     }
     const status = res.status;
     let retryAfter = 0;
@@ -1028,7 +1028,7 @@ var SequentialHandler = class {
     } else {
       const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
       if (handled === null) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       return handled;
     }
@@ -1036,17 +1036,18 @@ var SequentialHandler = class {
 };
 __name(SequentialHandler, "SequentialHandler");
 
-// src/lib/RequestManager.ts
+// src/lib/REST.ts
 var getFileType = lazy2(async () => import("file-type"));
 var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
   RequestMethod2["Delete"] = "DELETE";
   RequestMethod2["Get"] = "GET";
+  RequestMethod2["Head"] = "HEAD";
   RequestMethod2["Patch"] = "PATCH";
   RequestMethod2["Post"] = "POST";
   RequestMethod2["Put"] = "PUT";
   return RequestMethod2;
 })(RequestMethod || {});
-var RequestManager = class extends EventEmitter {
+var REST = class extends EventEmitter {
   /**
    * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
    * performed by this manager.
@@ -1076,12 +1077,16 @@ var RequestManager = class extends EventEmitter {
   hashTimer;
   handlerTimer;
   options;
+  cdn;
+  userAgent;
   constructor(options) {
     super();
     this.options = { ...DefaultRestOptions, ...options };
     this.options.offset = Math.max(0, this.options.offset);
+    this.userAgent = `${DefaultUserAgent} ${this.options.userAgentAppendix}`.trimEnd();
+    this.cdn = new CDN(this.options.cdn);
     this.globalRemaining = this.options.globalRequestsPerSecond;
-    this.agent = options.agent ?? null;
+    this.agent = options?.agent ?? null;
     this.setupSweepers();
   }
   setupSweepers() {
@@ -1106,7 +1111,7 @@ var RequestManager = class extends EventEmitter {
           return shouldSweep;
         });
         this.emit("hashSweep" /* HashSweep */, sweptHashes);
-      }, this.options.hashSweepInterval).unref();
+      }, this.options.hashSweepInterval);
     }
     if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.handlerSweepInterval);
@@ -1116,12 +1121,12 @@ var RequestManager = class extends EventEmitter {
           const { inactive } = val;
           if (inactive) {
             sweptHandlers.set(key, val);
+            this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
           }
-          this.emit("restDebug" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);
           return inactive;
         });
         this.emit("handlerSweep" /* HandlerSweep */, sweptHandlers);
-      }, this.options.handlerSweepInterval).unref();
+      }, this.options.handlerSweepInterval);
     }
   }
   /**
@@ -1142,27 +1147,6 @@ var RequestManager = class extends EventEmitter {
     this.#token = token;
     return this;
   }
-  /**
-   * Queues a request to be sent
-   *
-   * @param request - All the information needed to make a request
-   * @returns The response from the api request
-   */
-  async queueRequest(request2) {
-    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
-    const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
-      value: `Global(${request2.method}:${routeId.bucketRoute})`,
-      lastAccess: -1
-    };
-    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
-    const { url, fetchOptions } = await this.resolveRequest(request2);
-    return handler.queueRequest(routeId, url, fetchOptions, {
-      body: request2.body,
-      files: request2.files,
-      auth: request2.auth !== false,
-      signal: request2.signal
-    });
-  }
   /**
    * Creates a new rate limit handler from a hash, based on the hash and the major parameter
    *
@@ -1191,7 +1175,7 @@ var RequestManager = class extends EventEmitter {
     }
     const headers = {
       ...this.options.headers,
-      "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
+      "User-Agent": this.userAgent
     };
     if (request2.auth !== false) {
       if (!this.#token) {
@@ -1204,7 +1188,7 @@ var RequestManager = class extends EventEmitter {
     }
     const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
     let finalBody;
-    let additionalHeaders = {};
+    let additionalHeaders;
     if (request2.files?.length) {
       const formData = new FormData();
       for (const [index, file] of request2.files.entries()) {
@@ -1244,7 +1228,7 @@ var RequestManager = class extends EventEmitter {
     const method = request2.method.toUpperCase();
     const fetchOptions = {
       // Set body to null on get / head requests. This does not follow fetch spec (likely because it causes subtle bugs) but is aligned with what request was doing
-      body: ["GET", "HEAD"].includes(method) ? null : finalBody,
+      body: ["GET" /* Get */, "HEAD" /* Head */].includes(method) ? null : finalBody,
       headers: { ...request2.headers, ...additionalHeaders, ...headers },
       method,
       // Prioritize setting an agent per request, use the agent for this instance otherwise.
@@ -1264,91 +1248,13 @@ var RequestManager = class extends EventEmitter {
   clearHandlerSweeper() {
     clearInterval(this.handlerTimer);
   }
-  /**
-   * Generates route data for an endpoint:method
-   *
-   * @param endpoint - The raw endpoint to generalize
-   * @param method - The HTTP method this endpoint is called without
-   * @internal
-   */
-  static generateRouteData(endpoint, method) {
-    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
-      return {
-        majorParameter: BurstHandlerMajorIdKey,
-        bucketRoute: "/interactions/:id/:token/callback",
-        original: endpoint
-      };
-    }
-    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
-    const majorId = majorIdMatch?.[1] ?? "global";
-    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
-    let exceptions = "";
-    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
-      const id = /\d{17,19}$/.exec(endpoint)[0];
-      const timestamp = DiscordSnowflake.timestampFrom(id);
-      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
-        exceptions += "/Delete Old Message";
-      }
-    }
-    return {
-      majorParameter: majorId,
-      bucketRoute: baseRoute + exceptions,
-      original: endpoint
-    };
-  }
-};
-__name(RequestManager, "RequestManager");
-
-// src/lib/REST.ts
-init_esm_shims();
-import { EventEmitter as EventEmitter2 } from "node:events";
-var REST = class extends EventEmitter2 {
-  cdn;
-  requestManager;
-  constructor(options = {}) {
-    super();
-    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
-    this.requestManager = new RequestManager(options).on("restDebug" /* Debug */, this.emit.bind(this, "restDebug" /* Debug */)).on("rateLimited" /* RateLimited */, this.emit.bind(this, "rateLimited" /* RateLimited */)).on("invalidRequestWarning" /* InvalidRequestWarning */, this.emit.bind(this, "invalidRequestWarning" /* InvalidRequestWarning */)).on("hashSweep" /* HashSweep */, this.emit.bind(this, "hashSweep" /* HashSweep */));
-    this.on("newListener", (name, listener) => {
-      if (name === "response" /* Response */)
-        this.requestManager.on(name, listener);
-    });
-    this.on("removeListener", (name, listener) => {
-      if (name === "response" /* Response */)
-        this.requestManager.off(name, listener);
-    });
-  }
-  /**
-   * Gets the agent set for this instance
-   */
-  getAgent() {
-    return this.requestManager.agent;
-  }
-  /**
-   * Sets the default agent to use for requests performed by this instance
-   *
-   * @param agent - Sets the agent to use
-   */
-  setAgent(agent) {
-    this.requestManager.setAgent(agent);
-    return this;
-  }
-  /**
-   * Sets the authorization token that should be used for requests
-   *
-   * @param token - The authorization token to use
-   */
-  setToken(token) {
-    this.requestManager.setToken(token);
-    return this;
-  }
   /**
    * Runs a get request from the api
    *
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async get(fullRoute, options = {}) {
+  async get(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "GET" /* Get */ });
   }
   /**
@@ -1357,7 +1263,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async delete(fullRoute, options = {}) {
+  async delete(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "DELETE" /* Delete */ });
   }
   /**
@@ -1366,7 +1272,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async post(fullRoute, options = {}) {
+  async post(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "POST" /* Post */ });
   }
   /**
@@ -1375,7 +1281,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async put(fullRoute, options = {}) {
+  async put(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PUT" /* Put */ });
   }
   /**
@@ -1384,7 +1290,7 @@ var REST = class extends EventEmitter2 {
    * @param fullRoute - The full route to query
    * @param options - Optional request options
    */
-  async patch(fullRoute, options = {}) {
+  async patch(fullRoute, options) {
     return this.request({ ...options, fullRoute, method: "PATCH" /* Patch */ });
   }
   /**
@@ -1402,7 +1308,51 @@ var REST = class extends EventEmitter2 {
    * @param options - Request options
    */
   async raw(options) {
-    return this.requestManager.queueRequest(options);
+    const routeId = REST.generateRouteData(options.fullRoute, options.method);
+    const hash = this.hashes.get(`${options.method}:${routeId.bucketRoute}`) ?? {
+      value: `Global(${options.method}:${routeId.bucketRoute})`,
+      lastAccess: -1
+    };
+    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
+    const { url, fetchOptions } = await this.resolveRequest(options);
+    return handler.queueRequest(routeId, url, fetchOptions, {
+      body: options.body,
+      files: options.files,
+      auth: options.auth !== false,
+      signal: options.signal
+    });
+  }
+  /**
+   * Generates route data for an endpoint:method
+   *
+   * @param endpoint - The raw endpoint to generalize
+   * @param method - The HTTP method this endpoint is called without
+   * @internal
+   */
+  static generateRouteData(endpoint, method) {
+    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
+      return {
+        majorParameter: BurstHandlerMajorIdKey,
+        bucketRoute: "/interactions/:id/:token/callback",
+        original: endpoint
+      };
+    }
+    const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
+    const majorId = majorIdMatch?.[1] ?? "global";
+    const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
+    let exceptions = "";
+    if (method === "DELETE" /* Delete */ && baseRoute === "/channels/:id/messages/:id") {
+      const id = /\d{17,19}$/.exec(endpoint)[0];
+      const timestamp = DiscordSnowflake.timestampFrom(id);
+      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
+        exceptions += "/Delete Old Message";
+      }
+    }
+    return {
+      majorParameter: majorId,
+      bucketRoute: baseRoute + exceptions,
+      original: endpoint
+    };
   }
 };
 __name(REST, "REST");
@@ -1424,7 +1374,6 @@ export {
   REST,
   RESTEvents,
   RateLimitError,
-  RequestManager,
   RequestMethod,
   calculateUserDefaultAvatarIndex,
   makeURLSearchParams,
diff --git a/dist/strategies/undiciRequest.d.ts b/dist/strategies/undiciRequest.d.ts
index 93720b4b1ea2a57e25e2755a8760e828037cac34..fce9e4b388f0e8340bcf9bbde5e6b33cc6fcf8bd 100644
--- a/dist/strategies/undiciRequest.d.ts
+++ b/dist/strategies/undiciRequest.d.ts
@@ -1,11 +1,11 @@
 import { request, RequestInit } from 'undici';
-import { b as ResponseLike } from '../CDN-5391fe24.js';
+import { b as ResponseLike } from '../CDN-71b60987.js';
+import 'node:buffer';
 import 'node:events';
 import 'node:stream';
 import 'node:stream/web';
-import '@discordjs/collection';
-import 'node:buffer';
 import 'node:url';
+import '@discordjs/collection';
 
 type RequestOptions = Exclude<Parameters<typeof request>[1], undefined>;
 declare function makeRequest(url: string, init: RequestInit): Promise<ResponseLike>;
