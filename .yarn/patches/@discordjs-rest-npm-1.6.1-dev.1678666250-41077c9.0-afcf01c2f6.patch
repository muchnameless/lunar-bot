diff --git a/dist/index.d.ts b/dist/index.d.ts
index f3ea4790d3b55669ec0dfdda8844ab3897b8d0b8..1c77fc3c39eb0d5bae0ec9e4e54dcfa5a7b573e7 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -43,6 +43,7 @@ type ImageSize = (typeof ALLOWED_SIZES)[number];
 declare const OverwrittenMimeTypes: {
     readonly 'image/apng': "image/png";
 };
+declare const BurstHandlerMajorIdKey = "burst";
 
 /**
  * The options used for image URLs
@@ -752,6 +753,12 @@ declare class RequestManager extends EventEmitter {
      * Stops the request handler sweeping interval
      */
     clearHandlerSweeper(): void;
+    /**
+     * Increment the invalid request count and emit warning if necessary
+     *
+     * @internal
+     */
+    incrementInvalidCount(): void;
     /**
      * Generates route data for an endpoint:method
      *
@@ -867,4 +874,4 @@ declare function parseResponse(res: Dispatcher.ResponseData): Promise<unknown>;
  */
 declare const version: string;
 
-export { ALLOWED_EXTENSIONS, ALLOWED_SIZES, ALLOWED_STICKER_EXTENSIONS, APIRequest, BaseImageURLOptions, CDN, DefaultRestOptions, DefaultUserAgent, DiscordAPIError, DiscordErrorData, HTTPError, HandlerRequestData, HashData, ImageExtension, ImageSize, ImageURLOptions, InternalRequest, InvalidRequestWarningData, MakeURLOptions, OAuthErrorData, OverwrittenMimeTypes, REST, RESTEvents, RESTOptions, RateLimitData, RateLimitError, RateLimitQueueFilter, RawFile, RequestBody, RequestData, RequestHeaders, RequestManager, RequestMethod, RequestOptions, RestEvents, RouteData, RouteLike, StickerExtension, makeURLSearchParams, parseResponse, version };
+export { ALLOWED_EXTENSIONS, ALLOWED_SIZES, ALLOWED_STICKER_EXTENSIONS, APIRequest, BaseImageURLOptions, BurstHandlerMajorIdKey, CDN, DefaultRestOptions, DefaultUserAgent, DiscordAPIError, DiscordErrorData, HTTPError, HandlerRequestData, HashData, ImageExtension, ImageSize, ImageURLOptions, InternalRequest, InvalidRequestWarningData, MakeURLOptions, OAuthErrorData, OverwrittenMimeTypes, REST, RESTEvents, RESTOptions, RateLimitData, RateLimitError, RateLimitQueueFilter, RawFile, RequestBody, RequestData, RequestHeaders, RequestManager, RequestMethod, RequestOptions, RestEvents, RouteData, RouteLike, StickerExtension, makeURLSearchParams, parseResponse, version };
diff --git a/dist/index.js b/dist/index.js
index 42e45b3cfea4c38daa8a57033237cd678fab5d48..6139b34fdb9b7420e709da687f9e231a53cdeb0f 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -34,6 +34,7 @@ __export(src_exports, {
   ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
   ALLOWED_SIZES: () => ALLOWED_SIZES,
   ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
   CDN: () => CDN,
   DefaultRestOptions: () => DefaultRestOptions,
   DefaultUserAgent: () => DefaultUserAgent,
@@ -119,6 +120,7 @@ var OverwrittenMimeTypes = {
   // https://github.com/discordjs/discord.js/issues/8557
   "image/apng": "image/png"
 };
+var BurstHandlerMajorIdKey = "burst";
 
 // src/lib/CDN.ts
 var CDN = class {
@@ -456,16 +458,15 @@ __name(RateLimitError, "RateLimitError");
 // src/lib/RequestManager.ts
 var import_node_buffer2 = require("buffer");
 var import_node_events = require("events");
-var import_node_timers2 = require("timers");
+var import_node_timers3 = require("timers");
 var import_collection = require("@discordjs/collection");
 var import_util = require("@discordjs/util");
 var import_snowflake = require("@sapphire/snowflake");
-var import_undici4 = require("undici");
+var import_undici5 = require("undici");
 
-// src/lib/handlers/SequentialHandler.ts
+// src/lib/handlers/BurstHandler.ts
 var import_node_timers = require("timers");
 var import_promises = require("timers/promises");
-var import_async_queue = require("@sapphire/async-queue");
 var import_undici3 = require("undici");
 
 // src/lib/utils/utils.ts
@@ -582,10 +583,141 @@ function shouldRetry(error) {
   return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
 }
 __name(shouldRetry, "shouldRetry");
+async function onRateLimit(manager, rateLimitData) {
+  const { options } = manager;
+  if (!options.rejectOnRateLimit)
+    return;
+  const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
+  if (shouldThrow) {
+    throw new RateLimitError(rateLimitData);
+  }
+}
+__name(onRateLimit, "onRateLimit");
+
+// src/lib/handlers/BurstHandler.ts
+var BurstHandler = class {
+  /**
+  * @param manager - The request manager
+  * @param hash - The hash that this RequestHandler handles
+  * @param majorParameter - The major parameter for this handler
+  */
+  constructor(manager, hash, majorParameter) {
+    this.manager = manager;
+    this.hash = hash;
+    this.majorParameter = majorParameter;
+    this.inactive = false;
+    this.id = `${hash}:${majorParameter}`;
+  }
+  /**
+  * Emits a debug message
+  *
+  * @param message - The message to debug
+  */
+  debug(message) {
+    this.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);
+  }
+  /**
+  * {@inheritDoc IHandler.queueRequest}
+  */
+  async queueRequest(routeId, url, options, requestData) {
+    return this.runRequest(routeId, url, options, requestData);
+  }
+  /**
+  * The method that actually makes the request to the api, and updates info about the bucket accordingly
+  *
+  * @param routeId - The generalized api route with literal ids for major parameters
+  * @param url - The fully resolved url to make the request to
+  * @param options - The fetch options needed to make the request
+  * @param requestData - Extra data from the user's request needed for errors and additional processing
+  * @param retries - The number of retries this request has already attempted (recursion)
+  */
+  async runRequest(routeId, url, options, requestData, retries = 0) {
+    const method = options.method ?? "get";
+    const controller = new AbortController();
+    const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), this.manager.options.timeout);
+    if (requestData.signal) {
+      const signal = requestData.signal;
+      if (signal.aborted)
+        controller.abort();
+      else
+        signal.addEventListener("abort", () => controller.abort());
+    }
+    let res;
+    try {
+      res = await (0, import_undici3.request)(url, {
+        ...options,
+        signal: controller.signal
+      });
+    } catch (error) {
+      if (!(error instanceof Error))
+        throw error;
+      if (shouldRetry(error) && retries !== this.manager.options.retries) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      throw error;
+    } finally {
+      (0, import_node_timers.clearTimeout)(timeout);
+    }
+    const status = res.statusCode;
+    let retryAfter = 0;
+    const retry = parseHeader(res.headers["retry-after"]);
+    if (retry)
+      retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
+    if (status === 401 || status === 403 || status === 429) {
+      this.manager.incrementInvalidCount();
+    }
+    if (status >= 200 && status < 300) {
+      return res;
+    } else if (status === 429) {
+      const isGlobal = res.headers["x-ratelimit-global"] !== void 0;
+      await onRateLimit(this.manager, {
+        timeToReset: retryAfter,
+        limit: Number.POSITIVE_INFINITY,
+        method,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      });
+      this.debug([
+        "Encountered unexpected 429 rate limit",
+        `  Global         : ${isGlobal}`,
+        `  Method         : ${method}`,
+        `  URL            : ${url}`,
+        `  Bucket         : ${routeId.bucketRoute}`,
+        `  Major parameter: ${routeId.majorParameter}`,
+        `  Hash           : ${this.hash}`,
+        `  Limit          : ${Number.POSITIVE_INFINITY}`,
+        `  Retry After    : ${retryAfter}ms`,
+        `  Sublimit       : None`
+      ].join("\n"));
+      await (0, import_promises.setTimeout)(retryAfter);
+      return this.runRequest(routeId, url, options, requestData, retries);
+    } else if (status >= 500 && status < 600) {
+      if (retries !== this.manager.options.retries) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      throw new HTTPError(status, method, url, requestData);
+    } else {
+      if (status >= 400 && status < 500) {
+        if (status === 401 && requestData.auth) {
+          this.manager.setToken(null);
+        }
+        const data = await parseResponse(res);
+        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
+      }
+      return res;
+    }
+  }
+};
+__name(BurstHandler, "BurstHandler");
 
 // src/lib/handlers/SequentialHandler.ts
-var invalidCount = 0;
-var invalidCountResetTime = null;
+var import_node_timers2 = require("timers");
+var import_promises2 = require("timers/promises");
+var import_async_queue = require("@sapphire/async-queue");
+var import_undici4 = require("undici");
 var QueueType;
 (function(QueueType2) {
   QueueType2[QueueType2["Standard"] = 0] = "Standard";
@@ -670,21 +802,9 @@ var SequentialHandler = class {
   * @param time - The amount of time to delay all requests for
   */
   async globalDelayFor(time) {
-    await (0, import_promises.setTimeout)(time);
+    await (0, import_promises2.setTimeout)(time);
     this.manager.globalDelay = null;
   }
-  /*
-  * Determines whether the request should be queued or whether a RateLimitError should be thrown
-  */
-  async onRateLimit(rateLimitData) {
-    const { options } = this.manager;
-    if (!options.rejectOnRateLimit)
-      return;
-    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
-    if (shouldThrow) {
-      throw new RateLimitError(rateLimitData);
-    }
-  }
   /**
   * {@inheritDoc IHandler.queueRequest}
   */
@@ -747,7 +867,7 @@ var SequentialHandler = class {
       } else {
         limit2 = this.limit;
         timeout2 = this.timeToReset;
-        delay = (0, import_promises.setTimeout)(timeout2);
+        delay = (0, import_promises2.setTimeout)(timeout2);
       }
       const rateLimitData = {
         timeToReset: timeout2,
@@ -760,7 +880,7 @@ var SequentialHandler = class {
         global: isGlobal
       };
       this.manager.emit(RESTEvents.RateLimited, rateLimitData);
-      await this.onRateLimit(rateLimitData);
+      await onRateLimit(this.manager, rateLimitData);
       if (isGlobal) {
         this.debug(`Global rate limit hit, blocking all requests for ${timeout2}ms`);
       } else {
@@ -775,7 +895,7 @@ var SequentialHandler = class {
     this.manager.globalRemaining--;
     const method = options.method ?? "get";
     const controller = new AbortController();
-    const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), this.manager.options.timeout).unref();
+    const timeout = (0, import_node_timers2.setTimeout)(() => controller.abort(), this.manager.options.timeout);
     if (requestData.signal) {
       const signal = requestData.signal;
       if (signal.aborted)
@@ -785,7 +905,7 @@ var SequentialHandler = class {
     }
     let res;
     try {
-      res = await (0, import_undici3.request)(url, {
+      res = await (0, import_undici4.request)(url, {
         ...options,
         signal: controller.signal
       });
@@ -793,11 +913,11 @@ var SequentialHandler = class {
       if (!(error instanceof Error))
         throw error;
       if (shouldRetry(error) && retries !== this.manager.options.retries) {
-        return await this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       throw error;
     } finally {
-      (0, import_node_timers.clearTimeout)(timeout);
+      (0, import_node_timers2.clearTimeout)(timeout);
     }
     if (this.manager.listenerCount(RESTEvents.Response)) {
       this.manager.emit(RESTEvents.Response, {
@@ -849,18 +969,7 @@ var SequentialHandler = class {
       }
     }
     if (status === 401 || status === 403 || status === 429) {
-      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
-        invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
-        invalidCount = 0;
-      }
-      invalidCount++;
-      const emitInvalid = this.manager.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.options.invalidRequestWarningInterval === 0;
-      if (emitInvalid) {
-        this.manager.emit(RESTEvents.InvalidRequestWarning, {
-          count: invalidCount,
-          remainingTime: invalidCountResetTime - Date.now()
-        });
-      }
+      this.manager.incrementInvalidCount();
     }
     if (status >= 200 && status < 300) {
       return res;
@@ -875,7 +984,7 @@ var SequentialHandler = class {
         limit2 = this.limit;
         timeout2 = this.timeToReset;
       }
-      await this.onRateLimit({
+      await onRateLimit(this.manager, {
         timeToReset: timeout2,
         limit: limit2,
         method,
@@ -906,7 +1015,7 @@ var SequentialHandler = class {
         }
         this.#sublimitPromise?.resolve();
         this.#sublimitPromise = null;
-        await (0, import_promises.setTimeout)(sublimitTimeout);
+        await (0, import_promises2.setTimeout)(sublimitTimeout);
         let resolve;
         const promise = new Promise((res2) => resolve = res2);
         this.#sublimitPromise = {
@@ -921,7 +1030,7 @@ var SequentialHandler = class {
       return this.runRequest(routeId, url, options, requestData, retries);
     } else if (status >= 500 && status < 600) {
       if (retries !== this.manager.options.retries) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       throw new HTTPError(status, method, url, requestData);
     } else {
@@ -948,6 +1057,8 @@ var RequestMethod;
   RequestMethod2["Post"] = "POST";
   RequestMethod2["Put"] = "PUT";
 })(RequestMethod || (RequestMethod = {}));
+var invalidCount = 0;
+var invalidCountResetTime = null;
 var RequestManager = class extends import_node_events.EventEmitter {
   /**
   * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
@@ -990,7 +1101,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
     }, "validateMaxInterval");
     if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.hashSweepInterval);
-      this.hashTimer = (0, import_node_timers2.setInterval)(() => {
+      this.hashTimer = (0, import_node_timers3.setInterval)(() => {
         const sweptHashes = new import_collection.Collection();
         const currentDate = Date.now();
         this.hashes.sweep((val, key) => {
@@ -1004,11 +1115,11 @@ var RequestManager = class extends import_node_events.EventEmitter {
           return shouldSweep;
         });
         this.emit(RESTEvents.HashSweep, sweptHashes);
-      }, this.options.hashSweepInterval).unref();
+      }, this.options.hashSweepInterval);
     }
     if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.handlerSweepInterval);
-      this.handlerTimer = (0, import_node_timers2.setInterval)(() => {
+      this.handlerTimer = (0, import_node_timers3.setInterval)(() => {
         const sweptHandlers = new import_collection.Collection();
         this.handlers.sweep((val, key) => {
           const { inactive } = val;
@@ -1019,7 +1130,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
           return inactive;
         });
         this.emit(RESTEvents.HandlerSweep, sweptHandlers);
-      }, this.options.handlerSweepInterval).unref();
+      }, this.options.handlerSweepInterval);
     }
   }
   /**
@@ -1046,19 +1157,19 @@ var RequestManager = class extends import_node_events.EventEmitter {
   * @param request - All the information needed to make a request
   * @returns The response from the api request
   */
-  async queueRequest(request2) {
-    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
-    const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
-      value: `Global(${request2.method}:${routeId.bucketRoute})`,
+  async queueRequest(request3) {
+    const routeId = RequestManager.generateRouteData(request3.fullRoute, request3.method);
+    const hash = this.hashes.get(`${request3.method}:${routeId.bucketRoute}`) ?? {
+      value: `Global(${request3.method}:${routeId.bucketRoute})`,
       lastAccess: -1
     };
     const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
-    const { url, fetchOptions } = await this.resolveRequest(request2);
+    const { url, fetchOptions } = await this.resolveRequest(request3);
     return handler.queueRequest(routeId, url, fetchOptions, {
-      body: request2.body,
-      files: request2.files,
-      auth: request2.auth !== false,
-      signal: request2.signal
+      body: request3.body,
+      files: request3.files,
+      auth: request3.auth !== false,
+      signal: request3.signal
     });
   }
   /**
@@ -1069,7 +1180,7 @@ var RequestManager = class extends import_node_events.EventEmitter {
   * @internal
   */
   createHandler(hash, majorParameter) {
-    const queue = new SequentialHandler(this, hash, majorParameter);
+    const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
     this.handlers.set(queue.id, queue);
     return queue;
   }
@@ -1078,11 +1189,11 @@ var RequestManager = class extends import_node_events.EventEmitter {
   *
   * @param request - The request data
   */
-  async resolveRequest(request2) {
+  async resolveRequest(request3) {
     const { options } = this;
     let query = "";
-    if (request2.query) {
-      const resolvedQuery = request2.query.toString();
+    if (request3.query) {
+      const resolvedQuery = request3.query.toString();
       if (resolvedQuery !== "") {
         query = `?${resolvedQuery}`;
       }
@@ -1091,21 +1202,21 @@ var RequestManager = class extends import_node_events.EventEmitter {
       ...this.options.headers,
       "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
     };
-    if (request2.auth !== false) {
+    if (request3.auth !== false) {
       if (!this.#token) {
         throw new Error("Expected token to be set for this request, but none was present");
       }
-      headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
+      headers.Authorization = `${request3.authPrefix ?? this.options.authPrefix} ${this.#token}`;
     }
-    if (request2.reason?.length) {
-      headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
+    if (request3.reason?.length) {
+      headers["X-Audit-Log-Reason"] = encodeURIComponent(request3.reason);
     }
-    const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
+    const url = `${options.api}${request3.versioned === false ? "" : `/v${options.version}`}${request3.fullRoute}${query}`;
     let finalBody;
     let additionalHeaders = {};
-    if (request2.files?.length) {
-      const formData = new import_undici4.FormData();
-      for (const [index, file] of request2.files.entries()) {
+    if (request3.files?.length) {
+      const formData = new import_undici5.FormData();
+      for (const [index, file] of request3.files.entries()) {
         const fileKey = file.key ?? `files[${index}]`;
         if (import_node_buffer2.Buffer.isBuffer(file.data)) {
           const { fileTypeFromBuffer } = await getFileType();
@@ -1129,21 +1240,21 @@ var RequestManager = class extends import_node_events.EventEmitter {
           }), file.name);
         }
       }
-      if (request2.body != null) {
-        if (request2.appendToFormData) {
-          for (const [key, value] of Object.entries(request2.body)) {
+      if (request3.body != null) {
+        if (request3.appendToFormData) {
+          for (const [key, value] of Object.entries(request3.body)) {
             formData.append(key, value);
           }
         } else {
-          formData.append("payload_json", JSON.stringify(request2.body));
+          formData.append("payload_json", JSON.stringify(request3.body));
         }
       }
       finalBody = formData;
-    } else if (request2.body != null) {
-      if (request2.passThroughBody) {
-        finalBody = request2.body;
+    } else if (request3.body != null) {
+      if (request3.passThroughBody) {
+        finalBody = request3.body;
       } else {
-        finalBody = JSON.stringify(request2.body);
+        finalBody = JSON.stringify(request3.body);
         additionalHeaders = {
           "Content-Type": "application/json"
         };
@@ -1152,16 +1263,16 @@ var RequestManager = class extends import_node_events.EventEmitter {
     finalBody = await resolveBody(finalBody);
     const fetchOptions = {
       headers: {
-        ...request2.headers,
+        ...request3.headers,
         ...additionalHeaders,
         ...headers
       },
-      method: request2.method.toUpperCase()
+      method: request3.method.toUpperCase()
     };
     if (finalBody !== void 0) {
       fetchOptions.body = finalBody;
     }
-    fetchOptions.dispatcher = request2.dispatcher ?? this.agent ?? void 0;
+    fetchOptions.dispatcher = request3.dispatcher ?? this.agent ?? void 0;
     return {
       url,
       fetchOptions
@@ -1171,13 +1282,32 @@ var RequestManager = class extends import_node_events.EventEmitter {
   * Stops the hash sweeping interval
   */
   clearHashSweeper() {
-    (0, import_node_timers2.clearInterval)(this.hashTimer);
+    (0, import_node_timers3.clearInterval)(this.hashTimer);
   }
   /**
   * Stops the request handler sweeping interval
   */
   clearHandlerSweeper() {
-    (0, import_node_timers2.clearInterval)(this.handlerTimer);
+    (0, import_node_timers3.clearInterval)(this.handlerTimer);
+  }
+  /**
+  * Increment the invalid request count and emit warning if necessary
+  *
+  * @internal
+  */
+  incrementInvalidCount() {
+    if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
+      invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
+      invalidCount = 0;
+    }
+    invalidCount++;
+    const emitInvalid = this.options.invalidRequestWarningInterval > 0 && invalidCount % this.options.invalidRequestWarningInterval === 0;
+    if (emitInvalid) {
+      this.emit(RESTEvents.InvalidRequestWarning, {
+        count: invalidCount,
+        remainingTime: invalidCountResetTime - Date.now()
+      });
+    }
   }
   /**
   * Generates route data for an endpoint:method
@@ -1187,6 +1317,13 @@ var RequestManager = class extends import_node_events.EventEmitter {
   * @internal
   */
   static generateRouteData(endpoint, method) {
+    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
+      return {
+        majorParameter: BurstHandlerMajorIdKey,
+        bucketRoute: "/interactions/:id/:token/callback",
+        original: endpoint
+      };
+    }
     const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
     const majorId = majorIdMatch?.[1] ?? "global";
     const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
@@ -1339,6 +1476,7 @@ var version = "[VI]{{inject}}[/VI]";
   ALLOWED_EXTENSIONS,
   ALLOWED_SIZES,
   ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey,
   CDN,
   DefaultRestOptions,
   DefaultUserAgent,
diff --git a/dist/index.mjs b/dist/index.mjs
index de35a9e869a039185a63fafe44d4bc6bf21e50c4..614e09aa5099c252c07940d697f7000e874a4591 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -69,6 +69,7 @@ var OverwrittenMimeTypes = {
   // https://github.com/discordjs/discord.js/issues/8557
   "image/apng": "image/png"
 };
+var BurstHandlerMajorIdKey = "burst";
 
 // src/lib/CDN.ts
 var CDN = class {
@@ -412,10 +413,9 @@ import { lazy } from "@discordjs/util";
 import { DiscordSnowflake } from "@sapphire/snowflake";
 import { FormData as FormData2 } from "undici";
 
-// src/lib/handlers/SequentialHandler.ts
+// src/lib/handlers/BurstHandler.ts
 import { setTimeout, clearTimeout } from "node:timers";
 import { setTimeout as sleep } from "node:timers/promises";
-import { AsyncQueue } from "@sapphire/async-queue";
 import { request } from "undici";
 
 // src/lib/utils/utils.ts
@@ -532,10 +532,141 @@ function shouldRetry(error) {
   return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
 }
 __name(shouldRetry, "shouldRetry");
+async function onRateLimit(manager, rateLimitData) {
+  const { options } = manager;
+  if (!options.rejectOnRateLimit)
+    return;
+  const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
+  if (shouldThrow) {
+    throw new RateLimitError(rateLimitData);
+  }
+}
+__name(onRateLimit, "onRateLimit");
+
+// src/lib/handlers/BurstHandler.ts
+var BurstHandler = class {
+  /**
+  * @param manager - The request manager
+  * @param hash - The hash that this RequestHandler handles
+  * @param majorParameter - The major parameter for this handler
+  */
+  constructor(manager, hash, majorParameter) {
+    this.manager = manager;
+    this.hash = hash;
+    this.majorParameter = majorParameter;
+    this.inactive = false;
+    this.id = `${hash}:${majorParameter}`;
+  }
+  /**
+  * Emits a debug message
+  *
+  * @param message - The message to debug
+  */
+  debug(message) {
+    this.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);
+  }
+  /**
+  * {@inheritDoc IHandler.queueRequest}
+  */
+  async queueRequest(routeId, url, options, requestData) {
+    return this.runRequest(routeId, url, options, requestData);
+  }
+  /**
+  * The method that actually makes the request to the api, and updates info about the bucket accordingly
+  *
+  * @param routeId - The generalized api route with literal ids for major parameters
+  * @param url - The fully resolved url to make the request to
+  * @param options - The fetch options needed to make the request
+  * @param requestData - Extra data from the user's request needed for errors and additional processing
+  * @param retries - The number of retries this request has already attempted (recursion)
+  */
+  async runRequest(routeId, url, options, requestData, retries = 0) {
+    const method = options.method ?? "get";
+    const controller = new AbortController();
+    const timeout = setTimeout(() => controller.abort(), this.manager.options.timeout);
+    if (requestData.signal) {
+      const signal = requestData.signal;
+      if (signal.aborted)
+        controller.abort();
+      else
+        signal.addEventListener("abort", () => controller.abort());
+    }
+    let res;
+    try {
+      res = await request(url, {
+        ...options,
+        signal: controller.signal
+      });
+    } catch (error) {
+      if (!(error instanceof Error))
+        throw error;
+      if (shouldRetry(error) && retries !== this.manager.options.retries) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      throw error;
+    } finally {
+      clearTimeout(timeout);
+    }
+    const status = res.statusCode;
+    let retryAfter = 0;
+    const retry = parseHeader(res.headers["retry-after"]);
+    if (retry)
+      retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
+    if (status === 401 || status === 403 || status === 429) {
+      this.manager.incrementInvalidCount();
+    }
+    if (status >= 200 && status < 300) {
+      return res;
+    } else if (status === 429) {
+      const isGlobal = res.headers["x-ratelimit-global"] !== void 0;
+      await onRateLimit(this.manager, {
+        timeToReset: retryAfter,
+        limit: Number.POSITIVE_INFINITY,
+        method,
+        hash: this.hash,
+        url,
+        route: routeId.bucketRoute,
+        majorParameter: this.majorParameter,
+        global: isGlobal
+      });
+      this.debug([
+        "Encountered unexpected 429 rate limit",
+        `  Global         : ${isGlobal}`,
+        `  Method         : ${method}`,
+        `  URL            : ${url}`,
+        `  Bucket         : ${routeId.bucketRoute}`,
+        `  Major parameter: ${routeId.majorParameter}`,
+        `  Hash           : ${this.hash}`,
+        `  Limit          : ${Number.POSITIVE_INFINITY}`,
+        `  Retry After    : ${retryAfter}ms`,
+        `  Sublimit       : None`
+      ].join("\n"));
+      await sleep(retryAfter);
+      return this.runRequest(routeId, url, options, requestData, retries);
+    } else if (status >= 500 && status < 600) {
+      if (retries !== this.manager.options.retries) {
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
+      }
+      throw new HTTPError(status, method, url, requestData);
+    } else {
+      if (status >= 400 && status < 500) {
+        if (status === 401 && requestData.auth) {
+          this.manager.setToken(null);
+        }
+        const data = await parseResponse(res);
+        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
+      }
+      return res;
+    }
+  }
+};
+__name(BurstHandler, "BurstHandler");
 
 // src/lib/handlers/SequentialHandler.ts
-var invalidCount = 0;
-var invalidCountResetTime = null;
+import { setTimeout as setTimeout2, clearTimeout as clearTimeout2 } from "node:timers";
+import { setTimeout as sleep2 } from "node:timers/promises";
+import { AsyncQueue } from "@sapphire/async-queue";
+import { request as request2 } from "undici";
 var QueueType;
 (function(QueueType2) {
   QueueType2[QueueType2["Standard"] = 0] = "Standard";
@@ -620,21 +751,9 @@ var SequentialHandler = class {
   * @param time - The amount of time to delay all requests for
   */
   async globalDelayFor(time) {
-    await sleep(time);
+    await sleep2(time);
     this.manager.globalDelay = null;
   }
-  /*
-  * Determines whether the request should be queued or whether a RateLimitError should be thrown
-  */
-  async onRateLimit(rateLimitData) {
-    const { options } = this.manager;
-    if (!options.rejectOnRateLimit)
-      return;
-    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
-    if (shouldThrow) {
-      throw new RateLimitError(rateLimitData);
-    }
-  }
   /**
   * {@inheritDoc IHandler.queueRequest}
   */
@@ -697,7 +816,7 @@ var SequentialHandler = class {
       } else {
         limit2 = this.limit;
         timeout2 = this.timeToReset;
-        delay = sleep(timeout2);
+        delay = sleep2(timeout2);
       }
       const rateLimitData = {
         timeToReset: timeout2,
@@ -710,7 +829,7 @@ var SequentialHandler = class {
         global: isGlobal
       };
       this.manager.emit(RESTEvents.RateLimited, rateLimitData);
-      await this.onRateLimit(rateLimitData);
+      await onRateLimit(this.manager, rateLimitData);
       if (isGlobal) {
         this.debug(`Global rate limit hit, blocking all requests for ${timeout2}ms`);
       } else {
@@ -725,7 +844,7 @@ var SequentialHandler = class {
     this.manager.globalRemaining--;
     const method = options.method ?? "get";
     const controller = new AbortController();
-    const timeout = setTimeout(() => controller.abort(), this.manager.options.timeout).unref();
+    const timeout = setTimeout2(() => controller.abort(), this.manager.options.timeout);
     if (requestData.signal) {
       const signal = requestData.signal;
       if (signal.aborted)
@@ -735,7 +854,7 @@ var SequentialHandler = class {
     }
     let res;
     try {
-      res = await request(url, {
+      res = await request2(url, {
         ...options,
         signal: controller.signal
       });
@@ -743,11 +862,11 @@ var SequentialHandler = class {
       if (!(error instanceof Error))
         throw error;
       if (shouldRetry(error) && retries !== this.manager.options.retries) {
-        return await this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       throw error;
     } finally {
-      clearTimeout(timeout);
+      clearTimeout2(timeout);
     }
     if (this.manager.listenerCount(RESTEvents.Response)) {
       this.manager.emit(RESTEvents.Response, {
@@ -799,18 +918,7 @@ var SequentialHandler = class {
       }
     }
     if (status === 401 || status === 403 || status === 429) {
-      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
-        invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
-        invalidCount = 0;
-      }
-      invalidCount++;
-      const emitInvalid = this.manager.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.options.invalidRequestWarningInterval === 0;
-      if (emitInvalid) {
-        this.manager.emit(RESTEvents.InvalidRequestWarning, {
-          count: invalidCount,
-          remainingTime: invalidCountResetTime - Date.now()
-        });
-      }
+      this.manager.incrementInvalidCount();
     }
     if (status >= 200 && status < 300) {
       return res;
@@ -825,7 +933,7 @@ var SequentialHandler = class {
         limit2 = this.limit;
         timeout2 = this.timeToReset;
       }
-      await this.onRateLimit({
+      await onRateLimit(this.manager, {
         timeToReset: timeout2,
         limit: limit2,
         method,
@@ -856,7 +964,7 @@ var SequentialHandler = class {
         }
         this.#sublimitPromise?.resolve();
         this.#sublimitPromise = null;
-        await sleep(sublimitTimeout);
+        await sleep2(sublimitTimeout);
         let resolve;
         const promise = new Promise((res2) => resolve = res2);
         this.#sublimitPromise = {
@@ -871,7 +979,7 @@ var SequentialHandler = class {
       return this.runRequest(routeId, url, options, requestData, retries);
     } else if (status >= 500 && status < 600) {
       if (retries !== this.manager.options.retries) {
-        return this.runRequest(routeId, url, options, requestData, ++retries);
+        return this.runRequest(routeId, url, options, requestData, retries + 1);
       }
       throw new HTTPError(status, method, url, requestData);
     } else {
@@ -898,6 +1006,8 @@ var RequestMethod;
   RequestMethod2["Post"] = "POST";
   RequestMethod2["Put"] = "PUT";
 })(RequestMethod || (RequestMethod = {}));
+var invalidCount = 0;
+var invalidCountResetTime = null;
 var RequestManager = class extends EventEmitter {
   /**
   * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
@@ -954,7 +1064,7 @@ var RequestManager = class extends EventEmitter {
           return shouldSweep;
         });
         this.emit(RESTEvents.HashSweep, sweptHashes);
-      }, this.options.hashSweepInterval).unref();
+      }, this.options.hashSweepInterval);
     }
     if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
       validateMaxInterval(this.options.handlerSweepInterval);
@@ -969,7 +1079,7 @@ var RequestManager = class extends EventEmitter {
           return inactive;
         });
         this.emit(RESTEvents.HandlerSweep, sweptHandlers);
-      }, this.options.handlerSweepInterval).unref();
+      }, this.options.handlerSweepInterval);
     }
   }
   /**
@@ -996,19 +1106,19 @@ var RequestManager = class extends EventEmitter {
   * @param request - All the information needed to make a request
   * @returns The response from the api request
   */
-  async queueRequest(request2) {
-    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
-    const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
-      value: `Global(${request2.method}:${routeId.bucketRoute})`,
+  async queueRequest(request3) {
+    const routeId = RequestManager.generateRouteData(request3.fullRoute, request3.method);
+    const hash = this.hashes.get(`${request3.method}:${routeId.bucketRoute}`) ?? {
+      value: `Global(${request3.method}:${routeId.bucketRoute})`,
       lastAccess: -1
     };
     const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
-    const { url, fetchOptions } = await this.resolveRequest(request2);
+    const { url, fetchOptions } = await this.resolveRequest(request3);
     return handler.queueRequest(routeId, url, fetchOptions, {
-      body: request2.body,
-      files: request2.files,
-      auth: request2.auth !== false,
-      signal: request2.signal
+      body: request3.body,
+      files: request3.files,
+      auth: request3.auth !== false,
+      signal: request3.signal
     });
   }
   /**
@@ -1019,7 +1129,7 @@ var RequestManager = class extends EventEmitter {
   * @internal
   */
   createHandler(hash, majorParameter) {
-    const queue = new SequentialHandler(this, hash, majorParameter);
+    const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
     this.handlers.set(queue.id, queue);
     return queue;
   }
@@ -1028,11 +1138,11 @@ var RequestManager = class extends EventEmitter {
   *
   * @param request - The request data
   */
-  async resolveRequest(request2) {
+  async resolveRequest(request3) {
     const { options } = this;
     let query = "";
-    if (request2.query) {
-      const resolvedQuery = request2.query.toString();
+    if (request3.query) {
+      const resolvedQuery = request3.query.toString();
       if (resolvedQuery !== "") {
         query = `?${resolvedQuery}`;
       }
@@ -1041,21 +1151,21 @@ var RequestManager = class extends EventEmitter {
       ...this.options.headers,
       "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
     };
-    if (request2.auth !== false) {
+    if (request3.auth !== false) {
       if (!this.#token) {
         throw new Error("Expected token to be set for this request, but none was present");
       }
-      headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
+      headers.Authorization = `${request3.authPrefix ?? this.options.authPrefix} ${this.#token}`;
     }
-    if (request2.reason?.length) {
-      headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
+    if (request3.reason?.length) {
+      headers["X-Audit-Log-Reason"] = encodeURIComponent(request3.reason);
     }
-    const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
+    const url = `${options.api}${request3.versioned === false ? "" : `/v${options.version}`}${request3.fullRoute}${query}`;
     let finalBody;
     let additionalHeaders = {};
-    if (request2.files?.length) {
+    if (request3.files?.length) {
       const formData = new FormData2();
-      for (const [index, file] of request2.files.entries()) {
+      for (const [index, file] of request3.files.entries()) {
         const fileKey = file.key ?? `files[${index}]`;
         if (Buffer3.isBuffer(file.data)) {
           const { fileTypeFromBuffer } = await getFileType();
@@ -1079,21 +1189,21 @@ var RequestManager = class extends EventEmitter {
           }), file.name);
         }
       }
-      if (request2.body != null) {
-        if (request2.appendToFormData) {
-          for (const [key, value] of Object.entries(request2.body)) {
+      if (request3.body != null) {
+        if (request3.appendToFormData) {
+          for (const [key, value] of Object.entries(request3.body)) {
             formData.append(key, value);
           }
         } else {
-          formData.append("payload_json", JSON.stringify(request2.body));
+          formData.append("payload_json", JSON.stringify(request3.body));
         }
       }
       finalBody = formData;
-    } else if (request2.body != null) {
-      if (request2.passThroughBody) {
-        finalBody = request2.body;
+    } else if (request3.body != null) {
+      if (request3.passThroughBody) {
+        finalBody = request3.body;
       } else {
-        finalBody = JSON.stringify(request2.body);
+        finalBody = JSON.stringify(request3.body);
         additionalHeaders = {
           "Content-Type": "application/json"
         };
@@ -1102,16 +1212,16 @@ var RequestManager = class extends EventEmitter {
     finalBody = await resolveBody(finalBody);
     const fetchOptions = {
       headers: {
-        ...request2.headers,
+        ...request3.headers,
         ...additionalHeaders,
         ...headers
       },
-      method: request2.method.toUpperCase()
+      method: request3.method.toUpperCase()
     };
     if (finalBody !== void 0) {
       fetchOptions.body = finalBody;
     }
-    fetchOptions.dispatcher = request2.dispatcher ?? this.agent ?? void 0;
+    fetchOptions.dispatcher = request3.dispatcher ?? this.agent ?? void 0;
     return {
       url,
       fetchOptions
@@ -1130,6 +1240,25 @@ var RequestManager = class extends EventEmitter {
     clearInterval(this.handlerTimer);
   }
   /**
+  * Increment the invalid request count and emit warning if necessary
+  *
+  * @internal
+  */
+  incrementInvalidCount() {
+    if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
+      invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
+      invalidCount = 0;
+    }
+    invalidCount++;
+    const emitInvalid = this.options.invalidRequestWarningInterval > 0 && invalidCount % this.options.invalidRequestWarningInterval === 0;
+    if (emitInvalid) {
+      this.emit(RESTEvents.InvalidRequestWarning, {
+        count: invalidCount,
+        remainingTime: invalidCountResetTime - Date.now()
+      });
+    }
+  }
+  /**
   * Generates route data for an endpoint:method
   *
   * @param endpoint - The raw endpoint to generalize
@@ -1137,6 +1266,13 @@ var RequestManager = class extends EventEmitter {
   * @internal
   */
   static generateRouteData(endpoint, method) {
+    if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
+      return {
+        majorParameter: BurstHandlerMajorIdKey,
+        bucketRoute: "/interactions/:id/:token/callback",
+        original: endpoint
+      };
+    }
     const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
     const majorId = majorIdMatch?.[1] ?? "global";
     const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
@@ -1288,6 +1424,7 @@ export {
   ALLOWED_EXTENSIONS,
   ALLOWED_SIZES,
   ALLOWED_STICKER_EXTENSIONS,
+  BurstHandlerMajorIdKey,
   CDN,
   DefaultRestOptions,
   DefaultUserAgent,
